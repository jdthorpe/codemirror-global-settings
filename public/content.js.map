{"version":3,"file":"content.js","sources":["webpack:///webpack/bootstrap","webpack:///./ext/content.js","webpack:///./ext/inject.js","webpack:///./ext/styles.js","webpack:///./CodeMirror/theme/3024-day.css","webpack:///./CodeMirror/theme/3024-night.css","webpack:///./CodeMirror/theme/abcdef.css","webpack:///./CodeMirror/theme/ambiance-mobile.css","webpack:///./CodeMirror/theme/ambiance.css","webpack:///./CodeMirror/theme/base16-dark.css","webpack:///./CodeMirror/theme/base16-light.css","webpack:///./CodeMirror/theme/bespin.css","webpack:///./CodeMirror/theme/blackboard.css","webpack:///./CodeMirror/theme/cobalt.css","webpack:///./CodeMirror/theme/colorforth.css","webpack:///./CodeMirror/theme/darcula.css","webpack:///./CodeMirror/theme/dracula.css","webpack:///./CodeMirror/theme/duotone-dark.css","webpack:///./CodeMirror/theme/duotone-light.css","webpack:///./CodeMirror/theme/eclipse.css","webpack:///./CodeMirror/theme/elegant.css","webpack:///./CodeMirror/theme/erlang-dark.css","webpack:///./CodeMirror/theme/gruvbox-dark.css","webpack:///./CodeMirror/theme/hopscotch.css","webpack:///./CodeMirror/theme/icecoder.css","webpack:///./CodeMirror/theme/idea.css","webpack:///./CodeMirror/theme/isotope.css","webpack:///./CodeMirror/theme/lesser-dark.css","webpack:///./CodeMirror/theme/liquibyte.css","webpack:///./CodeMirror/theme/lucario.css","webpack:///./CodeMirror/theme/material.css","webpack:///./CodeMirror/theme/mbo.css","webpack:///./CodeMirror/theme/mdn-like.css","webpack:///./CodeMirror/theme/midnight.css","webpack:///./CodeMirror/theme/monokai.css","webpack:///./CodeMirror/theme/neat.css","webpack:///./CodeMirror/theme/neo.css","webpack:///./CodeMirror/theme/night.css","webpack:///./CodeMirror/theme/nord.css","webpack:///./CodeMirror/theme/oceanic-next.css","webpack:///./CodeMirror/theme/panda-syntax.css","webpack:///./CodeMirror/theme/paraiso-dark.css","webpack:///./CodeMirror/theme/paraiso-light.css","webpack:///./CodeMirror/theme/pastel-on-dark.css","webpack:///./CodeMirror/theme/railscasts.css","webpack:///./CodeMirror/theme/rubyblue.css","webpack:///./CodeMirror/theme/seti.css","webpack:///./CodeMirror/theme/shadowfox.css","webpack:///./CodeMirror/theme/solarized.css","webpack:///./CodeMirror/theme/ssms.css","webpack:///./CodeMirror/theme/the-matrix.css","webpack:///./CodeMirror/theme/tomorrow-night-bright.css","webpack:///./CodeMirror/theme/tomorrow-night-eighties.css","webpack:///./CodeMirror/theme/ttcn.css","webpack:///./CodeMirror/theme/twilight.css","webpack:///./CodeMirror/theme/vibrant-ink.css","webpack:///./CodeMirror/theme/xq-dark.css","webpack:///./CodeMirror/theme/xq-light.css","webpack:///./CodeMirror/theme/yeti.css","webpack:///./CodeMirror/theme/yonce.css","webpack:///./CodeMirror/theme/zenburn.css","webpack:///./ext/page.js","webpack:///./ext/vim.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./ext/content.js\");\n","import vim_bindings from '!!raw-loader!./vim';\nimport page from '!!raw-loader!./page';\nimport { inject_script } from './inject';\nimport styles from './styles';\nchrome.storage.local.get(['vim_disable_keys', 'default_disable_keys', 'theme', 'keyMap'], function (results) {\n  inject_script(\"var __mapName = \\\"\".concat(results.keyMap, \"\\\";\\nvar __vim_disable_keys = \").concat(results.vim_disable_keys || '', \";\\nvar __default_disable_keys = \").concat(results.default_disable_keys || '', \";\\nvar __addKeyMap = \").concat(vim_bindings, \";\\nvar __styleName = \\\"\").concat(results.theme in styles ? results.theme : 'deault', \"\\\"\\nvar __styleCSS = `\").concat(results.theme in styles ? styles[results.theme] : '', \"`\\n\").concat(page));\n});","export function inject_script(src) {\n  var script = document.constructor.prototype.createElement.call(document, 'script');\n  script.innerHTML = src;\n  script.charset = 'utf-8';\n  document.documentElement.appendChild(script);\n  script.parentNode.removeChild(script);\n}\nexport function inject_style(src) {\n  var script = document.constructor.prototype.createElement.call(document, 'style');\n  script.innerHTML = src;\n  script.charset = 'utf-8';\n  document.documentElement.appendChild(script);\n}","import _3024_day from '!!raw-loader!../CodeMirror/theme/3024-day.css';\nimport _3024_night from '!!raw-loader!../CodeMirror/theme/3024-night.css';\nimport abcdef from '!!raw-loader!../CodeMirror/theme/abcdef.css';\nimport ambiance_mobile from '!!raw-loader!../CodeMirror/theme/ambiance-mobile.css';\nimport ambiance from '!!raw-loader!../CodeMirror/theme/ambiance.css';\nimport base16_dark from '!!raw-loader!../CodeMirror/theme/base16-dark.css';\nimport base16_light from '!!raw-loader!../CodeMirror/theme/base16-light.css';\nimport bespin from '!!raw-loader!../CodeMirror/theme/bespin.css';\nimport blackboard from '!!raw-loader!../CodeMirror/theme/blackboard.css';\nimport cobalt from '!!raw-loader!../CodeMirror/theme/cobalt.css';\nimport colorforth from '!!raw-loader!../CodeMirror/theme/colorforth.css';\nimport darcula from '!!raw-loader!../CodeMirror/theme/darcula.css';\nimport dracula from '!!raw-loader!../CodeMirror/theme/dracula.css';\nimport duotone_dark from '!!raw-loader!../CodeMirror/theme/duotone-dark.css';\nimport duotone_light from '!!raw-loader!../CodeMirror/theme/duotone-light.css';\nimport eclipse from '!!raw-loader!../CodeMirror/theme/eclipse.css';\nimport elegant from '!!raw-loader!../CodeMirror/theme/elegant.css';\nimport erlang_dark from '!!raw-loader!../CodeMirror/theme/erlang-dark.css';\nimport gruvbox_dark from '!!raw-loader!../CodeMirror/theme/gruvbox-dark.css';\nimport hopscotch from '!!raw-loader!../CodeMirror/theme/hopscotch.css';\nimport icecoder from '!!raw-loader!../CodeMirror/theme/icecoder.css';\nimport idea from '!!raw-loader!../CodeMirror/theme/idea.css';\nimport isotope from '!!raw-loader!../CodeMirror/theme/isotope.css';\nimport lesser_dark from '!!raw-loader!../CodeMirror/theme/lesser-dark.css';\nimport liquibyte from '!!raw-loader!../CodeMirror/theme/liquibyte.css';\nimport lucario from '!!raw-loader!../CodeMirror/theme/lucario.css';\nimport material from '!!raw-loader!../CodeMirror/theme/material.css';\nimport mbo from '!!raw-loader!../CodeMirror/theme/mbo.css';\nimport mdn_like from '!!raw-loader!../CodeMirror/theme/mdn-like.css';\nimport midnight from '!!raw-loader!../CodeMirror/theme/midnight.css';\nimport monokai from '!!raw-loader!../CodeMirror/theme/monokai.css';\nimport neat from '!!raw-loader!../CodeMirror/theme/neat.css';\nimport neo from '!!raw-loader!../CodeMirror/theme/neo.css';\nimport night from '!!raw-loader!../CodeMirror/theme/night.css';\nimport nord from '!!raw-loader!../CodeMirror/theme/nord.css';\nimport oceanic_next from '!!raw-loader!../CodeMirror/theme/oceanic-next.css';\nimport panda_syntax from '!!raw-loader!../CodeMirror/theme/panda-syntax.css';\nimport paraiso_dark from '!!raw-loader!../CodeMirror/theme/paraiso-dark.css';\nimport paraiso_light from '!!raw-loader!../CodeMirror/theme/paraiso-light.css';\nimport pastel_on_dark from '!!raw-loader!../CodeMirror/theme/pastel-on-dark.css';\nimport railscasts from '!!raw-loader!../CodeMirror/theme/railscasts.css';\nimport rubyblue from '!!raw-loader!../CodeMirror/theme/rubyblue.css';\nimport seti from '!!raw-loader!../CodeMirror/theme/seti.css';\nimport shadowfox from '!!raw-loader!../CodeMirror/theme/shadowfox.css';\nimport solarized from '!!raw-loader!../CodeMirror/theme/solarized.css';\nimport ssms from '!!raw-loader!../CodeMirror/theme/ssms.css';\nimport the_matrix from '!!raw-loader!../CodeMirror/theme/the-matrix.css';\nimport tomorrow_night_bright from '!!raw-loader!../CodeMirror/theme/tomorrow-night-bright.css';\nimport tomorrow_night_eighties from '!!raw-loader!../CodeMirror/theme/tomorrow-night-eighties.css';\nimport ttcn from '!!raw-loader!../CodeMirror/theme/ttcn.css';\nimport twilight from '!!raw-loader!../CodeMirror/theme/twilight.css';\nimport vibrant_ink from '!!raw-loader!../CodeMirror/theme/vibrant-ink.css';\nimport xq_dark from '!!raw-loader!../CodeMirror/theme/xq-dark.css';\nimport xq_light from '!!raw-loader!../CodeMirror/theme/xq-light.css';\nimport yeti from '!!raw-loader!../CodeMirror/theme/yeti.css';\nimport yonce from '!!raw-loader!../CodeMirror/theme/yonce.css';\nimport zenburn from '!!raw-loader!../CodeMirror/theme/zenburn.css';\nvar styles = {\n  '3024-day': _3024_day,\n  '3024-night': _3024_night,\n  abcdef: abcdef,\n  'ambiance-mobile': ambiance_mobile,\n  ambiance: ambiance,\n  'base16-dark': base16_dark,\n  'base16-light': base16_light,\n  bespin: bespin,\n  blackboard: blackboard,\n  cobalt: cobalt,\n  colorforth: colorforth,\n  darcula: darcula,\n  dracula: dracula,\n  'duotone-dark': duotone_dark,\n  'duotone-light': duotone_light,\n  eclipse: eclipse,\n  elegant: elegant,\n  'erlang-dark': erlang_dark,\n  'gruvbox-dark': gruvbox_dark,\n  hopscotch: hopscotch,\n  icecoder: icecoder,\n  idea: idea,\n  isotope: isotope,\n  'lesser-dark': lesser_dark,\n  liquibyte: liquibyte,\n  lucario: lucario,\n  material: material,\n  mbo: mbo,\n  'mdn-like': mdn_like,\n  midnight: midnight,\n  monokai: monokai,\n  neat: neat,\n  neo: neo,\n  night: night,\n  nord: nord,\n  'oceanic-next': oceanic_next,\n  'panda-syntax': panda_syntax,\n  'paraiso-dark': paraiso_dark,\n  'paraiso-light': paraiso_light,\n  'pastel-on-dark': pastel_on_dark,\n  railscasts: railscasts,\n  rubyblue: rubyblue,\n  seti: seti,\n  shadowfox: shadowfox,\n  solarized: solarized,\n  ssms: ssms,\n  'the-matrix': the_matrix,\n  'tomorrow-night-bright': tomorrow_night_bright,\n  'tomorrow-night-eighties': tomorrow_night_eighties,\n  ttcn: ttcn,\n  twilight: twilight,\n  'vibrant-ink': vibrant_ink,\n  'xq-dark': xq_dark,\n  'xq-light': xq_light,\n  yeti: yeti,\n  yonce: yonce,\n  zenburn: zenburn\n};\nexport default styles;","export default \"/*\\n\\n    Name:       3024 day\\n    Author:     Jan T. Sott (http://github.com/idleberg)\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-3024-day.CodeMirror { background: #f7f7f7; color: #3a3432; }\\n.cm-s-3024-day div.CodeMirror-selected { background: #d6d5d4; }\\n\\n.cm-s-3024-day .CodeMirror-line::selection, .cm-s-3024-day .CodeMirror-line > span::selection, .cm-s-3024-day .CodeMirror-line > span > span::selection { background: #d6d5d4; }\\n.cm-s-3024-day .CodeMirror-line::-moz-selection, .cm-s-3024-day .CodeMirror-line > span::-moz-selection, .cm-s-3024-day .CodeMirror-line > span > span::selection { background: #d9d9d9; }\\n\\n.cm-s-3024-day .CodeMirror-gutters { background: #f7f7f7; border-right: 0px; }\\n.cm-s-3024-day .CodeMirror-guttermarker { color: #db2d20; }\\n.cm-s-3024-day .CodeMirror-guttermarker-subtle { color: #807d7c; }\\n.cm-s-3024-day .CodeMirror-linenumber { color: #807d7c; }\\n\\n.cm-s-3024-day .CodeMirror-cursor { border-left: 1px solid #5c5855; }\\n\\n.cm-s-3024-day span.cm-comment { color: #cdab53; }\\n.cm-s-3024-day span.cm-atom { color: #a16a94; }\\n.cm-s-3024-day span.cm-number { color: #a16a94; }\\n\\n.cm-s-3024-day span.cm-property, .cm-s-3024-day span.cm-attribute { color: #01a252; }\\n.cm-s-3024-day span.cm-keyword { color: #db2d20; }\\n.cm-s-3024-day span.cm-string { color: #fded02; }\\n\\n.cm-s-3024-day span.cm-variable { color: #01a252; }\\n.cm-s-3024-day span.cm-variable-2 { color: #01a0e4; }\\n.cm-s-3024-day span.cm-def { color: #e8bbd0; }\\n.cm-s-3024-day span.cm-bracket { color: #3a3432; }\\n.cm-s-3024-day span.cm-tag { color: #db2d20; }\\n.cm-s-3024-day span.cm-link { color: #a16a94; }\\n.cm-s-3024-day span.cm-error { background: #db2d20; color: #5c5855; }\\n\\n.cm-s-3024-day .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-3024-day .CodeMirror-matchingbracket { text-decoration: underline; color: #a16a94 !important; }\\n\"","export default \"/*\\n\\n    Name:       3024 night\\n    Author:     Jan T. Sott (http://github.com/idleberg)\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-3024-night.CodeMirror { background: #090300; color: #d6d5d4; }\\n.cm-s-3024-night div.CodeMirror-selected { background: #3a3432; }\\n.cm-s-3024-night .CodeMirror-line::selection, .cm-s-3024-night .CodeMirror-line > span::selection, .cm-s-3024-night .CodeMirror-line > span > span::selection { background: rgba(58, 52, 50, .99); }\\n.cm-s-3024-night .CodeMirror-line::-moz-selection, .cm-s-3024-night .CodeMirror-line > span::-moz-selection, .cm-s-3024-night .CodeMirror-line > span > span::-moz-selection { background: rgba(58, 52, 50, .99); }\\n.cm-s-3024-night .CodeMirror-gutters { background: #090300; border-right: 0px; }\\n.cm-s-3024-night .CodeMirror-guttermarker { color: #db2d20; }\\n.cm-s-3024-night .CodeMirror-guttermarker-subtle { color: #5c5855; }\\n.cm-s-3024-night .CodeMirror-linenumber { color: #5c5855; }\\n\\n.cm-s-3024-night .CodeMirror-cursor { border-left: 1px solid #807d7c; }\\n\\n.cm-s-3024-night span.cm-comment { color: #cdab53; }\\n.cm-s-3024-night span.cm-atom { color: #a16a94; }\\n.cm-s-3024-night span.cm-number { color: #a16a94; }\\n\\n.cm-s-3024-night span.cm-property, .cm-s-3024-night span.cm-attribute { color: #01a252; }\\n.cm-s-3024-night span.cm-keyword { color: #db2d20; }\\n.cm-s-3024-night span.cm-string { color: #fded02; }\\n\\n.cm-s-3024-night span.cm-variable { color: #01a252; }\\n.cm-s-3024-night span.cm-variable-2 { color: #01a0e4; }\\n.cm-s-3024-night span.cm-def { color: #e8bbd0; }\\n.cm-s-3024-night span.cm-bracket { color: #d6d5d4; }\\n.cm-s-3024-night span.cm-tag { color: #db2d20; }\\n.cm-s-3024-night span.cm-link { color: #a16a94; }\\n.cm-s-3024-night span.cm-error { background: #db2d20; color: #807d7c; }\\n\\n.cm-s-3024-night .CodeMirror-activeline-background { background: #2F2F2F; }\\n.cm-s-3024-night .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \".cm-s-abcdef.CodeMirror { background: #0f0f0f; color: #defdef; }\\n.cm-s-abcdef div.CodeMirror-selected { background: #515151; }\\n.cm-s-abcdef .CodeMirror-line::selection, .cm-s-abcdef .CodeMirror-line > span::selection, .cm-s-abcdef .CodeMirror-line > span > span::selection { background: rgba(56, 56, 56, 0.99); }\\n.cm-s-abcdef .CodeMirror-line::-moz-selection, .cm-s-abcdef .CodeMirror-line > span::-moz-selection, .cm-s-abcdef .CodeMirror-line > span > span::-moz-selection { background: rgba(56, 56, 56, 0.99); }\\n.cm-s-abcdef .CodeMirror-gutters { background: #555; border-right: 2px solid #314151; }\\n.cm-s-abcdef .CodeMirror-guttermarker { color: #222; }\\n.cm-s-abcdef .CodeMirror-guttermarker-subtle { color: azure; }\\n.cm-s-abcdef .CodeMirror-linenumber { color: #FFFFFF; }\\n.cm-s-abcdef .CodeMirror-cursor { border-left: 1px solid #00FF00; }\\n\\n.cm-s-abcdef span.cm-keyword { color: darkgoldenrod; font-weight: bold; }\\n.cm-s-abcdef span.cm-atom { color: #77F; }\\n.cm-s-abcdef span.cm-number { color: violet; }\\n.cm-s-abcdef span.cm-def { color: #fffabc; }\\n.cm-s-abcdef span.cm-variable { color: #abcdef; }\\n.cm-s-abcdef span.cm-variable-2 { color: #cacbcc; }\\n.cm-s-abcdef span.cm-variable-3, .cm-s-abcdef span.cm-type { color: #def; }\\n.cm-s-abcdef span.cm-property { color: #fedcba; }\\n.cm-s-abcdef span.cm-operator { color: #ff0; }\\n.cm-s-abcdef span.cm-comment { color: #7a7b7c; font-style: italic;}\\n.cm-s-abcdef span.cm-string { color: #2b4; }\\n.cm-s-abcdef span.cm-meta { color: #C9F; }\\n.cm-s-abcdef span.cm-qualifier { color: #FFF700; }\\n.cm-s-abcdef span.cm-builtin { color: #30aabc; }\\n.cm-s-abcdef span.cm-bracket { color: #8a8a8a; }\\n.cm-s-abcdef span.cm-tag { color: #FFDD44; }\\n.cm-s-abcdef span.cm-attribute { color: #DDFF00; }\\n.cm-s-abcdef span.cm-error { color: #FF0000; }\\n.cm-s-abcdef span.cm-header { color: aquamarine; font-weight: bold; }\\n.cm-s-abcdef span.cm-link { color: blueviolet; }\\n\\n.cm-s-abcdef .CodeMirror-activeline-background { background: #314151; }\\n\"","export default \".cm-s-ambiance.CodeMirror {\\n  -webkit-box-shadow: none;\\n  -moz-box-shadow: none;\\n  box-shadow: none;\\n}\\n\"","export default \"/* ambiance theme for codemirror */\\n\\n/* Color scheme */\\n\\n.cm-s-ambiance .cm-header { color: blue; }\\n.cm-s-ambiance .cm-quote { color: #24C2C7; }\\n\\n.cm-s-ambiance .cm-keyword { color: #cda869; }\\n.cm-s-ambiance .cm-atom { color: #CF7EA9; }\\n.cm-s-ambiance .cm-number { color: #78CF8A; }\\n.cm-s-ambiance .cm-def { color: #aac6e3; }\\n.cm-s-ambiance .cm-variable { color: #ffb795; }\\n.cm-s-ambiance .cm-variable-2 { color: #eed1b3; }\\n.cm-s-ambiance .cm-variable-3, .cm-s-ambiance .cm-type { color: #faded3; }\\n.cm-s-ambiance .cm-property { color: #eed1b3; }\\n.cm-s-ambiance .cm-operator { color: #fa8d6a; }\\n.cm-s-ambiance .cm-comment { color: #555; font-style:italic; }\\n.cm-s-ambiance .cm-string { color: #8f9d6a; }\\n.cm-s-ambiance .cm-string-2 { color: #9d937c; }\\n.cm-s-ambiance .cm-meta { color: #D2A8A1; }\\n.cm-s-ambiance .cm-qualifier { color: yellow; }\\n.cm-s-ambiance .cm-builtin { color: #9999cc; }\\n.cm-s-ambiance .cm-bracket { color: #24C2C7; }\\n.cm-s-ambiance .cm-tag { color: #fee4ff; }\\n.cm-s-ambiance .cm-attribute { color: #9B859D; }\\n.cm-s-ambiance .cm-hr { color: pink; }\\n.cm-s-ambiance .cm-link { color: #F4C20B; }\\n.cm-s-ambiance .cm-special { color: #FF9D00; }\\n.cm-s-ambiance .cm-error { color: #AF2018; }\\n\\n.cm-s-ambiance .CodeMirror-matchingbracket { color: #0f0; }\\n.cm-s-ambiance .CodeMirror-nonmatchingbracket { color: #f22; }\\n\\n.cm-s-ambiance div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }\\n.cm-s-ambiance.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-ambiance .CodeMirror-line::selection, .cm-s-ambiance .CodeMirror-line > span::selection, .cm-s-ambiance .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-ambiance .CodeMirror-line::-moz-selection, .cm-s-ambiance .CodeMirror-line > span::-moz-selection, .cm-s-ambiance .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }\\n\\n/* Editor styling */\\n\\n.cm-s-ambiance.CodeMirror {\\n  line-height: 1.40em;\\n  color: #E6E1DC;\\n  background-color: #202020;\\n  -webkit-box-shadow: inset 0 0 10px black;\\n  -moz-box-shadow: inset 0 0 10px black;\\n  box-shadow: inset 0 0 10px black;\\n}\\n\\n.cm-s-ambiance .CodeMirror-gutters {\\n  background: #3D3D3D;\\n  border-right: 1px solid #4D4D4D;\\n  box-shadow: 0 10px 20px black;\\n}\\n\\n.cm-s-ambiance .CodeMirror-linenumber {\\n  text-shadow: 0px 1px 1px #4d4d4d;\\n  color: #111;\\n  padding: 0 5px;\\n}\\n\\n.cm-s-ambiance .CodeMirror-guttermarker { color: #aaa; }\\n.cm-s-ambiance .CodeMirror-guttermarker-subtle { color: #111; }\\n\\n.cm-s-ambiance .CodeMirror-cursor { border-left: 1px solid #7991E8; }\\n\\n.cm-s-ambiance .CodeMirror-activeline-background {\\n  background: none repeat scroll 0% 0% rgba(255, 255, 255, 0.031);\\n}\\n\\n.cm-s-ambiance.CodeMirror,\\n.cm-s-ambiance .CodeMirror-gutters {\\n  background-image: url(\\\"data:image/png;base64,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\\\");\\n}\\n\"","export default \"/*\\n\\n    Name:       Base16 Default Dark\\n    Author:     Chris Kempson (http://chriskempson.com)\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-base16-dark.CodeMirror { background: #151515; color: #e0e0e0; }\\n.cm-s-base16-dark div.CodeMirror-selected { background: #303030; }\\n.cm-s-base16-dark .CodeMirror-line::selection, .cm-s-base16-dark .CodeMirror-line > span::selection, .cm-s-base16-dark .CodeMirror-line > span > span::selection { background: rgba(48, 48, 48, .99); }\\n.cm-s-base16-dark .CodeMirror-line::-moz-selection, .cm-s-base16-dark .CodeMirror-line > span::-moz-selection, .cm-s-base16-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(48, 48, 48, .99); }\\n.cm-s-base16-dark .CodeMirror-gutters { background: #151515; border-right: 0px; }\\n.cm-s-base16-dark .CodeMirror-guttermarker { color: #ac4142; }\\n.cm-s-base16-dark .CodeMirror-guttermarker-subtle { color: #505050; }\\n.cm-s-base16-dark .CodeMirror-linenumber { color: #505050; }\\n.cm-s-base16-dark .CodeMirror-cursor { border-left: 1px solid #b0b0b0; }\\n\\n.cm-s-base16-dark span.cm-comment { color: #8f5536; }\\n.cm-s-base16-dark span.cm-atom { color: #aa759f; }\\n.cm-s-base16-dark span.cm-number { color: #aa759f; }\\n\\n.cm-s-base16-dark span.cm-property, .cm-s-base16-dark span.cm-attribute { color: #90a959; }\\n.cm-s-base16-dark span.cm-keyword { color: #ac4142; }\\n.cm-s-base16-dark span.cm-string { color: #f4bf75; }\\n\\n.cm-s-base16-dark span.cm-variable { color: #90a959; }\\n.cm-s-base16-dark span.cm-variable-2 { color: #6a9fb5; }\\n.cm-s-base16-dark span.cm-def { color: #d28445; }\\n.cm-s-base16-dark span.cm-bracket { color: #e0e0e0; }\\n.cm-s-base16-dark span.cm-tag { color: #ac4142; }\\n.cm-s-base16-dark span.cm-link { color: #aa759f; }\\n.cm-s-base16-dark span.cm-error { background: #ac4142; color: #b0b0b0; }\\n\\n.cm-s-base16-dark .CodeMirror-activeline-background { background: #202020; }\\n.cm-s-base16-dark .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/*\\n\\n    Name:       Base16 Default Light\\n    Author:     Chris Kempson (http://chriskempson.com)\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-base16-light.CodeMirror { background: #f5f5f5; color: #202020; }\\n.cm-s-base16-light div.CodeMirror-selected { background: #e0e0e0; }\\n.cm-s-base16-light .CodeMirror-line::selection, .cm-s-base16-light .CodeMirror-line > span::selection, .cm-s-base16-light .CodeMirror-line > span > span::selection { background: #e0e0e0; }\\n.cm-s-base16-light .CodeMirror-line::-moz-selection, .cm-s-base16-light .CodeMirror-line > span::-moz-selection, .cm-s-base16-light .CodeMirror-line > span > span::-moz-selection { background: #e0e0e0; }\\n.cm-s-base16-light .CodeMirror-gutters { background: #f5f5f5; border-right: 0px; }\\n.cm-s-base16-light .CodeMirror-guttermarker { color: #ac4142; }\\n.cm-s-base16-light .CodeMirror-guttermarker-subtle { color: #b0b0b0; }\\n.cm-s-base16-light .CodeMirror-linenumber { color: #b0b0b0; }\\n.cm-s-base16-light .CodeMirror-cursor { border-left: 1px solid #505050; }\\n\\n.cm-s-base16-light span.cm-comment { color: #8f5536; }\\n.cm-s-base16-light span.cm-atom { color: #aa759f; }\\n.cm-s-base16-light span.cm-number { color: #aa759f; }\\n\\n.cm-s-base16-light span.cm-property, .cm-s-base16-light span.cm-attribute { color: #90a959; }\\n.cm-s-base16-light span.cm-keyword { color: #ac4142; }\\n.cm-s-base16-light span.cm-string { color: #f4bf75; }\\n\\n.cm-s-base16-light span.cm-variable { color: #90a959; }\\n.cm-s-base16-light span.cm-variable-2 { color: #6a9fb5; }\\n.cm-s-base16-light span.cm-def { color: #d28445; }\\n.cm-s-base16-light span.cm-bracket { color: #202020; }\\n.cm-s-base16-light span.cm-tag { color: #ac4142; }\\n.cm-s-base16-light span.cm-link { color: #aa759f; }\\n.cm-s-base16-light span.cm-error { background: #ac4142; color: #505050; }\\n\\n.cm-s-base16-light .CodeMirror-activeline-background { background: #DDDCDC; }\\n.cm-s-base16-light .CodeMirror-matchingbracket { color: #f5f5f5 !important; background-color: #6A9FB5 !important}\\n\"","export default \"/*\\n\\n    Name:       Bespin\\n    Author:     Mozilla / Jan T. Sott\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-bespin.CodeMirror {background: #28211c; color: #9d9b97;}\\n.cm-s-bespin div.CodeMirror-selected {background: #36312e !important;}\\n.cm-s-bespin .CodeMirror-gutters {background: #28211c; border-right: 0px;}\\n.cm-s-bespin .CodeMirror-linenumber {color: #666666;}\\n.cm-s-bespin .CodeMirror-cursor {border-left: 1px solid #797977 !important;}\\n\\n.cm-s-bespin span.cm-comment {color: #937121;}\\n.cm-s-bespin span.cm-atom {color: #9b859d;}\\n.cm-s-bespin span.cm-number {color: #9b859d;}\\n\\n.cm-s-bespin span.cm-property, .cm-s-bespin span.cm-attribute {color: #54be0d;}\\n.cm-s-bespin span.cm-keyword {color: #cf6a4c;}\\n.cm-s-bespin span.cm-string {color: #f9ee98;}\\n\\n.cm-s-bespin span.cm-variable {color: #54be0d;}\\n.cm-s-bespin span.cm-variable-2 {color: #5ea6ea;}\\n.cm-s-bespin span.cm-def {color: #cf7d34;}\\n.cm-s-bespin span.cm-error {background: #cf6a4c; color: #797977;}\\n.cm-s-bespin span.cm-bracket {color: #9d9b97;}\\n.cm-s-bespin span.cm-tag {color: #cf6a4c;}\\n.cm-s-bespin span.cm-link {color: #9b859d;}\\n\\n.cm-s-bespin .CodeMirror-matchingbracket { text-decoration: underline; color: white !important;}\\n.cm-s-bespin .CodeMirror-activeline-background { background: #404040; }\\n\"","export default \"/* Port of TextMate's Blackboard theme */\\n\\n.cm-s-blackboard.CodeMirror { background: #0C1021; color: #F8F8F8; }\\n.cm-s-blackboard div.CodeMirror-selected { background: #253B76; }\\n.cm-s-blackboard .CodeMirror-line::selection, .cm-s-blackboard .CodeMirror-line > span::selection, .cm-s-blackboard .CodeMirror-line > span > span::selection { background: rgba(37, 59, 118, .99); }\\n.cm-s-blackboard .CodeMirror-line::-moz-selection, .cm-s-blackboard .CodeMirror-line > span::-moz-selection, .cm-s-blackboard .CodeMirror-line > span > span::-moz-selection { background: rgba(37, 59, 118, .99); }\\n.cm-s-blackboard .CodeMirror-gutters { background: #0C1021; border-right: 0; }\\n.cm-s-blackboard .CodeMirror-guttermarker { color: #FBDE2D; }\\n.cm-s-blackboard .CodeMirror-guttermarker-subtle { color: #888; }\\n.cm-s-blackboard .CodeMirror-linenumber { color: #888; }\\n.cm-s-blackboard .CodeMirror-cursor { border-left: 1px solid #A7A7A7; }\\n\\n.cm-s-blackboard .cm-keyword { color: #FBDE2D; }\\n.cm-s-blackboard .cm-atom { color: #D8FA3C; }\\n.cm-s-blackboard .cm-number { color: #D8FA3C; }\\n.cm-s-blackboard .cm-def { color: #8DA6CE; }\\n.cm-s-blackboard .cm-variable { color: #FF6400; }\\n.cm-s-blackboard .cm-operator { color: #FBDE2D; }\\n.cm-s-blackboard .cm-comment { color: #AEAEAE; }\\n.cm-s-blackboard .cm-string { color: #61CE3C; }\\n.cm-s-blackboard .cm-string-2 { color: #61CE3C; }\\n.cm-s-blackboard .cm-meta { color: #D8FA3C; }\\n.cm-s-blackboard .cm-builtin { color: #8DA6CE; }\\n.cm-s-blackboard .cm-tag { color: #8DA6CE; }\\n.cm-s-blackboard .cm-attribute { color: #8DA6CE; }\\n.cm-s-blackboard .cm-header { color: #FF6400; }\\n.cm-s-blackboard .cm-hr { color: #AEAEAE; }\\n.cm-s-blackboard .cm-link { color: #8DA6CE; }\\n.cm-s-blackboard .cm-error { background: #9D1E15; color: #F8F8F8; }\\n\\n.cm-s-blackboard .CodeMirror-activeline-background { background: #3C3636; }\\n.cm-s-blackboard .CodeMirror-matchingbracket { outline:1px solid grey;color:white !important; }\\n\"","export default \".cm-s-cobalt.CodeMirror { background: #002240; color: white; }\\n.cm-s-cobalt div.CodeMirror-selected { background: #b36539; }\\n.cm-s-cobalt .CodeMirror-line::selection, .cm-s-cobalt .CodeMirror-line > span::selection, .cm-s-cobalt .CodeMirror-line > span > span::selection { background: rgba(179, 101, 57, .99); }\\n.cm-s-cobalt .CodeMirror-line::-moz-selection, .cm-s-cobalt .CodeMirror-line > span::-moz-selection, .cm-s-cobalt .CodeMirror-line > span > span::-moz-selection { background: rgba(179, 101, 57, .99); }\\n.cm-s-cobalt .CodeMirror-gutters { background: #002240; border-right: 1px solid #aaa; }\\n.cm-s-cobalt .CodeMirror-guttermarker { color: #ffee80; }\\n.cm-s-cobalt .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\\n.cm-s-cobalt .CodeMirror-linenumber { color: #d0d0d0; }\\n.cm-s-cobalt .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-cobalt span.cm-comment { color: #08f; }\\n.cm-s-cobalt span.cm-atom { color: #845dc4; }\\n.cm-s-cobalt span.cm-number, .cm-s-cobalt span.cm-attribute { color: #ff80e1; }\\n.cm-s-cobalt span.cm-keyword { color: #ffee80; }\\n.cm-s-cobalt span.cm-string { color: #3ad900; }\\n.cm-s-cobalt span.cm-meta { color: #ff9d00; }\\n.cm-s-cobalt span.cm-variable-2, .cm-s-cobalt span.cm-tag { color: #9effff; }\\n.cm-s-cobalt span.cm-variable-3, .cm-s-cobalt span.cm-def, .cm-s-cobalt .cm-type { color: white; }\\n.cm-s-cobalt span.cm-bracket { color: #d8d8d8; }\\n.cm-s-cobalt span.cm-builtin, .cm-s-cobalt span.cm-special { color: #ff9e59; }\\n.cm-s-cobalt span.cm-link { color: #845dc4; }\\n.cm-s-cobalt span.cm-error { color: #9d1e15; }\\n\\n.cm-s-cobalt .CodeMirror-activeline-background { background: #002D57; }\\n.cm-s-cobalt .CodeMirror-matchingbracket { outline:1px solid grey;color:white !important; }\\n\"","export default \".cm-s-colorforth.CodeMirror { background: #000000; color: #f8f8f8; }\\n.cm-s-colorforth .CodeMirror-gutters { background: #0a001f; border-right: 1px solid #aaa; }\\n.cm-s-colorforth .CodeMirror-guttermarker { color: #FFBD40; }\\n.cm-s-colorforth .CodeMirror-guttermarker-subtle { color: #78846f; }\\n.cm-s-colorforth .CodeMirror-linenumber { color: #bababa; }\\n.cm-s-colorforth .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-colorforth span.cm-comment     { color: #ededed; }\\n.cm-s-colorforth span.cm-def         { color: #ff1c1c; font-weight:bold; }\\n.cm-s-colorforth span.cm-keyword     { color: #ffd900; }\\n.cm-s-colorforth span.cm-builtin     { color: #00d95a; }\\n.cm-s-colorforth span.cm-variable    { color: #73ff00; }\\n.cm-s-colorforth span.cm-string      { color: #007bff; }\\n.cm-s-colorforth span.cm-number      { color: #00c4ff; }\\n.cm-s-colorforth span.cm-atom        { color: #606060; }\\n\\n.cm-s-colorforth span.cm-variable-2  { color: #EEE; }\\n.cm-s-colorforth span.cm-variable-3, .cm-s-colorforth span.cm-type { color: #DDD; }\\n.cm-s-colorforth span.cm-property    {}\\n.cm-s-colorforth span.cm-operator    {}\\n\\n.cm-s-colorforth span.cm-meta        { color: yellow; }\\n.cm-s-colorforth span.cm-qualifier   { color: #FFF700; }\\n.cm-s-colorforth span.cm-bracket     { color: #cc7; }\\n.cm-s-colorforth span.cm-tag         { color: #FFBD40; }\\n.cm-s-colorforth span.cm-attribute   { color: #FFF700; }\\n.cm-s-colorforth span.cm-error       { color: #f00; }\\n\\n.cm-s-colorforth div.CodeMirror-selected { background: #333d53; }\\n\\n.cm-s-colorforth span.cm-compilation { background: rgba(255, 255, 255, 0.12); }\\n\\n.cm-s-colorforth .CodeMirror-activeline-background { background: #253540; }\\n\"","export default \"/**\\n    Name: IntelliJ IDEA darcula theme\\n    From IntelliJ IDEA by JetBrains\\n */\\n\\n.cm-s-darcula  { font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;}\\n.cm-s-darcula.CodeMirror { background: #2B2B2B; color: #A9B7C6; } \\n\\n.cm-s-darcula span.cm-meta { color: #BBB529; }\\n.cm-s-darcula span.cm-number { color: #6897BB; }\\n.cm-s-darcula span.cm-keyword { color: #CC7832; line-height: 1em; font-weight: bold; }  \\n.cm-s-darcula span.cm-def { color: #A9B7C6; font-style: italic; }\\n.cm-s-darcula span.cm-variable { color: #A9B7C6; }\\n.cm-s-darcula span.cm-variable-2 { color: #A9B7C6; }\\n.cm-s-darcula span.cm-variable-3 { color: #9876AA; }\\n.cm-s-darcula span.cm-type { color: #AABBCC; font-weight: bold; }\\n.cm-s-darcula span.cm-property { color: #FFC66D; }\\n.cm-s-darcula span.cm-operator { color: #A9B7C6; }\\n.cm-s-darcula span.cm-string { color: #6A8759; }\\n.cm-s-darcula span.cm-string-2 { color: #6A8759; }\\n.cm-s-darcula span.cm-comment { color: #61A151; font-style: italic; } \\n.cm-s-darcula span.cm-link { color: #CC7832; }\\n.cm-s-darcula span.cm-atom { color: #CC7832; }\\n.cm-s-darcula span.cm-error { color: #BC3F3C; }\\n.cm-s-darcula span.cm-tag { color: #629755; font-weight: bold; font-style: italic; text-decoration: underline; }\\n.cm-s-darcula span.cm-attribute { color: #6897bb; }\\n.cm-s-darcula span.cm-qualifier { color: #6A8759; }\\n.cm-s-darcula span.cm-bracket { color: #A9B7C6; }\\n.cm-s-darcula span.cm-builtin { color: #FF9E59; }\\n.cm-s-darcula span.cm-special { color: #FF9E59; }\\n\\n.cm-s-darcula .CodeMirror-cursor { border-left: 1px solid #A9B7C6; }  \\n.cm-s-darcula .CodeMirror-activeline-background { background: #323232; } \\n.cm-s-darcula .CodeMirror-gutters { background: #313335; border-right: 1px solid #313335; } \\n.cm-s-darcula .CodeMirror-guttermarker { color: #FFEE80; }  \\n.cm-s-darcula .CodeMirror-guttermarker-subtle { color: #D0D0D0; }  \\n.cm-s-darcula .CodeMirrir-linenumber { color: #606366; } \\n.cm-s-darcula .CodeMirror-matchingbracket { background-color: #3B514D; color: #FFEF28 !important; font-weight: bold; } \\n\\n.cm-s-darcula div.CodeMirror-selected { background: #214283; }  \\n\\n.CodeMirror-hints.darcula {\\n  font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;\\n  color: #9C9E9E;\\n  background-color: #3B3E3F !important;\\n}\\n\\n.CodeMirror-hints.darcula .CodeMirror-hint-active {\\n  background-color: #494D4E !important;\\n  color: #9C9E9E !important;\\n}\\n\"","export default \"/*\\n\\n    Name:       dracula\\n    Author:     Michael Kaminsky (http://github.com/mkaminsky11)\\n\\n    Original dracula color scheme by Zeno Rocha (https://github.com/zenorocha/dracula-theme)\\n\\n*/\\n\\n\\n.cm-s-dracula.CodeMirror, .cm-s-dracula .CodeMirror-gutters {\\n  background-color: #282a36 !important;\\n  color: #f8f8f2 !important;\\n  border: none;\\n}\\n.cm-s-dracula .CodeMirror-gutters { color: #282a36; }\\n.cm-s-dracula .CodeMirror-cursor { border-left: solid thin #f8f8f0; }\\n.cm-s-dracula .CodeMirror-linenumber { color: #6D8A88; }\\n.cm-s-dracula .CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-dracula .CodeMirror-line::selection, .cm-s-dracula .CodeMirror-line > span::selection, .cm-s-dracula .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-dracula .CodeMirror-line::-moz-selection, .cm-s-dracula .CodeMirror-line > span::-moz-selection, .cm-s-dracula .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-dracula span.cm-comment { color: #6272a4; }\\n.cm-s-dracula span.cm-string, .cm-s-dracula span.cm-string-2 { color: #f1fa8c; }\\n.cm-s-dracula span.cm-number { color: #bd93f9; }\\n.cm-s-dracula span.cm-variable { color: #50fa7b; }\\n.cm-s-dracula span.cm-variable-2 { color: white; }\\n.cm-s-dracula span.cm-def { color: #50fa7b; }\\n.cm-s-dracula span.cm-operator { color: #ff79c6; }\\n.cm-s-dracula span.cm-keyword { color: #ff79c6; }\\n.cm-s-dracula span.cm-atom { color: #bd93f9; }\\n.cm-s-dracula span.cm-meta { color: #f8f8f2; }\\n.cm-s-dracula span.cm-tag { color: #ff79c6; }\\n.cm-s-dracula span.cm-attribute { color: #50fa7b; }\\n.cm-s-dracula span.cm-qualifier { color: #50fa7b; }\\n.cm-s-dracula span.cm-property { color: #66d9ef; }\\n.cm-s-dracula span.cm-builtin { color: #50fa7b; }\\n.cm-s-dracula span.cm-variable-3, .cm-s-dracula span.cm-type { color: #ffb86c; }\\n\\n.cm-s-dracula .CodeMirror-activeline-background { background: rgba(255,255,255,0.1); }\\n.cm-s-dracula .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/*\\nName:   DuoTone-Dark\\nAuthor: by Bram de Haan, adapted from DuoTone themes by Simurai (http://simurai.com/projects/2016/01/01/duotone-themes)\\n\\nCodeMirror template by Jan T. Sott (https://github.com/idleberg), adapted by Bram de Haan (https://github.com/atelierbram/)\\n*/\\n\\n.cm-s-duotone-dark.CodeMirror { background: #2a2734; color: #6c6783; }\\n.cm-s-duotone-dark div.CodeMirror-selected { background: #545167!important; }\\n.cm-s-duotone-dark .CodeMirror-gutters { background: #2a2734; border-right: 0px; }\\n.cm-s-duotone-dark .CodeMirror-linenumber { color: #545167; }\\n\\n/* begin cursor */\\n.cm-s-duotone-dark .CodeMirror-cursor { border-left: 1px solid #ffad5c; /* border-left: 1px solid #ffad5c80; */ border-right: .5em solid #ffad5c; /* border-right: .5em solid #ffad5c80; */ opacity: .5; }\\n.cm-s-duotone-dark .CodeMirror-activeline-background { background: #363342; /* background: #36334280;  */ opacity: .5;}\\n.cm-s-duotone-dark .cm-fat-cursor .CodeMirror-cursor { background: #ffad5c; /* background: #ffad5c80; */ opacity: .5;}\\n/* end cursor */\\n\\n.cm-s-duotone-dark span.cm-atom, .cm-s-duotone-dark span.cm-number, .cm-s-duotone-dark span.cm-keyword, .cm-s-duotone-dark span.cm-variable, .cm-s-duotone-dark span.cm-attribute, .cm-s-duotone-dark span.cm-quote, .cm-s-duotone-dark span.cm-hr, .cm-s-duotone-dark span.cm-link { color: #ffcc99; }\\n\\n.cm-s-duotone-dark span.cm-property { color: #9a86fd; }\\n.cm-s-duotone-dark span.cm-punctuation, .cm-s-duotone-dark span.cm-unit, .cm-s-duotone-dark span.cm-negative { color: #e09142; }\\n.cm-s-duotone-dark span.cm-string { color: #ffb870; }\\n.cm-s-duotone-dark span.cm-operator { color: #ffad5c; }\\n.cm-s-duotone-dark span.cm-positive { color: #6a51e6; }\\n\\n.cm-s-duotone-dark span.cm-variable-2, .cm-s-duotone-dark span.cm-variable-3, .cm-s-duotone-dark span.cm-type, .cm-s-duotone-dark span.cm-string-2, .cm-s-duotone-dark span.cm-url { color: #7a63ee; }\\n.cm-s-duotone-dark span.cm-def, .cm-s-duotone-dark span.cm-tag, .cm-s-duotone-dark span.cm-builtin, .cm-s-duotone-dark span.cm-qualifier, .cm-s-duotone-dark span.cm-header, .cm-s-duotone-dark span.cm-em { color: #eeebff; }\\n.cm-s-duotone-dark span.cm-bracket, .cm-s-duotone-dark span.cm-comment { color: #6c6783; }\\n\\n/* using #f00 red for errors, don't think any of the colorscheme variables will stand out enough, ... maybe by giving it a background-color ... */\\n.cm-s-duotone-dark span.cm-error, .cm-s-duotone-dark span.cm-invalidchar { color: #f00; }\\n\\n.cm-s-duotone-dark span.cm-header { font-weight: normal; }\\n.cm-s-duotone-dark .CodeMirror-matchingbracket { text-decoration: underline; color: #eeebff !important; } \\n\"","export default \"/*\\nName:   DuoTone-Light\\nAuthor: by Bram de Haan, adapted from DuoTone themes by Simurai (http://simurai.com/projects/2016/01/01/duotone-themes)\\n\\nCodeMirror template by Jan T. Sott (https://github.com/idleberg), adapted by Bram de Haan (https://github.com/atelierbram/)\\n*/\\n\\n.cm-s-duotone-light.CodeMirror { background: #faf8f5; color: #b29762; }\\n.cm-s-duotone-light div.CodeMirror-selected { background: #e3dcce !important; }\\n.cm-s-duotone-light .CodeMirror-gutters { background: #faf8f5; border-right: 0px; }\\n.cm-s-duotone-light .CodeMirror-linenumber { color: #cdc4b1; }\\n\\n/* begin cursor */\\n.cm-s-duotone-light .CodeMirror-cursor { border-left: 1px solid #93abdc; /* border-left: 1px solid #93abdc80; */ border-right: .5em solid #93abdc; /* border-right: .5em solid #93abdc80; */ opacity: .5; }\\n.cm-s-duotone-light .CodeMirror-activeline-background { background: #e3dcce;  /* background: #e3dcce80; */ opacity: .5; }\\n.cm-s-duotone-light .cm-fat-cursor .CodeMirror-cursor { background: #93abdc; /* #93abdc80; */ opacity: .5; }\\n/* end cursor */\\n\\n.cm-s-duotone-light span.cm-atom, .cm-s-duotone-light span.cm-number, .cm-s-duotone-light span.cm-keyword, .cm-s-duotone-light span.cm-variable, .cm-s-duotone-light span.cm-attribute, .cm-s-duotone-light span.cm-quote, .cm-s-duotone-light-light span.cm-hr, .cm-s-duotone-light-light span.cm-link { color: #063289; }\\n\\n.cm-s-duotone-light span.cm-property { color: #b29762; }\\n.cm-s-duotone-light span.cm-punctuation, .cm-s-duotone-light span.cm-unit, .cm-s-duotone-light span.cm-negative { color: #063289; }\\n.cm-s-duotone-light span.cm-string, .cm-s-duotone-light span.cm-operator { color: #1659df; }\\n.cm-s-duotone-light span.cm-positive { color: #896724; }\\n\\n.cm-s-duotone-light span.cm-variable-2, .cm-s-duotone-light span.cm-variable-3, .cm-s-duotone-light span.cm-type, .cm-s-duotone-light span.cm-string-2, .cm-s-duotone-light span.cm-url { color: #896724; }\\n.cm-s-duotone-light span.cm-def, .cm-s-duotone-light span.cm-tag, .cm-s-duotone-light span.cm-builtin, .cm-s-duotone-light span.cm-qualifier, .cm-s-duotone-light span.cm-header, .cm-s-duotone-light span.cm-em { color: #2d2006; }\\n.cm-s-duotone-light span.cm-bracket, .cm-s-duotone-light span.cm-comment { color: #b6ad9a; }\\n\\n/* using #f00 red for errors, don't think any of the colorscheme variables will stand out enough, ... maybe by giving it a background-color ... */\\n/* .cm-s-duotone-light span.cm-error { background: #896724; color: #728fcb; } */\\n.cm-s-duotone-light span.cm-error, .cm-s-duotone-light span.cm-invalidchar { color: #f00; }\\n\\n.cm-s-duotone-light span.cm-header { font-weight: normal; }\\n.cm-s-duotone-light .CodeMirror-matchingbracket { text-decoration: underline; color: #faf8f5 !important; }\\n\\n\"","export default \".cm-s-eclipse span.cm-meta { color: #FF1717; }\\n.cm-s-eclipse span.cm-keyword { line-height: 1em; font-weight: bold; color: #7F0055; }\\n.cm-s-eclipse span.cm-atom { color: #219; }\\n.cm-s-eclipse span.cm-number { color: #164; }\\n.cm-s-eclipse span.cm-def { color: #00f; }\\n.cm-s-eclipse span.cm-variable { color: black; }\\n.cm-s-eclipse span.cm-variable-2 { color: #0000C0; }\\n.cm-s-eclipse span.cm-variable-3, .cm-s-eclipse span.cm-type { color: #0000C0; }\\n.cm-s-eclipse span.cm-property { color: black; }\\n.cm-s-eclipse span.cm-operator { color: black; }\\n.cm-s-eclipse span.cm-comment { color: #3F7F5F; }\\n.cm-s-eclipse span.cm-string { color: #2A00FF; }\\n.cm-s-eclipse span.cm-string-2 { color: #f50; }\\n.cm-s-eclipse span.cm-qualifier { color: #555; }\\n.cm-s-eclipse span.cm-builtin { color: #30a; }\\n.cm-s-eclipse span.cm-bracket { color: #cc7; }\\n.cm-s-eclipse span.cm-tag { color: #170; }\\n.cm-s-eclipse span.cm-attribute { color: #00c; }\\n.cm-s-eclipse span.cm-link { color: #219; }\\n.cm-s-eclipse span.cm-error { color: #f00; }\\n\\n.cm-s-eclipse .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-eclipse .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }\\n\"","export default \".cm-s-elegant span.cm-number, .cm-s-elegant span.cm-string, .cm-s-elegant span.cm-atom { color: #762; }\\n.cm-s-elegant span.cm-comment { color: #262; font-style: italic; line-height: 1em; }\\n.cm-s-elegant span.cm-meta { color: #555; font-style: italic; line-height: 1em; }\\n.cm-s-elegant span.cm-variable { color: black; }\\n.cm-s-elegant span.cm-variable-2 { color: #b11; }\\n.cm-s-elegant span.cm-qualifier { color: #555; }\\n.cm-s-elegant span.cm-keyword { color: #730; }\\n.cm-s-elegant span.cm-builtin { color: #30a; }\\n.cm-s-elegant span.cm-link { color: #762; }\\n.cm-s-elegant span.cm-error { background-color: #fdd; }\\n\\n.cm-s-elegant .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-elegant .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }\\n\"","export default \".cm-s-erlang-dark.CodeMirror { background: #002240; color: white; }\\n.cm-s-erlang-dark div.CodeMirror-selected { background: #b36539; }\\n.cm-s-erlang-dark .CodeMirror-line::selection, .cm-s-erlang-dark .CodeMirror-line > span::selection, .cm-s-erlang-dark .CodeMirror-line > span > span::selection { background: rgba(179, 101, 57, .99); }\\n.cm-s-erlang-dark .CodeMirror-line::-moz-selection, .cm-s-erlang-dark .CodeMirror-line > span::-moz-selection, .cm-s-erlang-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(179, 101, 57, .99); }\\n.cm-s-erlang-dark .CodeMirror-gutters { background: #002240; border-right: 1px solid #aaa; }\\n.cm-s-erlang-dark .CodeMirror-guttermarker { color: white; }\\n.cm-s-erlang-dark .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\\n.cm-s-erlang-dark .CodeMirror-linenumber { color: #d0d0d0; }\\n.cm-s-erlang-dark .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-erlang-dark span.cm-quote      { color: #ccc; }\\n.cm-s-erlang-dark span.cm-atom       { color: #f133f1; }\\n.cm-s-erlang-dark span.cm-attribute  { color: #ff80e1; }\\n.cm-s-erlang-dark span.cm-bracket    { color: #ff9d00; }\\n.cm-s-erlang-dark span.cm-builtin    { color: #eaa; }\\n.cm-s-erlang-dark span.cm-comment    { color: #77f; }\\n.cm-s-erlang-dark span.cm-def        { color: #e7a; }\\n.cm-s-erlang-dark span.cm-keyword    { color: #ffee80; }\\n.cm-s-erlang-dark span.cm-meta       { color: #50fefe; }\\n.cm-s-erlang-dark span.cm-number     { color: #ffd0d0; }\\n.cm-s-erlang-dark span.cm-operator   { color: #d55; }\\n.cm-s-erlang-dark span.cm-property   { color: #ccc; }\\n.cm-s-erlang-dark span.cm-qualifier  { color: #ccc; }\\n.cm-s-erlang-dark span.cm-special    { color: #ffbbbb; }\\n.cm-s-erlang-dark span.cm-string     { color: #3ad900; }\\n.cm-s-erlang-dark span.cm-string-2   { color: #ccc; }\\n.cm-s-erlang-dark span.cm-tag        { color: #9effff; }\\n.cm-s-erlang-dark span.cm-variable   { color: #50fe50; }\\n.cm-s-erlang-dark span.cm-variable-2 { color: #e0e; }\\n.cm-s-erlang-dark span.cm-variable-3, .cm-s-erlang-dark span.cm-type { color: #ccc; }\\n.cm-s-erlang-dark span.cm-error      { color: #9d1e15; }\\n\\n.cm-s-erlang-dark .CodeMirror-activeline-background { background: #013461; }\\n.cm-s-erlang-dark .CodeMirror-matchingbracket { outline:1px solid grey; color:white !important; }\\n\"","export default \"/*\\n\\n    Name:       gruvbox-dark\\n    Author:     kRkk (https://github.com/krkk)\\n\\n    Original gruvbox color scheme by Pavel Pertsev (https://github.com/morhetz/gruvbox)\\n\\n*/\\n\\n.cm-s-gruvbox-dark.CodeMirror, .cm-s-gruvbox-dark .CodeMirror-gutters { background-color: #282828; color: #bdae93; }\\n.cm-s-gruvbox-dark .CodeMirror-gutters {background: #282828; border-right: 0px;}\\n.cm-s-gruvbox-dark .CodeMirror-linenumber {color: #7c6f64;}\\n.cm-s-gruvbox-dark .CodeMirror-cursor { border-left: 1px solid #ebdbb2; }\\n.cm-s-gruvbox-dark div.CodeMirror-selected { background: #928374; }\\n.cm-s-gruvbox-dark span.cm-meta { color: #83a598; }\\n\\n.cm-s-gruvbox-dark span.cm-comment { color: #928374; }\\n.cm-s-gruvbox-dark span.cm-number, span.cm-atom { color: #d3869b; }\\n.cm-s-gruvbox-dark span.cm-keyword { color: #f84934; }\\n\\n.cm-s-gruvbox-dark span.cm-variable { color: #ebdbb2; }\\n.cm-s-gruvbox-dark span.cm-variable-2 { color: #ebdbb2; }\\n.cm-s-gruvbox-dark span.cm-variable-3, .cm-s-gruvbox-dark span.cm-type { color: #fabd2f; }\\n.cm-s-gruvbox-dark span.cm-operator { color: #ebdbb2; }\\n.cm-s-gruvbox-dark span.cm-callee { color: #ebdbb2; }\\n.cm-s-gruvbox-dark span.cm-def { color: #ebdbb2; }\\n.cm-s-gruvbox-dark span.cm-property { color: #ebdbb2; }\\n.cm-s-gruvbox-dark span.cm-string { color: #b8bb26; }\\n.cm-s-gruvbox-dark span.cm-string-2 { color: #8ec07c; }\\n.cm-s-gruvbox-dark span.cm-qualifier { color: #8ec07c; }\\n.cm-s-gruvbox-dark span.cm-attribute { color: #8ec07c; }\\n\\n.cm-s-gruvbox-dark .CodeMirror-activeline-background { background: #3c3836; }\\n.cm-s-gruvbox-dark .CodeMirror-matchingbracket { background: #928374; color:#282828 !important; }\\n\\n.cm-s-gruvbox-dark span.cm-builtin { color: #fe8019; }\\n.cm-s-gruvbox-dark span.cm-tag { color: #fe8019; }\\n\"","export default \"/*\\n\\n    Name:       Hopscotch\\n    Author:     Jan T. Sott\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-hopscotch.CodeMirror {background: #322931; color: #d5d3d5;}\\n.cm-s-hopscotch div.CodeMirror-selected {background: #433b42 !important;}\\n.cm-s-hopscotch .CodeMirror-gutters {background: #322931; border-right: 0px;}\\n.cm-s-hopscotch .CodeMirror-linenumber {color: #797379;}\\n.cm-s-hopscotch .CodeMirror-cursor {border-left: 1px solid #989498 !important;}\\n\\n.cm-s-hopscotch span.cm-comment {color: #b33508;}\\n.cm-s-hopscotch span.cm-atom {color: #c85e7c;}\\n.cm-s-hopscotch span.cm-number {color: #c85e7c;}\\n\\n.cm-s-hopscotch span.cm-property, .cm-s-hopscotch span.cm-attribute {color: #8fc13e;}\\n.cm-s-hopscotch span.cm-keyword {color: #dd464c;}\\n.cm-s-hopscotch span.cm-string {color: #fdcc59;}\\n\\n.cm-s-hopscotch span.cm-variable {color: #8fc13e;}\\n.cm-s-hopscotch span.cm-variable-2 {color: #1290bf;}\\n.cm-s-hopscotch span.cm-def {color: #fd8b19;}\\n.cm-s-hopscotch span.cm-error {background: #dd464c; color: #989498;}\\n.cm-s-hopscotch span.cm-bracket {color: #d5d3d5;}\\n.cm-s-hopscotch span.cm-tag {color: #dd464c;}\\n.cm-s-hopscotch span.cm-link {color: #c85e7c;}\\n\\n.cm-s-hopscotch .CodeMirror-matchingbracket { text-decoration: underline; color: white !important;}\\n.cm-s-hopscotch .CodeMirror-activeline-background { background: #302020; }\\n\"","export default \"/*\\nICEcoder default theme by Matt Pass, used in code editor available at https://icecoder.net\\n*/\\n\\n.cm-s-icecoder { color: #666; background: #1d1d1b; }\\n\\n.cm-s-icecoder span.cm-keyword { color: #eee; font-weight:bold; }  /* off-white 1 */\\n.cm-s-icecoder span.cm-atom { color: #e1c76e; }                    /* yellow */\\n.cm-s-icecoder span.cm-number { color: #6cb5d9; }                  /* blue */\\n.cm-s-icecoder span.cm-def { color: #b9ca4a; }                     /* green */\\n\\n.cm-s-icecoder span.cm-variable { color: #6cb5d9; }                /* blue */\\n.cm-s-icecoder span.cm-variable-2 { color: #cc1e5c; }              /* pink */\\n.cm-s-icecoder span.cm-variable-3, .cm-s-icecoder span.cm-type { color: #f9602c; } /* orange */\\n\\n.cm-s-icecoder span.cm-property { color: #eee; }                   /* off-white 1 */\\n.cm-s-icecoder span.cm-operator { color: #9179bb; }                /* purple */\\n.cm-s-icecoder span.cm-comment { color: #97a3aa; }                 /* grey-blue */\\n\\n.cm-s-icecoder span.cm-string { color: #b9ca4a; }                  /* green */\\n.cm-s-icecoder span.cm-string-2 { color: #6cb5d9; }                /* blue */\\n\\n.cm-s-icecoder span.cm-meta { color: #555; }                       /* grey */\\n\\n.cm-s-icecoder span.cm-qualifier { color: #555; }                  /* grey */\\n.cm-s-icecoder span.cm-builtin { color: #214e7b; }                 /* bright blue */\\n.cm-s-icecoder span.cm-bracket { color: #cc7; }                    /* grey-yellow */\\n\\n.cm-s-icecoder span.cm-tag { color: #e8e8e8; }                     /* off-white 2 */\\n.cm-s-icecoder span.cm-attribute { color: #099; }                  /* teal */\\n\\n.cm-s-icecoder span.cm-header { color: #6a0d6a; }                  /* purple-pink */\\n.cm-s-icecoder span.cm-quote { color: #186718; }                   /* dark green */\\n.cm-s-icecoder span.cm-hr { color: #888; }                         /* mid-grey */\\n.cm-s-icecoder span.cm-link { color: #e1c76e; }                    /* yellow */\\n.cm-s-icecoder span.cm-error { color: #d00; }                      /* red */\\n\\n.cm-s-icecoder .CodeMirror-cursor { border-left: 1px solid white; }\\n.cm-s-icecoder div.CodeMirror-selected { color: #fff; background: #037; }\\n.cm-s-icecoder .CodeMirror-gutters { background: #1d1d1b; min-width: 41px; border-right: 0; }\\n.cm-s-icecoder .CodeMirror-linenumber { color: #555; cursor: default; }\\n.cm-s-icecoder .CodeMirror-matchingbracket { color: #fff !important; background: #555 !important; }\\n.cm-s-icecoder .CodeMirror-activeline-background { background: #000; }\\n\"","export default \"/**\\n    Name:       IDEA default theme\\n    From IntelliJ IDEA by JetBrains\\n */\\n\\n.cm-s-idea span.cm-meta { color: #808000; }\\n.cm-s-idea span.cm-number { color: #0000FF; }\\n.cm-s-idea span.cm-keyword { line-height: 1em; font-weight: bold; color: #000080; }\\n.cm-s-idea span.cm-atom { font-weight: bold; color: #000080; }\\n.cm-s-idea span.cm-def { color: #000000; }\\n.cm-s-idea span.cm-variable { color: black; }\\n.cm-s-idea span.cm-variable-2 { color: black; }\\n.cm-s-idea span.cm-variable-3, .cm-s-idea span.cm-type { color: black; }\\n.cm-s-idea span.cm-property { color: black; }\\n.cm-s-idea span.cm-operator { color: black; }\\n.cm-s-idea span.cm-comment { color: #808080; }\\n.cm-s-idea span.cm-string { color: #008000; }\\n.cm-s-idea span.cm-string-2 { color: #008000; }\\n.cm-s-idea span.cm-qualifier { color: #555; }\\n.cm-s-idea span.cm-error { color: #FF0000; }\\n.cm-s-idea span.cm-attribute { color: #0000FF; }\\n.cm-s-idea span.cm-tag { color: #000080; }\\n.cm-s-idea span.cm-link { color: #0000FF; }\\n.cm-s-idea .CodeMirror-activeline-background { background: #FFFAE3; }\\n\\n.cm-s-idea span.cm-builtin { color: #30a; }\\n.cm-s-idea span.cm-bracket { color: #cc7; }\\n.cm-s-idea  { font-family: Consolas, Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, serif;}\\n\\n\\n.cm-s-idea .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }\\n\\n.CodeMirror-hints.idea {\\n  font-family: Menlo, Monaco, Consolas, 'Courier New', monospace;\\n  color: #616569;\\n  background-color: #ebf3fd !important;\\n}\\n\\n.CodeMirror-hints.idea .CodeMirror-hint-active {\\n  background-color: #a2b8c9 !important;\\n  color: #5c6065 !important;\\n}\"","export default \"/*\\n\\n    Name:       Isotope\\n    Author:     David Desandro / Jan T. Sott\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-isotope.CodeMirror {background: #000000; color: #e0e0e0;}\\n.cm-s-isotope div.CodeMirror-selected {background: #404040 !important;}\\n.cm-s-isotope .CodeMirror-gutters {background: #000000; border-right: 0px;}\\n.cm-s-isotope .CodeMirror-linenumber {color: #808080;}\\n.cm-s-isotope .CodeMirror-cursor {border-left: 1px solid #c0c0c0 !important;}\\n\\n.cm-s-isotope span.cm-comment {color: #3300ff;}\\n.cm-s-isotope span.cm-atom {color: #cc00ff;}\\n.cm-s-isotope span.cm-number {color: #cc00ff;}\\n\\n.cm-s-isotope span.cm-property, .cm-s-isotope span.cm-attribute {color: #33ff00;}\\n.cm-s-isotope span.cm-keyword {color: #ff0000;}\\n.cm-s-isotope span.cm-string {color: #ff0099;}\\n\\n.cm-s-isotope span.cm-variable {color: #33ff00;}\\n.cm-s-isotope span.cm-variable-2 {color: #0066ff;}\\n.cm-s-isotope span.cm-def {color: #ff9900;}\\n.cm-s-isotope span.cm-error {background: #ff0000; color: #c0c0c0;}\\n.cm-s-isotope span.cm-bracket {color: #e0e0e0;}\\n.cm-s-isotope span.cm-tag {color: #ff0000;}\\n.cm-s-isotope span.cm-link {color: #cc00ff;}\\n\\n.cm-s-isotope .CodeMirror-matchingbracket { text-decoration: underline; color: white !important;}\\n.cm-s-isotope .CodeMirror-activeline-background { background: #202020; }\\n\"","export default \"/*\\nhttp://lesscss.org/ dark theme\\nPorted to CodeMirror by Peter Kroon\\n*/\\n.cm-s-lesser-dark {\\n  line-height: 1.3em;\\n}\\n.cm-s-lesser-dark.CodeMirror { background: #262626; color: #EBEFE7; text-shadow: 0 -1px 1px #262626; }\\n.cm-s-lesser-dark div.CodeMirror-selected { background: #45443B; } /* 33322B*/\\n.cm-s-lesser-dark .CodeMirror-line::selection, .cm-s-lesser-dark .CodeMirror-line > span::selection, .cm-s-lesser-dark .CodeMirror-line > span > span::selection { background: rgba(69, 68, 59, .99); }\\n.cm-s-lesser-dark .CodeMirror-line::-moz-selection, .cm-s-lesser-dark .CodeMirror-line > span::-moz-selection, .cm-s-lesser-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(69, 68, 59, .99); }\\n.cm-s-lesser-dark .CodeMirror-cursor { border-left: 1px solid white; }\\n.cm-s-lesser-dark pre { padding: 0 8px; }/*editable code holder*/\\n\\n.cm-s-lesser-dark.CodeMirror span.CodeMirror-matchingbracket { color: #7EFC7E; }/*65FC65*/\\n\\n.cm-s-lesser-dark .CodeMirror-gutters { background: #262626; border-right:1px solid #aaa; }\\n.cm-s-lesser-dark .CodeMirror-guttermarker { color: #599eff; }\\n.cm-s-lesser-dark .CodeMirror-guttermarker-subtle { color: #777; }\\n.cm-s-lesser-dark .CodeMirror-linenumber { color: #777; }\\n\\n.cm-s-lesser-dark span.cm-header { color: #a0a; }\\n.cm-s-lesser-dark span.cm-quote { color: #090; }\\n.cm-s-lesser-dark span.cm-keyword { color: #599eff; }\\n.cm-s-lesser-dark span.cm-atom { color: #C2B470; }\\n.cm-s-lesser-dark span.cm-number { color: #B35E4D; }\\n.cm-s-lesser-dark span.cm-def { color: white; }\\n.cm-s-lesser-dark span.cm-variable { color:#D9BF8C; }\\n.cm-s-lesser-dark span.cm-variable-2 { color: #669199; }\\n.cm-s-lesser-dark span.cm-variable-3, .cm-s-lesser-dark span.cm-type { color: white; }\\n.cm-s-lesser-dark span.cm-property { color: #92A75C; }\\n.cm-s-lesser-dark span.cm-operator { color: #92A75C; }\\n.cm-s-lesser-dark span.cm-comment { color: #666; }\\n.cm-s-lesser-dark span.cm-string { color: #BCD279; }\\n.cm-s-lesser-dark span.cm-string-2 { color: #f50; }\\n.cm-s-lesser-dark span.cm-meta { color: #738C73; }\\n.cm-s-lesser-dark span.cm-qualifier { color: #555; }\\n.cm-s-lesser-dark span.cm-builtin { color: #ff9e59; }\\n.cm-s-lesser-dark span.cm-bracket { color: #EBEFE7; }\\n.cm-s-lesser-dark span.cm-tag { color: #669199; }\\n.cm-s-lesser-dark span.cm-attribute { color: #81a4d5; }\\n.cm-s-lesser-dark span.cm-hr { color: #999; }\\n.cm-s-lesser-dark span.cm-link { color: #7070E6; }\\n.cm-s-lesser-dark span.cm-error { color: #9d1e15; }\\n\\n.cm-s-lesser-dark .CodeMirror-activeline-background { background: #3C3A3A; }\\n.cm-s-lesser-dark .CodeMirror-matchingbracket { outline:1px solid grey; color:white !important; }\\n\"","export default \".cm-s-liquibyte.CodeMirror {\\n\\tbackground-color: #000;\\n\\tcolor: #fff;\\n\\tline-height: 1.2em;\\n\\tfont-size: 1em;\\n}\\n.cm-s-liquibyte .CodeMirror-focused .cm-matchhighlight {\\n\\ttext-decoration: underline;\\n\\ttext-decoration-color: #0f0;\\n\\ttext-decoration-style: wavy;\\n}\\n.cm-s-liquibyte .cm-trailingspace {\\n\\ttext-decoration: line-through;\\n\\ttext-decoration-color: #f00;\\n\\ttext-decoration-style: dotted;\\n}\\n.cm-s-liquibyte .cm-tab {\\n\\ttext-decoration: line-through;\\n\\ttext-decoration-color: #404040;\\n\\ttext-decoration-style: dotted;\\n}\\n.cm-s-liquibyte .CodeMirror-gutters { background-color: #262626; border-right: 1px solid #505050; padding-right: 0.8em; }\\n.cm-s-liquibyte .CodeMirror-gutter-elt div { font-size: 1.2em; }\\n.cm-s-liquibyte .CodeMirror-guttermarker {  }\\n.cm-s-liquibyte .CodeMirror-guttermarker-subtle {  }\\n.cm-s-liquibyte .CodeMirror-linenumber { color: #606060; padding-left: 0; }\\n.cm-s-liquibyte .CodeMirror-cursor { border-left: 1px solid #eee; }\\n\\n.cm-s-liquibyte span.cm-comment     { color: #008000; }\\n.cm-s-liquibyte span.cm-def         { color: #ffaf40; font-weight: bold; }\\n.cm-s-liquibyte span.cm-keyword     { color: #c080ff; font-weight: bold; }\\n.cm-s-liquibyte span.cm-builtin     { color: #ffaf40; font-weight: bold; }\\n.cm-s-liquibyte span.cm-variable    { color: #5967ff; font-weight: bold; }\\n.cm-s-liquibyte span.cm-string      { color: #ff8000; }\\n.cm-s-liquibyte span.cm-number      { color: #0f0; font-weight: bold; }\\n.cm-s-liquibyte span.cm-atom        { color: #bf3030; font-weight: bold; }\\n\\n.cm-s-liquibyte span.cm-variable-2  { color: #007f7f; font-weight: bold; }\\n.cm-s-liquibyte span.cm-variable-3, .cm-s-liquibyte span.cm-type { color: #c080ff; font-weight: bold; }\\n.cm-s-liquibyte span.cm-property    { color: #999; font-weight: bold; }\\n.cm-s-liquibyte span.cm-operator    { color: #fff; }\\n\\n.cm-s-liquibyte span.cm-meta        { color: #0f0; }\\n.cm-s-liquibyte span.cm-qualifier   { color: #fff700; font-weight: bold; }\\n.cm-s-liquibyte span.cm-bracket     { color: #cc7; }\\n.cm-s-liquibyte span.cm-tag         { color: #ff0; font-weight: bold; }\\n.cm-s-liquibyte span.cm-attribute   { color: #c080ff; font-weight: bold; }\\n.cm-s-liquibyte span.cm-error       { color: #f00; }\\n\\n.cm-s-liquibyte div.CodeMirror-selected { background-color: rgba(255, 0, 0, 0.25); }\\n\\n.cm-s-liquibyte span.cm-compilation { background-color: rgba(255, 255, 255, 0.12); }\\n\\n.cm-s-liquibyte .CodeMirror-activeline-background { background-color: rgba(0, 255, 0, 0.15); }\\n\\n/* Default styles for common addons */\\n.cm-s-liquibyte .CodeMirror span.CodeMirror-matchingbracket { color: #0f0; font-weight: bold; }\\n.cm-s-liquibyte .CodeMirror span.CodeMirror-nonmatchingbracket { color: #f00; font-weight: bold; }\\n.CodeMirror-matchingtag { background-color: rgba(150, 255, 0, .3); }\\n/* Scrollbars */\\n/* Simple */\\n.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal div:hover, .cm-s-liquibyte div.CodeMirror-simplescroll-vertical div:hover {\\n\\tbackground-color: rgba(80, 80, 80, .7);\\n}\\n.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal div, .cm-s-liquibyte div.CodeMirror-simplescroll-vertical div {\\n\\tbackground-color: rgba(80, 80, 80, .3);\\n\\tborder: 1px solid #404040;\\n\\tborder-radius: 5px;\\n}\\n.cm-s-liquibyte div.CodeMirror-simplescroll-vertical div {\\n\\tborder-top: 1px solid #404040;\\n\\tborder-bottom: 1px solid #404040;\\n}\\n.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal div {\\n\\tborder-left: 1px solid #404040;\\n\\tborder-right: 1px solid #404040;\\n}\\n.cm-s-liquibyte div.CodeMirror-simplescroll-vertical {\\n\\tbackground-color: #262626;\\n}\\n.cm-s-liquibyte div.CodeMirror-simplescroll-horizontal {\\n\\tbackground-color: #262626;\\n\\tborder-top: 1px solid #404040;\\n}\\n/* Overlay */\\n.cm-s-liquibyte div.CodeMirror-overlayscroll-horizontal div, div.CodeMirror-overlayscroll-vertical div {\\n\\tbackground-color: #404040;\\n\\tborder-radius: 5px;\\n}\\n.cm-s-liquibyte div.CodeMirror-overlayscroll-vertical div {\\n\\tborder: 1px solid #404040;\\n}\\n.cm-s-liquibyte div.CodeMirror-overlayscroll-horizontal div {\\n\\tborder: 1px solid #404040;\\n}\\n\"","export default \"/*\\n  Name:       lucario\\n  Author:     Raphael Amorim\\n\\n  Original Lucario color scheme (https://github.com/raphamorim/lucario)\\n*/\\n\\n.cm-s-lucario.CodeMirror, .cm-s-lucario .CodeMirror-gutters {\\n  background-color: #2b3e50 !important;\\n  color: #f8f8f2 !important;\\n  border: none;\\n}\\n.cm-s-lucario .CodeMirror-gutters { color: #2b3e50; }\\n.cm-s-lucario .CodeMirror-cursor { border-left: solid thin #E6C845; }\\n.cm-s-lucario .CodeMirror-linenumber { color: #f8f8f2; }\\n.cm-s-lucario .CodeMirror-selected { background: #243443; }\\n.cm-s-lucario .CodeMirror-line::selection, .cm-s-lucario .CodeMirror-line > span::selection, .cm-s-lucario .CodeMirror-line > span > span::selection { background: #243443; }\\n.cm-s-lucario .CodeMirror-line::-moz-selection, .cm-s-lucario .CodeMirror-line > span::-moz-selection, .cm-s-lucario .CodeMirror-line > span > span::-moz-selection { background: #243443; }\\n.cm-s-lucario span.cm-comment { color: #5c98cd; }\\n.cm-s-lucario span.cm-string, .cm-s-lucario span.cm-string-2 { color: #E6DB74; }\\n.cm-s-lucario span.cm-number { color: #ca94ff; }\\n.cm-s-lucario span.cm-variable { color: #f8f8f2; }\\n.cm-s-lucario span.cm-variable-2 { color: #f8f8f2; }\\n.cm-s-lucario span.cm-def { color: #72C05D; }\\n.cm-s-lucario span.cm-operator { color: #66D9EF; }\\n.cm-s-lucario span.cm-keyword { color: #ff6541; }\\n.cm-s-lucario span.cm-atom { color: #bd93f9; }\\n.cm-s-lucario span.cm-meta { color: #f8f8f2; }\\n.cm-s-lucario span.cm-tag { color: #ff6541; }\\n.cm-s-lucario span.cm-attribute { color: #66D9EF; }\\n.cm-s-lucario span.cm-qualifier { color: #72C05D; }\\n.cm-s-lucario span.cm-property { color: #f8f8f2; }\\n.cm-s-lucario span.cm-builtin { color: #72C05D; }\\n.cm-s-lucario span.cm-variable-3, .cm-s-lucario span.cm-type { color: #ffb86c; }\\n\\n.cm-s-lucario .CodeMirror-activeline-background { background: #243443; }\\n.cm-s-lucario .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/*\\n\\n    Name:       material\\n    Author:     Michael Kaminsky (http://github.com/mkaminsky11)\\n\\n    Original material color scheme by Mattia Astorino (https://github.com/equinusocio/material-theme)\\n\\n*/\\n\\n.cm-s-material.CodeMirror {\\n  background-color: #263238;\\n  color: rgba(233, 237, 237, 1);\\n}\\n.cm-s-material .CodeMirror-gutters {\\n  background: #263238;\\n  color: rgb(83,127,126);\\n  border: none;\\n}\\n.cm-s-material .CodeMirror-guttermarker, .cm-s-material .CodeMirror-guttermarker-subtle, .cm-s-material .CodeMirror-linenumber { color: rgb(83,127,126); }\\n.cm-s-material .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }\\n.cm-s-material div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }\\n.cm-s-material.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-material .CodeMirror-line::selection, .cm-s-material .CodeMirror-line > span::selection, .cm-s-material .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-material .CodeMirror-line::-moz-selection, .cm-s-material .CodeMirror-line > span::-moz-selection, .cm-s-material .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }\\n\\n.cm-s-material .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }\\n.cm-s-material .cm-keyword { color: rgba(199, 146, 234, 1); }\\n.cm-s-material .cm-operator { color: rgba(233, 237, 237, 1); }\\n.cm-s-material .cm-variable-2 { color: #80CBC4; }\\n.cm-s-material .cm-variable-3, .cm-s-material .cm-type { color: #82B1FF; }\\n.cm-s-material .cm-builtin { color: #DECB6B; }\\n.cm-s-material .cm-atom { color: #F77669; }\\n.cm-s-material .cm-number { color: #F77669; }\\n.cm-s-material .cm-def { color: rgba(233, 237, 237, 1); }\\n.cm-s-material .cm-string { color: #C3E88D; }\\n.cm-s-material .cm-string-2 { color: #80CBC4; }\\n.cm-s-material .cm-comment { color: #546E7A; }\\n.cm-s-material .cm-variable { color: #82B1FF; }\\n.cm-s-material .cm-tag { color: #80CBC4; }\\n.cm-s-material .cm-meta { color: #80CBC4; }\\n.cm-s-material .cm-attribute { color: #FFCB6B; }\\n.cm-s-material .cm-property { color: #80CBAE; }\\n.cm-s-material .cm-qualifier { color: #DECB6B; }\\n.cm-s-material .cm-variable-3, .cm-s-material .cm-type { color: #DECB6B; }\\n.cm-s-material .cm-tag { color: rgba(255, 83, 112, 1); }\\n.cm-s-material .cm-error {\\n  color: rgba(255, 255, 255, 1.0);\\n  background-color: #EC5F67;\\n}\\n.cm-s-material .CodeMirror-matchingbracket {\\n  text-decoration: underline;\\n  color: white !important;\\n}\\n\"","export default \"/****************************************************************/\\n/*   Based on mbonaci's Brackets mbo theme                      */\\n/*   https://github.com/mbonaci/global/blob/master/Mbo.tmTheme  */\\n/*   Create your own: http://tmtheme-editor.herokuapp.com       */\\n/****************************************************************/\\n\\n.cm-s-mbo.CodeMirror { background: #2c2c2c; color: #ffffec; }\\n.cm-s-mbo div.CodeMirror-selected { background: #716C62; }\\n.cm-s-mbo .CodeMirror-line::selection, .cm-s-mbo .CodeMirror-line > span::selection, .cm-s-mbo .CodeMirror-line > span > span::selection { background: rgba(113, 108, 98, .99); }\\n.cm-s-mbo .CodeMirror-line::-moz-selection, .cm-s-mbo .CodeMirror-line > span::-moz-selection, .cm-s-mbo .CodeMirror-line > span > span::-moz-selection { background: rgba(113, 108, 98, .99); }\\n.cm-s-mbo .CodeMirror-gutters { background: #4e4e4e; border-right: 0px; }\\n.cm-s-mbo .CodeMirror-guttermarker { color: white; }\\n.cm-s-mbo .CodeMirror-guttermarker-subtle { color: grey; }\\n.cm-s-mbo .CodeMirror-linenumber { color: #dadada; }\\n.cm-s-mbo .CodeMirror-cursor { border-left: 1px solid #ffffec; }\\n\\n.cm-s-mbo span.cm-comment { color: #95958a; }\\n.cm-s-mbo span.cm-atom { color: #00a8c6; }\\n.cm-s-mbo span.cm-number { color: #00a8c6; }\\n\\n.cm-s-mbo span.cm-property, .cm-s-mbo span.cm-attribute { color: #9ddfe9; }\\n.cm-s-mbo span.cm-keyword { color: #ffb928; }\\n.cm-s-mbo span.cm-string { color: #ffcf6c; }\\n.cm-s-mbo span.cm-string.cm-property { color: #ffffec; }\\n\\n.cm-s-mbo span.cm-variable { color: #ffffec; }\\n.cm-s-mbo span.cm-variable-2 { color: #00a8c6; }\\n.cm-s-mbo span.cm-def { color: #ffffec; }\\n.cm-s-mbo span.cm-bracket { color: #fffffc; font-weight: bold; }\\n.cm-s-mbo span.cm-tag { color: #9ddfe9; }\\n.cm-s-mbo span.cm-link { color: #f54b07; }\\n.cm-s-mbo span.cm-error { border-bottom: #636363; color: #ffffec; }\\n.cm-s-mbo span.cm-qualifier { color: #ffffec; }\\n\\n.cm-s-mbo .CodeMirror-activeline-background { background: #494b41; }\\n.cm-s-mbo .CodeMirror-matchingbracket { color: #ffb928 !important; }\\n.cm-s-mbo .CodeMirror-matchingtag { background: rgba(255, 255, 255, .37); }\\n\"","export default \"/*\\n  MDN-LIKE Theme - Mozilla\\n  Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>\\n  Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues\\n  GitHub: @peterkroon\\n\\n  The mdn-like theme is inspired on the displayed code examples at: https://developer.mozilla.org/en-US/docs/Web/CSS/animation\\n\\n*/\\n.cm-s-mdn-like.CodeMirror { color: #999; background-color: #fff; }\\n.cm-s-mdn-like div.CodeMirror-selected { background: #cfc; }\\n.cm-s-mdn-like .CodeMirror-line::selection, .cm-s-mdn-like .CodeMirror-line > span::selection, .cm-s-mdn-like .CodeMirror-line > span > span::selection { background: #cfc; }\\n.cm-s-mdn-like .CodeMirror-line::-moz-selection, .cm-s-mdn-like .CodeMirror-line > span::-moz-selection, .cm-s-mdn-like .CodeMirror-line > span > span::-moz-selection { background: #cfc; }\\n\\n.cm-s-mdn-like .CodeMirror-gutters { background: #f8f8f8; border-left: 6px solid rgba(0,83,159,0.65); color: #333; }\\n.cm-s-mdn-like .CodeMirror-linenumber { color: #aaa; padding-left: 8px; }\\n.cm-s-mdn-like .CodeMirror-cursor { border-left: 2px solid #222; }\\n\\n.cm-s-mdn-like .cm-keyword { color: #6262FF; }\\n.cm-s-mdn-like .cm-atom { color: #F90; }\\n.cm-s-mdn-like .cm-number { color:  #ca7841; }\\n.cm-s-mdn-like .cm-def { color: #8DA6CE; }\\n.cm-s-mdn-like span.cm-variable-2, .cm-s-mdn-like span.cm-tag { color: #690; }\\n.cm-s-mdn-like span.cm-variable-3, .cm-s-mdn-like span.cm-def, .cm-s-mdn-like span.cm-type { color: #07a; }\\n\\n.cm-s-mdn-like .cm-variable { color: #07a; }\\n.cm-s-mdn-like .cm-property { color: #905; }\\n.cm-s-mdn-like .cm-qualifier { color: #690; }\\n\\n.cm-s-mdn-like .cm-operator { color: #cda869; }\\n.cm-s-mdn-like .cm-comment { color:#777; font-weight:normal; }\\n.cm-s-mdn-like .cm-string { color:#07a; font-style:italic; }\\n.cm-s-mdn-like .cm-string-2 { color:#bd6b18; } /*?*/\\n.cm-s-mdn-like .cm-meta { color: #000; } /*?*/\\n.cm-s-mdn-like .cm-builtin { color: #9B7536; } /*?*/\\n.cm-s-mdn-like .cm-tag { color: #997643; }\\n.cm-s-mdn-like .cm-attribute { color: #d6bb6d; } /*?*/\\n.cm-s-mdn-like .cm-header { color: #FF6400; }\\n.cm-s-mdn-like .cm-hr { color: #AEAEAE; }\\n.cm-s-mdn-like .cm-link { color:#ad9361; font-style:italic; text-decoration:none; }\\n.cm-s-mdn-like .cm-error { border-bottom: 1px solid red; }\\n\\ndiv.cm-s-mdn-like .CodeMirror-activeline-background { background: #efefff; }\\ndiv.cm-s-mdn-like span.CodeMirror-matchingbracket { outline:1px solid grey; color: inherit; }\\n\\n.cm-s-mdn-like.CodeMirror { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFcAAAAyCAYAAAAp8UeFAAAHvklEQVR42s2b63bcNgyEQZCSHCdt2vd/0tWF7I+Q6XgMXiTtuvU5Pl57ZQKkKHzEAOtF5KeIJBGJ8uvL599FRFREZhFx8DeXv8trn68RuGaC8TRfo3SNp9dlDDHedyLyTUTeRWStXKPZrjtpZxaRw5hPqozRs1N8/enzIiQRWcCgy4MUA0f+XWliDhyL8Lfyvx7ei/Ae3iQFHyw7U/59pQVIMEEPEz0G7XiwdRjzSfC3UTtz9vchIntxvry5iMgfIhJoEflOz2CQr3F5h/HfeFe+GTdLaKcu9L8LTeQb/R/7GgbsfKedyNdoHsN31uRPWrfZ5wsj/NzzRQHuToIdU3ahwnsKPxXCjJITuOsi7XLc7SG/v5GdALs7wf8JjTFiB5+QvTEfRyGOfX3Lrx8wxyQi3sNq46O7QahQiCsRFgqddjBouVEHOKDgXAQHD9gJCr5sMKkEdjwsarG/ww3BMHBU7OBjXnzdyY7SfCxf5/z6ATccrwlKuwC/jhznnPF4CgVzhhVf4xp2EixcBActO75iZ8/fM9zAs2OMzKdslgXWJ9XG8PQoOAMA5fGcsvORgv0doBXyHrCwfLJAOwo71QLNkb8n2Pl6EWiR7OCibtkPaz4Kc/0NNAze2gju3zOwekALDaCFPI5vjPFmgGY5AZqyGEvH1x7QfIb8YtxMnA/b+QQ0aQDAwc6JMFg8CbQZ4qoYEEHbRwNojuK3EHwd7VALSgq+MNDKzfT58T8qdpADrgW0GmgcAS1lhzztJmkAzcPNOQbsWEALBDSlMKUG0Eq4CLAQWvEVQ9WU57gZJwZtgPO3r9oBTQ9WO8TjqXINx8R0EYpiZEUWOF3FxkbJkgU9B2f41YBrIj5ZfsQa0M5kTgiAAqM3ShXLgu8XMqcrQBvJ0CL5pnTsfMB13oB8athpAq2XOQmcGmoACCLydx7nToa23ATaSIY2ichfOdPTGxlasXMLaL0MLZAOwAKIM+y8CmicobGdCcbbK9DzN+yYGVoNNI5iUKTMyYOjPse4A8SM1MmcXgU0toOq1yO/v8FOxlASyc7TgeYaAMBJHcY1CcCwGI/TK4AmDbDyKYBBtFUkRwto8gygiQEaByFgJ00BH2M8JWwQS1nafDXQCidWyOI8AcjDCSjCLk8ngObuAm3JAHAdubAmOaK06V8MNEsKPJOhobSprwQa6gD7DclRQdqcwL4zxqgBrQcabUiBLclRDKAlWp+etPkBaNMA0AKlrHwTdEByZAA4GM+SNluSY6wAzcMNewxmgig5Ks0nkrSpBvSaQHMdKTBAnLojOdYyGpQ254602ZILPdTD1hdlggdIm74jbTp8vDwF5ZYUeLWGJpWsh6XNyXgcYwVoJQTEhhTYkxzZjiU5npU2TaB979TQehlaAVq4kaGpiPwwwLkYUuBbQwocyQTv1tA0+1UFWoJF3iv1oq+qoSk8EQdJmwHkziIF7oOZk14EGitibAdjLYYK78H5vZOhtWpoI0ATGHs0Q8OMb4Ey+2bU2UYztCtA0wFAs7TplGLRVQCcqaFdGSPCeTI1QNIC52iWNzof6Uib7xjEp07mNNoUYmVosVItHrHzRlLgBn9LFyRHaQCtVUMbtTNhoXWiTOO9k/V8BdAc1Oq0ArSQs6/5SU0hckNy9NnXqQY0PGYo5dWJ7nINaN6o958FWin27aBaWRka1r5myvLOAm0j30eBJqCxHLReVclxhxOEN2JfDWjxBtAC7MIH1fVaGdoOp4qJYDgKtKPSFNID2gSnGldrCqkFZ+5UeQXQBIRrSwocbdZYQT/2LwRahBPBXoHrB8nxaGROST62DKUbQOMMzZIC9abkuELfQzQALWTnDNAm8KHWFOJgJ5+SHIvTPcmx1xQyZRhNL5Qci689aXMEaN/uNIWkEwDAvFpOZmgsBaaGnbs1NPa1Jm32gBZAIh1pCtG7TSH4aE0y1uVY4uqoFPisGlpP2rSA5qTecWn5agK6BzSpgAyD+wFaqhnYoSZ1Vwr8CmlTQbrcO3ZaX0NAEyMbYaAlyquFoLKK3SPby9CeVUPThrSJmkCAE0CrKUQadi4DrdSlWhmah0YL9z9vClH59YGbHx1J8VZTyAjQepJjmXwAKTDQI3omc3p1U4gDUf6RfcdYfrUp5ClAi2J3Ba6UOXGo+K+bQrjjssitG2SJzshaLwMtXgRagUNpYYoVkMSBLM+9GGiJZMvduG6DRZ4qc04DMPtQQxOjEtACmhO7K1AbNbQDEggZyJwscFpAGwENhoBeUwh3bWolhe8BTYVKxQEWrSUn/uhcM5KhvUu/+eQu0Lzhi+VrK0PrZZNDQKs9cpYUuFYgMVpD4/NxenJTiMCNqdUEUf1qZWjppLT5qSkkUZbCwkbZMSuVnu80hfSkzRbQeqCZSAh6huR4VtoM2gHAlLf72smuWgE+VV7XpE25Ab2WFDgyhnSuKbs4GuGzCjR+tIoUuMFg3kgcWKLTwRqanJQ2W00hAsenfaApRC42hbCvK1SlE0HtE9BGgneJO+ELamitD1YjjOYnNYVcraGhtKkW0EqVVeDx733I2NH581k1NNxNLG0i0IJ8/NjVaOZ0tYZ2Vtr0Xv7tPV3hkWp9EFkgS/J0vosngTaSoaG06WHi+xObQkaAdlbanP8B2+2l0f90LmUAAAAASUVORK5CYII=); }\\n\"","export default \"/* Based on the theme at http://bonsaiden.github.com/JavaScript-Garden */\\n\\n/*<!--match-->*/\\n.cm-s-midnight span.CodeMirror-matchhighlight { background: #494949; }\\n.cm-s-midnight.CodeMirror-focused span.CodeMirror-matchhighlight { background: #314D67 !important; }\\n\\n/*<!--activeline-->*/\\n.cm-s-midnight .CodeMirror-activeline-background { background: #253540; }\\n\\n.cm-s-midnight.CodeMirror {\\n    background: #0F192A;\\n    color: #D1EDFF;\\n}\\n\\n.cm-s-midnight div.CodeMirror-selected { background: #314D67; }\\n.cm-s-midnight .CodeMirror-line::selection, .cm-s-midnight .CodeMirror-line > span::selection, .cm-s-midnight .CodeMirror-line > span > span::selection { background: rgba(49, 77, 103, .99); }\\n.cm-s-midnight .CodeMirror-line::-moz-selection, .cm-s-midnight .CodeMirror-line > span::-moz-selection, .cm-s-midnight .CodeMirror-line > span > span::-moz-selection { background: rgba(49, 77, 103, .99); }\\n.cm-s-midnight .CodeMirror-gutters { background: #0F192A; border-right: 1px solid; }\\n.cm-s-midnight .CodeMirror-guttermarker { color: white; }\\n.cm-s-midnight .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\\n.cm-s-midnight .CodeMirror-linenumber { color: #D0D0D0; }\\n.cm-s-midnight .CodeMirror-cursor { border-left: 1px solid #F8F8F0; }\\n\\n.cm-s-midnight span.cm-comment { color: #428BDD; }\\n.cm-s-midnight span.cm-atom { color: #AE81FF; }\\n.cm-s-midnight span.cm-number { color: #D1EDFF; }\\n\\n.cm-s-midnight span.cm-property, .cm-s-midnight span.cm-attribute { color: #A6E22E; }\\n.cm-s-midnight span.cm-keyword { color: #E83737; }\\n.cm-s-midnight span.cm-string { color: #1DC116; }\\n\\n.cm-s-midnight span.cm-variable { color: #FFAA3E; }\\n.cm-s-midnight span.cm-variable-2 { color: #FFAA3E; }\\n.cm-s-midnight span.cm-def { color: #4DD; }\\n.cm-s-midnight span.cm-bracket { color: #D1EDFF; }\\n.cm-s-midnight span.cm-tag { color: #449; }\\n.cm-s-midnight span.cm-link { color: #AE81FF; }\\n.cm-s-midnight span.cm-error { background: #F92672; color: #F8F8F0; }\\n\\n.cm-s-midnight .CodeMirror-matchingbracket {\\n  text-decoration: underline;\\n  color: white !important;\\n}\\n\"","export default \"/* Based on Sublime Text's Monokai theme */\\n\\n.cm-s-monokai.CodeMirror { background: #272822; color: #f8f8f2; }\\n.cm-s-monokai div.CodeMirror-selected { background: #49483E; }\\n.cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line > span::selection, .cm-s-monokai .CodeMirror-line > span > span::selection { background: rgba(73, 72, 62, .99); }\\n.cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line > span::-moz-selection, .cm-s-monokai .CodeMirror-line > span > span::-moz-selection { background: rgba(73, 72, 62, .99); }\\n.cm-s-monokai .CodeMirror-gutters { background: #272822; border-right: 0px; }\\n.cm-s-monokai .CodeMirror-guttermarker { color: white; }\\n.cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\\n.cm-s-monokai .CodeMirror-linenumber { color: #d0d0d0; }\\n.cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }\\n\\n.cm-s-monokai span.cm-comment { color: #75715e; }\\n.cm-s-monokai span.cm-atom { color: #ae81ff; }\\n.cm-s-monokai span.cm-number { color: #ae81ff; }\\n\\n.cm-s-monokai span.cm-comment.cm-attribute { color: #97b757; }\\n.cm-s-monokai span.cm-comment.cm-def { color: #bc9262; }\\n.cm-s-monokai span.cm-comment.cm-tag { color: #bc6283; }\\n.cm-s-monokai span.cm-comment.cm-type { color: #5998a6; }\\n\\n.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute { color: #a6e22e; }\\n.cm-s-monokai span.cm-keyword { color: #f92672; }\\n.cm-s-monokai span.cm-builtin { color: #66d9ef; }\\n.cm-s-monokai span.cm-string { color: #e6db74; }\\n\\n.cm-s-monokai span.cm-variable { color: #f8f8f2; }\\n.cm-s-monokai span.cm-variable-2 { color: #9effff; }\\n.cm-s-monokai span.cm-variable-3, .cm-s-monokai span.cm-type { color: #66d9ef; }\\n.cm-s-monokai span.cm-def { color: #fd971f; }\\n.cm-s-monokai span.cm-bracket { color: #f8f8f2; }\\n.cm-s-monokai span.cm-tag { color: #f92672; }\\n.cm-s-monokai span.cm-header { color: #ae81ff; }\\n.cm-s-monokai span.cm-link { color: #ae81ff; }\\n.cm-s-monokai span.cm-error { background: #f92672; color: #f8f8f0; }\\n\\n.cm-s-monokai .CodeMirror-activeline-background { background: #373831; }\\n.cm-s-monokai .CodeMirror-matchingbracket {\\n  text-decoration: underline;\\n  color: white !important;\\n}\\n\"","export default \".cm-s-neat span.cm-comment { color: #a86; }\\n.cm-s-neat span.cm-keyword { line-height: 1em; font-weight: bold; color: blue; }\\n.cm-s-neat span.cm-string { color: #a22; }\\n.cm-s-neat span.cm-builtin { line-height: 1em; font-weight: bold; color: #077; }\\n.cm-s-neat span.cm-special { line-height: 1em; font-weight: bold; color: #0aa; }\\n.cm-s-neat span.cm-variable { color: black; }\\n.cm-s-neat span.cm-number, .cm-s-neat span.cm-atom { color: #3a3; }\\n.cm-s-neat span.cm-meta { color: #555; }\\n.cm-s-neat span.cm-link { color: #3a3; }\\n\\n.cm-s-neat .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-neat .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }\\n\"","export default \"/* neo theme for codemirror */\\n\\n/* Color scheme */\\n\\n.cm-s-neo.CodeMirror {\\n  background-color:#ffffff;\\n  color:#2e383c;\\n  line-height:1.4375;\\n}\\n.cm-s-neo .cm-comment { color:#75787b; }\\n.cm-s-neo .cm-keyword, .cm-s-neo .cm-property { color:#1d75b3; }\\n.cm-s-neo .cm-atom,.cm-s-neo .cm-number { color:#75438a; }\\n.cm-s-neo .cm-node,.cm-s-neo .cm-tag { color:#9c3328; }\\n.cm-s-neo .cm-string { color:#b35e14; }\\n.cm-s-neo .cm-variable,.cm-s-neo .cm-qualifier { color:#047d65; }\\n\\n\\n/* Editor styling */\\n\\n.cm-s-neo pre {\\n  padding:0;\\n}\\n\\n.cm-s-neo .CodeMirror-gutters {\\n  border:none;\\n  border-right:10px solid transparent;\\n  background-color:transparent;\\n}\\n\\n.cm-s-neo .CodeMirror-linenumber {\\n  padding:0;\\n  color:#e0e2e5;\\n}\\n\\n.cm-s-neo .CodeMirror-guttermarker { color: #1d75b3; }\\n.cm-s-neo .CodeMirror-guttermarker-subtle { color: #e0e2e5; }\\n\\n.cm-s-neo .CodeMirror-cursor {\\n  width: auto;\\n  border: 0;\\n  background: rgba(155,157,162,0.37);\\n  z-index: 1;\\n}\\n\"","export default \"/* Loosely based on the Midnight Textmate theme */\\n\\n.cm-s-night.CodeMirror { background: #0a001f; color: #f8f8f8; }\\n.cm-s-night div.CodeMirror-selected { background: #447; }\\n.cm-s-night .CodeMirror-line::selection, .cm-s-night .CodeMirror-line > span::selection, .cm-s-night .CodeMirror-line > span > span::selection { background: rgba(68, 68, 119, .99); }\\n.cm-s-night .CodeMirror-line::-moz-selection, .cm-s-night .CodeMirror-line > span::-moz-selection, .cm-s-night .CodeMirror-line > span > span::-moz-selection { background: rgba(68, 68, 119, .99); }\\n.cm-s-night .CodeMirror-gutters { background: #0a001f; border-right: 1px solid #aaa; }\\n.cm-s-night .CodeMirror-guttermarker { color: white; }\\n.cm-s-night .CodeMirror-guttermarker-subtle { color: #bbb; }\\n.cm-s-night .CodeMirror-linenumber { color: #f8f8f8; }\\n.cm-s-night .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-night span.cm-comment { color: #8900d1; }\\n.cm-s-night span.cm-atom { color: #845dc4; }\\n.cm-s-night span.cm-number, .cm-s-night span.cm-attribute { color: #ffd500; }\\n.cm-s-night span.cm-keyword { color: #599eff; }\\n.cm-s-night span.cm-string { color: #37f14a; }\\n.cm-s-night span.cm-meta { color: #7678e2; }\\n.cm-s-night span.cm-variable-2, .cm-s-night span.cm-tag { color: #99b2ff; }\\n.cm-s-night span.cm-variable-3, .cm-s-night span.cm-def, .cm-s-night span.cm-type { color: white; }\\n.cm-s-night span.cm-bracket { color: #8da6ce; }\\n.cm-s-night span.cm-builtin, .cm-s-night span.cm-special { color: #ff9e59; }\\n.cm-s-night span.cm-link { color: #845dc4; }\\n.cm-s-night span.cm-error { color: #9d1e15; }\\n\\n.cm-s-night .CodeMirror-activeline-background { background: #1C005A; }\\n.cm-s-night .CodeMirror-matchingbracket { outline:1px solid grey; color:white !important; }\\n\"","export default \"/* Based on arcticicestudio's Nord theme */\\n/* https://github.com/arcticicestudio/nord */\\n\\n.cm-s-nord.CodeMirror { background: #2e3440; color: #d8dee9; }\\n.cm-s-nord div.CodeMirror-selected { background: #434c5e; }\\n.cm-s-nord .CodeMirror-line::selection, .cm-s-nord .CodeMirror-line > span::selection, .cm-s-nord .CodeMirror-line > span > span::selection { background: #3b4252; }\\n.cm-s-nord .CodeMirror-line::-moz-selection, .cm-s-nord .CodeMirror-line > span::-moz-selection, .cm-s-nord .CodeMirror-line > span > span::-moz-selection { background: #3b4252; }\\n.cm-s-nord .CodeMirror-gutters { background: #2e3440; border-right: 0px; }\\n.cm-s-nord .CodeMirror-guttermarker { color: #4c566a; }\\n.cm-s-nord .CodeMirror-guttermarker-subtle { color: #4c566a; }\\n.cm-s-nord .CodeMirror-linenumber { color: #4c566a; }\\n.cm-s-nord .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }\\n\\n.cm-s-nord span.cm-comment { color: #4c566a; }\\n.cm-s-nord span.cm-atom { color: #b48ead; }\\n.cm-s-nord span.cm-number { color: #b48ead; }\\n\\n.cm-s-nord span.cm-comment.cm-attribute { color: #97b757; }\\n.cm-s-nord span.cm-comment.cm-def { color: #bc9262; }\\n.cm-s-nord span.cm-comment.cm-tag { color: #bc6283; }\\n.cm-s-nord span.cm-comment.cm-type { color: #5998a6; }\\n\\n.cm-s-nord span.cm-property, .cm-s-nord span.cm-attribute { color: #8FBCBB; }\\n.cm-s-nord span.cm-keyword { color: #81A1C1; }\\n.cm-s-nord span.cm-builtin { color: #81A1C1; }\\n.cm-s-nord span.cm-string { color: #A3BE8C; }\\n\\n.cm-s-nord span.cm-variable { color: #d8dee9; }\\n.cm-s-nord span.cm-variable-2 { color: #d8dee9; }\\n.cm-s-nord span.cm-variable-3, .cm-s-nord span.cm-type { color: #d8dee9; }\\n.cm-s-nord span.cm-def { color: #8FBCBB; }\\n.cm-s-nord span.cm-bracket { color: #81A1C1; }\\n.cm-s-nord span.cm-tag { color: #bf616a; }\\n.cm-s-nord span.cm-header { color: #b48ead; }\\n.cm-s-nord span.cm-link { color: #b48ead; }\\n.cm-s-nord span.cm-error { background: #bf616a; color: #f8f8f0; }\\n\\n.cm-s-nord .CodeMirror-activeline-background { background: #3b4252; }\\n.cm-s-nord .CodeMirror-matchingbracket {\\n  text-decoration: underline;\\n  color: white !important;\\n}\\n\"","export default \"/*\\n\\n    Name:       oceanic-next\\n    Author:     Filype Pereira (https://github.com/fpereira1)\\n\\n    Original oceanic-next color scheme by Dmitri Voronianski (https://github.com/voronianski/oceanic-next-color-scheme)\\n\\n*/\\n\\n.cm-s-oceanic-next.CodeMirror { background: #304148; color: #f8f8f2; }\\n.cm-s-oceanic-next div.CodeMirror-selected { background: rgba(101, 115, 126, 0.33); }\\n.cm-s-oceanic-next .CodeMirror-line::selection, .cm-s-oceanic-next .CodeMirror-line > span::selection, .cm-s-oceanic-next .CodeMirror-line > span > span::selection { background: rgba(101, 115, 126, 0.33); }\\n.cm-s-oceanic-next .CodeMirror-line::-moz-selection, .cm-s-oceanic-next .CodeMirror-line > span::-moz-selection, .cm-s-oceanic-next .CodeMirror-line > span > span::-moz-selection { background: rgba(101, 115, 126, 0.33); }\\n.cm-s-oceanic-next .CodeMirror-gutters { background: #304148; border-right: 10px; }\\n.cm-s-oceanic-next .CodeMirror-guttermarker { color: white; }\\n.cm-s-oceanic-next .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\\n.cm-s-oceanic-next .CodeMirror-linenumber { color: #d0d0d0; }\\n.cm-s-oceanic-next .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }\\n\\n.cm-s-oceanic-next span.cm-comment { color: #65737E; }\\n.cm-s-oceanic-next span.cm-atom { color: #C594C5; }\\n.cm-s-oceanic-next span.cm-number { color: #F99157; }\\n\\n.cm-s-oceanic-next span.cm-property { color: #99C794; }\\n.cm-s-oceanic-next span.cm-attribute,\\n.cm-s-oceanic-next span.cm-keyword { color: #C594C5; }\\n.cm-s-oceanic-next span.cm-builtin { color: #66d9ef; }\\n.cm-s-oceanic-next span.cm-string { color: #99C794; }\\n\\n.cm-s-oceanic-next span.cm-variable,\\n.cm-s-oceanic-next span.cm-variable-2,\\n.cm-s-oceanic-next span.cm-variable-3 { color: #f8f8f2; }\\n.cm-s-oceanic-next span.cm-def { color: #6699CC; }\\n.cm-s-oceanic-next span.cm-bracket { color: #5FB3B3; }\\n.cm-s-oceanic-next span.cm-tag { color: #C594C5; }\\n.cm-s-oceanic-next span.cm-header { color: #C594C5; }\\n.cm-s-oceanic-next span.cm-link { color: #C594C5; }\\n.cm-s-oceanic-next span.cm-error { background: #C594C5; color: #f8f8f0; }\\n\\n.cm-s-oceanic-next .CodeMirror-activeline-background { background: rgba(101, 115, 126, 0.33); }\\n.cm-s-oceanic-next .CodeMirror-matchingbracket {\\n  text-decoration: underline;\\n  color: white !important;\\n}\\n\"","export default \"/*\\n\\tName:       Panda Syntax\\n\\tAuthor:     Siamak Mokhtari (http://github.com/siamak/)\\n\\tCodeMirror template by Siamak Mokhtari (https://github.com/siamak/atom-panda-syntax)\\n*/\\n.cm-s-panda-syntax {\\n\\tbackground: #292A2B;\\n\\tcolor: #E6E6E6;\\n\\tline-height: 1.5;\\n\\tfont-family: 'Operator Mono', 'Source Code Pro', Menlo, Monaco, Consolas, Courier New, monospace;\\n}\\n.cm-s-panda-syntax .CodeMirror-cursor { border-color: #ff2c6d; }\\n.cm-s-panda-syntax .CodeMirror-activeline-background {\\n\\tbackground: rgba(99, 123, 156, 0.1);\\n}\\n.cm-s-panda-syntax .CodeMirror-selected {\\n\\tbackground: #FFF;\\n}\\n.cm-s-panda-syntax .cm-comment {\\n\\tfont-style: italic;\\n\\tcolor: #676B79;\\n}\\n.cm-s-panda-syntax .cm-operator {\\n\\tcolor: #f3f3f3;\\n}\\n.cm-s-panda-syntax .cm-string {\\n\\tcolor: #19F9D8;\\n}\\n.cm-s-panda-syntax .cm-string-2 {\\n    color: #FFB86C;\\n}\\n\\n.cm-s-panda-syntax .cm-tag {\\n\\tcolor: #ff2c6d;\\n}\\n.cm-s-panda-syntax .cm-meta {\\n\\tcolor: #b084eb;\\n}\\n\\n.cm-s-panda-syntax .cm-number {\\n\\tcolor: #FFB86C;\\n}\\n.cm-s-panda-syntax .cm-atom {\\n\\tcolor: #ff2c6d;\\n}\\n.cm-s-panda-syntax .cm-keyword {\\n\\tcolor: #FF75B5;\\n}\\n.cm-s-panda-syntax .cm-variable {\\n\\tcolor: #ffb86c;\\n}\\n.cm-s-panda-syntax .cm-variable-2 {\\n\\tcolor: #ff9ac1;\\n}\\n.cm-s-panda-syntax .cm-variable-3, .cm-s-panda-syntax .cm-type {\\n\\tcolor: #ff9ac1;\\n}\\n\\n.cm-s-panda-syntax .cm-def {\\n\\tcolor: #e6e6e6;\\n}\\n.cm-s-panda-syntax .cm-property {\\n\\tcolor: #f3f3f3;\\n}\\n.cm-s-panda-syntax .cm-unit {\\n    color: #ffb86c;\\n}\\n\\n.cm-s-panda-syntax .cm-attribute {\\n    color: #ffb86c;\\n}\\n\\n.cm-s-panda-syntax .CodeMirror-matchingbracket {\\n    border-bottom: 1px dotted #19F9D8;\\n    padding-bottom: 2px;\\n    color: #e6e6e6;\\n}\\n.cm-s-panda-syntax .CodeMirror-gutters {\\n    background: #292a2b;\\n    border-right-color: rgba(255, 255, 255, 0.1);\\n}\\n.cm-s-panda-syntax .CodeMirror-linenumber {\\n    color: #e6e6e6;\\n    opacity: 0.6;\\n}\\n\"","export default \"/*\\n\\n    Name:       Paraso (Dark)\\n    Author:     Jan T. Sott\\n\\n    Color scheme by Jan T. Sott (https://github.com/idleberg/Paraiso-CodeMirror)\\n    Inspired by the art of Rubens LP (http://www.rubenslp.com.br)\\n\\n*/\\n\\n.cm-s-paraiso-dark.CodeMirror { background: #2f1e2e; color: #b9b6b0; }\\n.cm-s-paraiso-dark div.CodeMirror-selected { background: #41323f; }\\n.cm-s-paraiso-dark .CodeMirror-line::selection, .cm-s-paraiso-dark .CodeMirror-line > span::selection, .cm-s-paraiso-dark .CodeMirror-line > span > span::selection { background: rgba(65, 50, 63, .99); }\\n.cm-s-paraiso-dark .CodeMirror-line::-moz-selection, .cm-s-paraiso-dark .CodeMirror-line > span::-moz-selection, .cm-s-paraiso-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(65, 50, 63, .99); }\\n.cm-s-paraiso-dark .CodeMirror-gutters { background: #2f1e2e; border-right: 0px; }\\n.cm-s-paraiso-dark .CodeMirror-guttermarker { color: #ef6155; }\\n.cm-s-paraiso-dark .CodeMirror-guttermarker-subtle { color: #776e71; }\\n.cm-s-paraiso-dark .CodeMirror-linenumber { color: #776e71; }\\n.cm-s-paraiso-dark .CodeMirror-cursor { border-left: 1px solid #8d8687; }\\n\\n.cm-s-paraiso-dark span.cm-comment { color: #e96ba8; }\\n.cm-s-paraiso-dark span.cm-atom { color: #815ba4; }\\n.cm-s-paraiso-dark span.cm-number { color: #815ba4; }\\n\\n.cm-s-paraiso-dark span.cm-property, .cm-s-paraiso-dark span.cm-attribute { color: #48b685; }\\n.cm-s-paraiso-dark span.cm-keyword { color: #ef6155; }\\n.cm-s-paraiso-dark span.cm-string { color: #fec418; }\\n\\n.cm-s-paraiso-dark span.cm-variable { color: #48b685; }\\n.cm-s-paraiso-dark span.cm-variable-2 { color: #06b6ef; }\\n.cm-s-paraiso-dark span.cm-def { color: #f99b15; }\\n.cm-s-paraiso-dark span.cm-bracket { color: #b9b6b0; }\\n.cm-s-paraiso-dark span.cm-tag { color: #ef6155; }\\n.cm-s-paraiso-dark span.cm-link { color: #815ba4; }\\n.cm-s-paraiso-dark span.cm-error { background: #ef6155; color: #8d8687; }\\n\\n.cm-s-paraiso-dark .CodeMirror-activeline-background { background: #4D344A; }\\n.cm-s-paraiso-dark .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/*\\n\\n    Name:       Paraso (Light)\\n    Author:     Jan T. Sott\\n\\n    Color scheme by Jan T. Sott (https://github.com/idleberg/Paraiso-CodeMirror)\\n    Inspired by the art of Rubens LP (http://www.rubenslp.com.br)\\n\\n*/\\n\\n.cm-s-paraiso-light.CodeMirror { background: #e7e9db; color: #41323f; }\\n.cm-s-paraiso-light div.CodeMirror-selected { background: #b9b6b0; }\\n.cm-s-paraiso-light .CodeMirror-line::selection, .cm-s-paraiso-light .CodeMirror-line > span::selection, .cm-s-paraiso-light .CodeMirror-line > span > span::selection { background: #b9b6b0; }\\n.cm-s-paraiso-light .CodeMirror-line::-moz-selection, .cm-s-paraiso-light .CodeMirror-line > span::-moz-selection, .cm-s-paraiso-light .CodeMirror-line > span > span::-moz-selection { background: #b9b6b0; }\\n.cm-s-paraiso-light .CodeMirror-gutters { background: #e7e9db; border-right: 0px; }\\n.cm-s-paraiso-light .CodeMirror-guttermarker { color: black; }\\n.cm-s-paraiso-light .CodeMirror-guttermarker-subtle { color: #8d8687; }\\n.cm-s-paraiso-light .CodeMirror-linenumber { color: #8d8687; }\\n.cm-s-paraiso-light .CodeMirror-cursor { border-left: 1px solid #776e71; }\\n\\n.cm-s-paraiso-light span.cm-comment { color: #e96ba8; }\\n.cm-s-paraiso-light span.cm-atom { color: #815ba4; }\\n.cm-s-paraiso-light span.cm-number { color: #815ba4; }\\n\\n.cm-s-paraiso-light span.cm-property, .cm-s-paraiso-light span.cm-attribute { color: #48b685; }\\n.cm-s-paraiso-light span.cm-keyword { color: #ef6155; }\\n.cm-s-paraiso-light span.cm-string { color: #fec418; }\\n\\n.cm-s-paraiso-light span.cm-variable { color: #48b685; }\\n.cm-s-paraiso-light span.cm-variable-2 { color: #06b6ef; }\\n.cm-s-paraiso-light span.cm-def { color: #f99b15; }\\n.cm-s-paraiso-light span.cm-bracket { color: #41323f; }\\n.cm-s-paraiso-light span.cm-tag { color: #ef6155; }\\n.cm-s-paraiso-light span.cm-link { color: #815ba4; }\\n.cm-s-paraiso-light span.cm-error { background: #ef6155; color: #776e71; }\\n\\n.cm-s-paraiso-light .CodeMirror-activeline-background { background: #CFD1C4; }\\n.cm-s-paraiso-light .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/**\\n * Pastel On Dark theme ported from ACE editor\\n * @license MIT\\n * @copyright AtomicPages LLC 2014\\n * @author Dennis Thompson, AtomicPages LLC\\n * @version 1.1\\n * @source https://github.com/atomicpages/codemirror-pastel-on-dark-theme\\n */\\n\\n.cm-s-pastel-on-dark.CodeMirror {\\n\\tbackground: #2c2827;\\n\\tcolor: #8F938F;\\n\\tline-height: 1.5;\\n}\\n.cm-s-pastel-on-dark div.CodeMirror-selected { background: rgba(221,240,255,0.2); }\\n.cm-s-pastel-on-dark .CodeMirror-line::selection, .cm-s-pastel-on-dark .CodeMirror-line > span::selection, .cm-s-pastel-on-dark .CodeMirror-line > span > span::selection { background: rgba(221,240,255,0.2); }\\n.cm-s-pastel-on-dark .CodeMirror-line::-moz-selection, .cm-s-pastel-on-dark .CodeMirror-line > span::-moz-selection, .cm-s-pastel-on-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(221,240,255,0.2); }\\n\\n.cm-s-pastel-on-dark .CodeMirror-gutters {\\n\\tbackground: #34302f;\\n\\tborder-right: 0px;\\n\\tpadding: 0 3px;\\n}\\n.cm-s-pastel-on-dark .CodeMirror-guttermarker { color: white; }\\n.cm-s-pastel-on-dark .CodeMirror-guttermarker-subtle { color: #8F938F; }\\n.cm-s-pastel-on-dark .CodeMirror-linenumber { color: #8F938F; }\\n.cm-s-pastel-on-dark .CodeMirror-cursor { border-left: 1px solid #A7A7A7; }\\n.cm-s-pastel-on-dark span.cm-comment { color: #A6C6FF; }\\n.cm-s-pastel-on-dark span.cm-atom { color: #DE8E30; }\\n.cm-s-pastel-on-dark span.cm-number { color: #CCCCCC; }\\n.cm-s-pastel-on-dark span.cm-property { color: #8F938F; }\\n.cm-s-pastel-on-dark span.cm-attribute { color: #a6e22e; }\\n.cm-s-pastel-on-dark span.cm-keyword { color: #AEB2F8; }\\n.cm-s-pastel-on-dark span.cm-string { color: #66A968; }\\n.cm-s-pastel-on-dark span.cm-variable { color: #AEB2F8; }\\n.cm-s-pastel-on-dark span.cm-variable-2 { color: #BEBF55; }\\n.cm-s-pastel-on-dark span.cm-variable-3, .cm-s-pastel-on-dark span.cm-type { color: #DE8E30; }\\n.cm-s-pastel-on-dark span.cm-def { color: #757aD8; }\\n.cm-s-pastel-on-dark span.cm-bracket { color: #f8f8f2; }\\n.cm-s-pastel-on-dark span.cm-tag { color: #C1C144; }\\n.cm-s-pastel-on-dark span.cm-link { color: #ae81ff; }\\n.cm-s-pastel-on-dark span.cm-qualifier,.cm-s-pastel-on-dark span.cm-builtin { color: #C1C144; }\\n.cm-s-pastel-on-dark span.cm-error {\\n\\tbackground: #757aD8;\\n\\tcolor: #f8f8f0;\\n}\\n.cm-s-pastel-on-dark .CodeMirror-activeline-background { background: rgba(255, 255, 255, 0.031); }\\n.cm-s-pastel-on-dark .CodeMirror-matchingbracket {\\n\\tborder: 1px solid rgba(255,255,255,0.25);\\n\\tcolor: #8F938F !important;\\n\\tmargin: -1px -1px 0 -1px;\\n}\\n\"","export default \"/*\\n\\n    Name:       Railscasts\\n    Author:     Ryan Bates (http://railscasts.com)\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-railscasts.CodeMirror {background: #2b2b2b; color: #f4f1ed;}\\n.cm-s-railscasts div.CodeMirror-selected {background: #272935 !important;}\\n.cm-s-railscasts .CodeMirror-gutters {background: #2b2b2b; border-right: 0px;}\\n.cm-s-railscasts .CodeMirror-linenumber {color: #5a647e;}\\n.cm-s-railscasts .CodeMirror-cursor {border-left: 1px solid #d4cfc9 !important;}\\n\\n.cm-s-railscasts span.cm-comment {color: #bc9458;}\\n.cm-s-railscasts span.cm-atom {color: #b6b3eb;}\\n.cm-s-railscasts span.cm-number {color: #b6b3eb;}\\n\\n.cm-s-railscasts span.cm-property, .cm-s-railscasts span.cm-attribute {color: #a5c261;}\\n.cm-s-railscasts span.cm-keyword {color: #da4939;}\\n.cm-s-railscasts span.cm-string {color: #ffc66d;}\\n\\n.cm-s-railscasts span.cm-variable {color: #a5c261;}\\n.cm-s-railscasts span.cm-variable-2 {color: #6d9cbe;}\\n.cm-s-railscasts span.cm-def {color: #cc7833;}\\n.cm-s-railscasts span.cm-error {background: #da4939; color: #d4cfc9;}\\n.cm-s-railscasts span.cm-bracket {color: #f4f1ed;}\\n.cm-s-railscasts span.cm-tag {color: #da4939;}\\n.cm-s-railscasts span.cm-link {color: #b6b3eb;}\\n\\n.cm-s-railscasts .CodeMirror-matchingbracket { text-decoration: underline; color: white !important;}\\n.cm-s-railscasts .CodeMirror-activeline-background { background: #303040; }\\n\"","export default \".cm-s-rubyblue.CodeMirror { background: #112435; color: white; }\\n.cm-s-rubyblue div.CodeMirror-selected { background: #38566F; }\\n.cm-s-rubyblue .CodeMirror-line::selection, .cm-s-rubyblue .CodeMirror-line > span::selection, .cm-s-rubyblue .CodeMirror-line > span > span::selection { background: rgba(56, 86, 111, 0.99); }\\n.cm-s-rubyblue .CodeMirror-line::-moz-selection, .cm-s-rubyblue .CodeMirror-line > span::-moz-selection, .cm-s-rubyblue .CodeMirror-line > span > span::-moz-selection { background: rgba(56, 86, 111, 0.99); }\\n.cm-s-rubyblue .CodeMirror-gutters { background: #1F4661; border-right: 7px solid #3E7087; }\\n.cm-s-rubyblue .CodeMirror-guttermarker { color: white; }\\n.cm-s-rubyblue .CodeMirror-guttermarker-subtle { color: #3E7087; }\\n.cm-s-rubyblue .CodeMirror-linenumber { color: white; }\\n.cm-s-rubyblue .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-rubyblue span.cm-comment { color: #999; font-style:italic; line-height: 1em; }\\n.cm-s-rubyblue span.cm-atom { color: #F4C20B; }\\n.cm-s-rubyblue span.cm-number, .cm-s-rubyblue span.cm-attribute { color: #82C6E0; }\\n.cm-s-rubyblue span.cm-keyword { color: #F0F; }\\n.cm-s-rubyblue span.cm-string { color: #F08047; }\\n.cm-s-rubyblue span.cm-meta { color: #F0F; }\\n.cm-s-rubyblue span.cm-variable-2, .cm-s-rubyblue span.cm-tag { color: #7BD827; }\\n.cm-s-rubyblue span.cm-variable-3, .cm-s-rubyblue span.cm-def, .cm-s-rubyblue span.cm-type { color: white; }\\n.cm-s-rubyblue span.cm-bracket { color: #F0F; }\\n.cm-s-rubyblue span.cm-link { color: #F4C20B; }\\n.cm-s-rubyblue span.CodeMirror-matchingbracket { color:#F0F !important; }\\n.cm-s-rubyblue span.cm-builtin, .cm-s-rubyblue span.cm-special { color: #FF9D00; }\\n.cm-s-rubyblue span.cm-error { color: #AF2018; }\\n\\n.cm-s-rubyblue .CodeMirror-activeline-background { background: #173047; }\\n\"","export default \"/*\\n\\n    Name:       seti\\n    Author:     Michael Kaminsky (http://github.com/mkaminsky11)\\n\\n    Original seti color scheme by Jesse Weed (https://github.com/jesseweed/seti-syntax)\\n\\n*/\\n\\n\\n.cm-s-seti.CodeMirror {\\n  background-color: #151718 !important;\\n  color: #CFD2D1 !important;\\n  border: none;\\n}\\n.cm-s-seti .CodeMirror-gutters {\\n  color: #404b53;\\n  background-color: #0E1112;\\n  border: none;\\n}\\n.cm-s-seti .CodeMirror-cursor { border-left: solid thin #f8f8f0; }\\n.cm-s-seti .CodeMirror-linenumber { color: #6D8A88; }\\n.cm-s-seti.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-seti .CodeMirror-line::selection, .cm-s-seti .CodeMirror-line > span::selection, .cm-s-seti .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-seti .CodeMirror-line::-moz-selection, .cm-s-seti .CodeMirror-line > span::-moz-selection, .cm-s-seti .CodeMirror-line > span > span::-moz-selection { background: rgba(255, 255, 255, 0.10); }\\n.cm-s-seti span.cm-comment { color: #41535b; }\\n.cm-s-seti span.cm-string, .cm-s-seti span.cm-string-2 { color: #55b5db; }\\n.cm-s-seti span.cm-number { color: #cd3f45; }\\n.cm-s-seti span.cm-variable { color: #55b5db; }\\n.cm-s-seti span.cm-variable-2 { color: #a074c4; }\\n.cm-s-seti span.cm-def { color: #55b5db; }\\n.cm-s-seti span.cm-keyword { color: #ff79c6; }\\n.cm-s-seti span.cm-operator { color: #9fca56; }\\n.cm-s-seti span.cm-keyword { color: #e6cd69; }\\n.cm-s-seti span.cm-atom { color: #cd3f45; }\\n.cm-s-seti span.cm-meta { color: #55b5db; }\\n.cm-s-seti span.cm-tag { color: #55b5db; }\\n.cm-s-seti span.cm-attribute { color: #9fca56; }\\n.cm-s-seti span.cm-qualifier { color: #9fca56; }\\n.cm-s-seti span.cm-property { color: #a074c4; }\\n.cm-s-seti span.cm-variable-3, .cm-s-seti span.cm-type { color: #9fca56; }\\n.cm-s-seti span.cm-builtin { color: #9fca56; }\\n.cm-s-seti .CodeMirror-activeline-background { background: #101213; }\\n.cm-s-seti .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/*\\n\\n    Name:       shadowfox\\n    Author:     overdodactyl (http://github.com/overdodactyl)\\n\\n    Original shadowfox color scheme by Firefox\\n\\n*/\\n\\n.cm-s-shadowfox.CodeMirror { background: #2a2a2e; color: #b1b1b3; }\\n.cm-s-shadowfox div.CodeMirror-selected { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-line::selection, .cm-s-shadowfox .CodeMirror-line > span::selection, .cm-s-shadowfox .CodeMirror-line > span > span::selection { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-line::-moz-selection, .cm-s-shadowfox .CodeMirror-line > span::-moz-selection, .cm-s-shadowfox .CodeMirror-line > span > span::-moz-selection { background: #353B48; }\\n.cm-s-shadowfox .CodeMirror-gutters { background: #0c0c0d ; border-right: 1px solid #0c0c0d; }\\n.cm-s-shadowfox .CodeMirror-guttermarker { color: #555; }\\n.cm-s-shadowfox .CodeMirror-linenumber { color: #939393; }\\n.cm-s-shadowfox .CodeMirror-cursor { border-left: 1px solid #fff; }\\n\\n.cm-s-shadowfox span.cm-comment { color: #939393; }\\n.cm-s-shadowfox span.cm-atom { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-quote { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-builtin { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-attribute { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-keyword { color: #FF7DE9; }\\n.cm-s-shadowfox span.cm-error { color: #FF7DE9; }\\n\\n.cm-s-shadowfox span.cm-number { color: #6B89FF; }\\n.cm-s-shadowfox span.cm-string { color: #6B89FF; }\\n.cm-s-shadowfox span.cm-string-2 { color: #6B89FF; }\\n\\n.cm-s-shadowfox span.cm-meta { color: #939393; }\\n.cm-s-shadowfox span.cm-hr { color: #939393; }\\n\\n.cm-s-shadowfox span.cm-header { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-qualifier { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-variable-2 { color: #75BFFF; }\\n\\n.cm-s-shadowfox span.cm-property { color: #86DE74; }\\n\\n.cm-s-shadowfox span.cm-def { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-bracket { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-tag { color: #75BFFF; }\\n.cm-s-shadowfox span.cm-link:visited { color: #75BFFF; }\\n\\n.cm-s-shadowfox span.cm-variable { color: #B98EFF; }\\n.cm-s-shadowfox span.cm-variable-3 { color: #d7d7db; }\\n.cm-s-shadowfox span.cm-link { color: #737373; }\\n.cm-s-shadowfox span.cm-operator { color: #b1b1b3; }\\n.cm-s-shadowfox span.cm-special { color: #d7d7db; }\\n\\n.cm-s-shadowfox .CodeMirror-activeline-background { background: rgba(185, 215, 253, .15) }\\n.cm-s-shadowfox .CodeMirror-matchingbracket { outline: solid 1px rgba(255, 255, 255, .25); color: white !important; }\\n\"","export default \"/*\\nSolarized theme for code-mirror\\nhttp://ethanschoonover.com/solarized\\n*/\\n\\n/*\\nSolarized color palette\\nhttp://ethanschoonover.com/solarized/img/solarized-palette.png\\n*/\\n\\n.solarized.base03 { color: #002b36; }\\n.solarized.base02 { color: #073642; }\\n.solarized.base01 { color: #586e75; }\\n.solarized.base00 { color: #657b83; }\\n.solarized.base0 { color: #839496; }\\n.solarized.base1 { color: #93a1a1; }\\n.solarized.base2 { color: #eee8d5; }\\n.solarized.base3  { color: #fdf6e3; }\\n.solarized.solar-yellow  { color: #b58900; }\\n.solarized.solar-orange  { color: #cb4b16; }\\n.solarized.solar-red { color: #dc322f; }\\n.solarized.solar-magenta { color: #d33682; }\\n.solarized.solar-violet  { color: #6c71c4; }\\n.solarized.solar-blue { color: #268bd2; }\\n.solarized.solar-cyan { color: #2aa198; }\\n.solarized.solar-green { color: #859900; }\\n\\n/* Color scheme for code-mirror */\\n\\n.cm-s-solarized {\\n  line-height: 1.45em;\\n  color-profile: sRGB;\\n  rendering-intent: auto;\\n}\\n.cm-s-solarized.cm-s-dark {\\n  color: #839496;\\n  background-color: #002b36;\\n  text-shadow: #002b36 0 1px;\\n}\\n.cm-s-solarized.cm-s-light {\\n  background-color: #fdf6e3;\\n  color: #657b83;\\n  text-shadow: #eee8d5 0 1px;\\n}\\n\\n.cm-s-solarized .CodeMirror-widget {\\n  text-shadow: none;\\n}\\n\\n.cm-s-solarized .cm-header { color: #586e75; }\\n.cm-s-solarized .cm-quote { color: #93a1a1; }\\n\\n.cm-s-solarized .cm-keyword { color: #cb4b16; }\\n.cm-s-solarized .cm-atom { color: #d33682; }\\n.cm-s-solarized .cm-number { color: #d33682; }\\n.cm-s-solarized .cm-def { color: #2aa198; }\\n\\n.cm-s-solarized .cm-variable { color: #839496; }\\n.cm-s-solarized .cm-variable-2 { color: #b58900; }\\n.cm-s-solarized .cm-variable-3, .cm-s-solarized .cm-type { color: #6c71c4; }\\n\\n.cm-s-solarized .cm-property { color: #2aa198; }\\n.cm-s-solarized .cm-operator { color: #6c71c4; }\\n\\n.cm-s-solarized .cm-comment { color: #586e75; font-style:italic; }\\n\\n.cm-s-solarized .cm-string { color: #859900; }\\n.cm-s-solarized .cm-string-2 { color: #b58900; }\\n\\n.cm-s-solarized .cm-meta { color: #859900; }\\n.cm-s-solarized .cm-qualifier { color: #b58900; }\\n.cm-s-solarized .cm-builtin { color: #d33682; }\\n.cm-s-solarized .cm-bracket { color: #cb4b16; }\\n.cm-s-solarized .CodeMirror-matchingbracket { color: #859900; }\\n.cm-s-solarized .CodeMirror-nonmatchingbracket { color: #dc322f; }\\n.cm-s-solarized .cm-tag { color: #93a1a1; }\\n.cm-s-solarized .cm-attribute { color: #2aa198; }\\n.cm-s-solarized .cm-hr {\\n  color: transparent;\\n  border-top: 1px solid #586e75;\\n  display: block;\\n}\\n.cm-s-solarized .cm-link { color: #93a1a1; cursor: pointer; }\\n.cm-s-solarized .cm-special { color: #6c71c4; }\\n.cm-s-solarized .cm-em {\\n  color: #999;\\n  text-decoration: underline;\\n  text-decoration-style: dotted;\\n}\\n.cm-s-solarized .cm-error,\\n.cm-s-solarized .cm-invalidchar {\\n  color: #586e75;\\n  border-bottom: 1px dotted #dc322f;\\n}\\n\\n.cm-s-solarized.cm-s-dark div.CodeMirror-selected { background: #073642; }\\n.cm-s-solarized.cm-s-dark.CodeMirror ::selection { background: rgba(7, 54, 66, 0.99); }\\n.cm-s-solarized.cm-s-dark .CodeMirror-line::-moz-selection, .cm-s-dark .CodeMirror-line > span::-moz-selection, .cm-s-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(7, 54, 66, 0.99); }\\n\\n.cm-s-solarized.cm-s-light div.CodeMirror-selected { background: #eee8d5; }\\n.cm-s-solarized.cm-s-light .CodeMirror-line::selection, .cm-s-light .CodeMirror-line > span::selection, .cm-s-light .CodeMirror-line > span > span::selection { background: #eee8d5; }\\n.cm-s-solarized.cm-s-light .CodeMirror-line::-moz-selection, .cm-s-ligh .CodeMirror-line > span::-moz-selection, .cm-s-ligh .CodeMirror-line > span > span::-moz-selection { background: #eee8d5; }\\n\\n/* Editor styling */\\n\\n\\n\\n/* Little shadow on the view-port of the buffer view */\\n.cm-s-solarized.CodeMirror {\\n  -moz-box-shadow: inset 7px 0 12px -6px #000;\\n  -webkit-box-shadow: inset 7px 0 12px -6px #000;\\n  box-shadow: inset 7px 0 12px -6px #000;\\n}\\n\\n/* Remove gutter border */\\n.cm-s-solarized .CodeMirror-gutters {\\n  border-right: 0;\\n}\\n\\n/* Gutter colors and line number styling based of color scheme (dark / light) */\\n\\n/* Dark */\\n.cm-s-solarized.cm-s-dark .CodeMirror-gutters {\\n  background-color: #073642;\\n}\\n\\n.cm-s-solarized.cm-s-dark .CodeMirror-linenumber {\\n  color: #586e75;\\n  text-shadow: #021014 0 -1px;\\n}\\n\\n/* Light */\\n.cm-s-solarized.cm-s-light .CodeMirror-gutters {\\n  background-color: #eee8d5;\\n}\\n\\n.cm-s-solarized.cm-s-light .CodeMirror-linenumber {\\n  color: #839496;\\n}\\n\\n/* Common */\\n.cm-s-solarized .CodeMirror-linenumber {\\n  padding: 0 5px;\\n}\\n.cm-s-solarized .CodeMirror-guttermarker-subtle { color: #586e75; }\\n.cm-s-solarized.cm-s-dark .CodeMirror-guttermarker { color: #ddd; }\\n.cm-s-solarized.cm-s-light .CodeMirror-guttermarker { color: #cb4b16; }\\n\\n.cm-s-solarized .CodeMirror-gutter .CodeMirror-gutter-text {\\n  color: #586e75;\\n}\\n\\n/* Cursor */\\n.cm-s-solarized .CodeMirror-cursor { border-left: 1px solid #819090; }\\n\\n/* Fat cursor */\\n.cm-s-solarized.cm-s-light.cm-fat-cursor .CodeMirror-cursor { background: #77ee77; }\\n.cm-s-solarized.cm-s-light .cm-animate-fat-cursor { background-color: #77ee77; }\\n.cm-s-solarized.cm-s-dark.cm-fat-cursor .CodeMirror-cursor { background: #586e75; }\\n.cm-s-solarized.cm-s-dark .cm-animate-fat-cursor { background-color: #586e75; }\\n\\n/* Active line */\\n.cm-s-solarized.cm-s-dark .CodeMirror-activeline-background {\\n  background: rgba(255, 255, 255, 0.06);\\n}\\n.cm-s-solarized.cm-s-light .CodeMirror-activeline-background {\\n  background: rgba(0, 0, 0, 0.06);\\n}\\n\"","export default \".cm-s-ssms span.cm-keyword { color: blue; }\\n.cm-s-ssms span.cm-comment { color: darkgreen; }\\n.cm-s-ssms span.cm-string { color: red; }\\n.cm-s-ssms span.cm-def { color: black; }\\n.cm-s-ssms span.cm-variable { color: black; }\\n.cm-s-ssms span.cm-variable-2 { color: black; }\\n.cm-s-ssms span.cm-atom { color: darkgray; }\\n.cm-s-ssms .CodeMirror-linenumber { color: teal; }\\n.cm-s-ssms .CodeMirror-activeline-background { background: #ffffff; }\\n.cm-s-ssms span.cm-string-2 { color: #FF00FF; }\\n.cm-s-ssms span.cm-operator, \\n.cm-s-ssms span.cm-bracket, \\n.cm-s-ssms span.cm-punctuation { color: darkgray; }\\n.cm-s-ssms .CodeMirror-gutters { border-right: 3px solid #ffee62; background-color: #ffffff; }\\n.cm-s-ssms div.CodeMirror-selected { background: #ADD6FF; }\\n\\n\"","export default \".cm-s-the-matrix.CodeMirror { background: #000000; color: #00FF00; }\\n.cm-s-the-matrix div.CodeMirror-selected { background: #2D2D2D; }\\n.cm-s-the-matrix .CodeMirror-line::selection, .cm-s-the-matrix .CodeMirror-line > span::selection, .cm-s-the-matrix .CodeMirror-line > span > span::selection { background: rgba(45, 45, 45, 0.99); }\\n.cm-s-the-matrix .CodeMirror-line::-moz-selection, .cm-s-the-matrix .CodeMirror-line > span::-moz-selection, .cm-s-the-matrix .CodeMirror-line > span > span::-moz-selection { background: rgba(45, 45, 45, 0.99); }\\n.cm-s-the-matrix .CodeMirror-gutters { background: #060; border-right: 2px solid #00FF00; }\\n.cm-s-the-matrix .CodeMirror-guttermarker { color: #0f0; }\\n.cm-s-the-matrix .CodeMirror-guttermarker-subtle { color: white; }\\n.cm-s-the-matrix .CodeMirror-linenumber { color: #FFFFFF; }\\n.cm-s-the-matrix .CodeMirror-cursor { border-left: 1px solid #00FF00; }\\n\\n.cm-s-the-matrix span.cm-keyword { color: #008803; font-weight: bold; }\\n.cm-s-the-matrix span.cm-atom { color: #3FF; }\\n.cm-s-the-matrix span.cm-number { color: #FFB94F; }\\n.cm-s-the-matrix span.cm-def { color: #99C; }\\n.cm-s-the-matrix span.cm-variable { color: #F6C; }\\n.cm-s-the-matrix span.cm-variable-2 { color: #C6F; }\\n.cm-s-the-matrix span.cm-variable-3, .cm-s-the-matrix span.cm-type { color: #96F; }\\n.cm-s-the-matrix span.cm-property { color: #62FFA0; }\\n.cm-s-the-matrix span.cm-operator { color: #999; }\\n.cm-s-the-matrix span.cm-comment { color: #CCCCCC; }\\n.cm-s-the-matrix span.cm-string { color: #39C; }\\n.cm-s-the-matrix span.cm-meta { color: #C9F; }\\n.cm-s-the-matrix span.cm-qualifier { color: #FFF700; }\\n.cm-s-the-matrix span.cm-builtin { color: #30a; }\\n.cm-s-the-matrix span.cm-bracket { color: #cc7; }\\n.cm-s-the-matrix span.cm-tag { color: #FFBD40; }\\n.cm-s-the-matrix span.cm-attribute { color: #FFF700; }\\n.cm-s-the-matrix span.cm-error { color: #FF0000; }\\n\\n.cm-s-the-matrix .CodeMirror-activeline-background { background: #040; }\\n\"","export default \"/*\\n\\n    Name:       Tomorrow Night - Bright\\n    Author:     Chris Kempson\\n\\n    Port done by Gerard Braad <me@gbraad.nl>\\n\\n*/\\n\\n.cm-s-tomorrow-night-bright.CodeMirror { background: #000000; color: #eaeaea; }\\n.cm-s-tomorrow-night-bright div.CodeMirror-selected { background: #424242; }\\n.cm-s-tomorrow-night-bright .CodeMirror-gutters { background: #000000; border-right: 0px; }\\n.cm-s-tomorrow-night-bright .CodeMirror-guttermarker { color: #e78c45; }\\n.cm-s-tomorrow-night-bright .CodeMirror-guttermarker-subtle { color: #777; }\\n.cm-s-tomorrow-night-bright .CodeMirror-linenumber { color: #424242; }\\n.cm-s-tomorrow-night-bright .CodeMirror-cursor { border-left: 1px solid #6A6A6A; }\\n\\n.cm-s-tomorrow-night-bright span.cm-comment { color: #d27b53; }\\n.cm-s-tomorrow-night-bright span.cm-atom { color: #a16a94; }\\n.cm-s-tomorrow-night-bright span.cm-number { color: #a16a94; }\\n\\n.cm-s-tomorrow-night-bright span.cm-property, .cm-s-tomorrow-night-bright span.cm-attribute { color: #99cc99; }\\n.cm-s-tomorrow-night-bright span.cm-keyword { color: #d54e53; }\\n.cm-s-tomorrow-night-bright span.cm-string { color: #e7c547; }\\n\\n.cm-s-tomorrow-night-bright span.cm-variable { color: #b9ca4a; }\\n.cm-s-tomorrow-night-bright span.cm-variable-2 { color: #7aa6da; }\\n.cm-s-tomorrow-night-bright span.cm-def { color: #e78c45; }\\n.cm-s-tomorrow-night-bright span.cm-bracket { color: #eaeaea; }\\n.cm-s-tomorrow-night-bright span.cm-tag { color: #d54e53; }\\n.cm-s-tomorrow-night-bright span.cm-link { color: #a16a94; }\\n.cm-s-tomorrow-night-bright span.cm-error { background: #d54e53; color: #6A6A6A; }\\n\\n.cm-s-tomorrow-night-bright .CodeMirror-activeline-background { background: #2a2a2a; }\\n.cm-s-tomorrow-night-bright .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \"/*\\n\\n    Name:       Tomorrow Night - Eighties\\n    Author:     Chris Kempson\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-tomorrow-night-eighties.CodeMirror { background: #000000; color: #CCCCCC; }\\n.cm-s-tomorrow-night-eighties div.CodeMirror-selected { background: #2D2D2D; }\\n.cm-s-tomorrow-night-eighties .CodeMirror-line::selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span::selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span > span::selection { background: rgba(45, 45, 45, 0.99); }\\n.cm-s-tomorrow-night-eighties .CodeMirror-line::-moz-selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span::-moz-selection, .cm-s-tomorrow-night-eighties .CodeMirror-line > span > span::-moz-selection { background: rgba(45, 45, 45, 0.99); }\\n.cm-s-tomorrow-night-eighties .CodeMirror-gutters { background: #000000; border-right: 0px; }\\n.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker { color: #f2777a; }\\n.cm-s-tomorrow-night-eighties .CodeMirror-guttermarker-subtle { color: #777; }\\n.cm-s-tomorrow-night-eighties .CodeMirror-linenumber { color: #515151; }\\n.cm-s-tomorrow-night-eighties .CodeMirror-cursor { border-left: 1px solid #6A6A6A; }\\n\\n.cm-s-tomorrow-night-eighties span.cm-comment { color: #d27b53; }\\n.cm-s-tomorrow-night-eighties span.cm-atom { color: #a16a94; }\\n.cm-s-tomorrow-night-eighties span.cm-number { color: #a16a94; }\\n\\n.cm-s-tomorrow-night-eighties span.cm-property, .cm-s-tomorrow-night-eighties span.cm-attribute { color: #99cc99; }\\n.cm-s-tomorrow-night-eighties span.cm-keyword { color: #f2777a; }\\n.cm-s-tomorrow-night-eighties span.cm-string { color: #ffcc66; }\\n\\n.cm-s-tomorrow-night-eighties span.cm-variable { color: #99cc99; }\\n.cm-s-tomorrow-night-eighties span.cm-variable-2 { color: #6699cc; }\\n.cm-s-tomorrow-night-eighties span.cm-def { color: #f99157; }\\n.cm-s-tomorrow-night-eighties span.cm-bracket { color: #CCCCCC; }\\n.cm-s-tomorrow-night-eighties span.cm-tag { color: #f2777a; }\\n.cm-s-tomorrow-night-eighties span.cm-link { color: #a16a94; }\\n.cm-s-tomorrow-night-eighties span.cm-error { background: #f2777a; color: #6A6A6A; }\\n\\n.cm-s-tomorrow-night-eighties .CodeMirror-activeline-background { background: #343600; }\\n.cm-s-tomorrow-night-eighties .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\n\"","export default \".cm-s-ttcn .cm-quote { color: #090; }\\n.cm-s-ttcn .cm-negative { color: #d44; }\\n.cm-s-ttcn .cm-positive { color: #292; }\\n.cm-s-ttcn .cm-header, .cm-strong { font-weight: bold; }\\n.cm-s-ttcn .cm-em { font-style: italic; }\\n.cm-s-ttcn .cm-link { text-decoration: underline; }\\n.cm-s-ttcn .cm-strikethrough { text-decoration: line-through; }\\n.cm-s-ttcn .cm-header { color: #00f; font-weight: bold; }\\n\\n.cm-s-ttcn .cm-atom { color: #219; }\\n.cm-s-ttcn .cm-attribute { color: #00c; }\\n.cm-s-ttcn .cm-bracket { color: #997; }\\n.cm-s-ttcn .cm-comment { color: #333333; }\\n.cm-s-ttcn .cm-def { color: #00f; }\\n.cm-s-ttcn .cm-em { font-style: italic; }\\n.cm-s-ttcn .cm-error { color: #f00; }\\n.cm-s-ttcn .cm-hr { color: #999; }\\n.cm-s-ttcn .cm-invalidchar { color: #f00; }\\n.cm-s-ttcn .cm-keyword { font-weight:bold; }\\n.cm-s-ttcn .cm-link { color: #00c; text-decoration: underline; }\\n.cm-s-ttcn .cm-meta { color: #555; }\\n.cm-s-ttcn .cm-negative { color: #d44; }\\n.cm-s-ttcn .cm-positive { color: #292; }\\n.cm-s-ttcn .cm-qualifier { color: #555; }\\n.cm-s-ttcn .cm-strikethrough { text-decoration: line-through; }\\n.cm-s-ttcn .cm-string { color: #006400; }\\n.cm-s-ttcn .cm-string-2 { color: #f50; }\\n.cm-s-ttcn .cm-strong { font-weight: bold; }\\n.cm-s-ttcn .cm-tag { color: #170; }\\n.cm-s-ttcn .cm-variable { color: #8B2252; }\\n.cm-s-ttcn .cm-variable-2 { color: #05a; }\\n.cm-s-ttcn .cm-variable-3, .cm-s-ttcn .cm-type { color: #085; }\\n\\n.cm-s-ttcn .cm-invalidchar { color: #f00; }\\n\\n/* ASN */\\n.cm-s-ttcn .cm-accessTypes,\\n.cm-s-ttcn .cm-compareTypes { color: #27408B; }\\n.cm-s-ttcn .cm-cmipVerbs { color: #8B2252; }\\n.cm-s-ttcn .cm-modifier { color:#D2691E; }\\n.cm-s-ttcn .cm-status { color:#8B4545; }\\n.cm-s-ttcn .cm-storage { color:#A020F0; }\\n.cm-s-ttcn .cm-tags { color:#006400; }\\n\\n/* CFG */\\n.cm-s-ttcn .cm-externalCommands { color: #8B4545; font-weight:bold; }\\n.cm-s-ttcn .cm-fileNCtrlMaskOptions,\\n.cm-s-ttcn .cm-sectionTitle { color: #2E8B57; font-weight:bold; }\\n\\n/* TTCN */\\n.cm-s-ttcn .cm-booleanConsts,\\n.cm-s-ttcn .cm-otherConsts,\\n.cm-s-ttcn .cm-verdictConsts { color: #006400; }\\n.cm-s-ttcn .cm-configOps,\\n.cm-s-ttcn .cm-functionOps,\\n.cm-s-ttcn .cm-portOps,\\n.cm-s-ttcn .cm-sutOps,\\n.cm-s-ttcn .cm-timerOps,\\n.cm-s-ttcn .cm-verdictOps { color: #0000FF; }\\n.cm-s-ttcn .cm-preprocessor,\\n.cm-s-ttcn .cm-templateMatch,\\n.cm-s-ttcn .cm-ttcn3Macros { color: #27408B; }\\n.cm-s-ttcn .cm-types { color: #A52A2A; font-weight:bold; }\\n.cm-s-ttcn .cm-visibilityModifiers { font-weight:bold; }\\n\"","export default \".cm-s-twilight.CodeMirror { background: #141414; color: #f7f7f7; } /**/\\n.cm-s-twilight div.CodeMirror-selected { background: #323232; } /**/\\n.cm-s-twilight .CodeMirror-line::selection, .cm-s-twilight .CodeMirror-line > span::selection, .cm-s-twilight .CodeMirror-line > span > span::selection { background: rgba(50, 50, 50, 0.99); }\\n.cm-s-twilight .CodeMirror-line::-moz-selection, .cm-s-twilight .CodeMirror-line > span::-moz-selection, .cm-s-twilight .CodeMirror-line > span > span::-moz-selection { background: rgba(50, 50, 50, 0.99); }\\n\\n.cm-s-twilight .CodeMirror-gutters { background: #222; border-right: 1px solid #aaa; }\\n.cm-s-twilight .CodeMirror-guttermarker { color: white; }\\n.cm-s-twilight .CodeMirror-guttermarker-subtle { color: #aaa; }\\n.cm-s-twilight .CodeMirror-linenumber { color: #aaa; }\\n.cm-s-twilight .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-twilight .cm-keyword { color: #f9ee98; } /**/\\n.cm-s-twilight .cm-atom { color: #FC0; }\\n.cm-s-twilight .cm-number { color:  #ca7841; } /**/\\n.cm-s-twilight .cm-def { color: #8DA6CE; }\\n.cm-s-twilight span.cm-variable-2, .cm-s-twilight span.cm-tag { color: #607392; } /**/\\n.cm-s-twilight span.cm-variable-3, .cm-s-twilight span.cm-def, .cm-s-twilight span.cm-type { color: #607392; } /**/\\n.cm-s-twilight .cm-operator { color: #cda869; } /**/\\n.cm-s-twilight .cm-comment { color:#777; font-style:italic; font-weight:normal; } /**/\\n.cm-s-twilight .cm-string { color:#8f9d6a; font-style:italic; } /**/\\n.cm-s-twilight .cm-string-2 { color:#bd6b18; } /*?*/\\n.cm-s-twilight .cm-meta { background-color:#141414; color:#f7f7f7; } /*?*/\\n.cm-s-twilight .cm-builtin { color: #cda869; } /*?*/\\n.cm-s-twilight .cm-tag { color: #997643; } /**/\\n.cm-s-twilight .cm-attribute { color: #d6bb6d; } /*?*/\\n.cm-s-twilight .cm-header { color: #FF6400; }\\n.cm-s-twilight .cm-hr { color: #AEAEAE; }\\n.cm-s-twilight .cm-link { color:#ad9361; font-style:italic; text-decoration:none; } /**/\\n.cm-s-twilight .cm-error { border-bottom: 1px solid red; }\\n\\n.cm-s-twilight .CodeMirror-activeline-background { background: #27282E; }\\n.cm-s-twilight .CodeMirror-matchingbracket { outline:1px solid grey; color:white !important; }\\n\"","export default \"/* Taken from the popular Visual Studio Vibrant Ink Schema */\\n\\n.cm-s-vibrant-ink.CodeMirror { background: black; color: white; }\\n.cm-s-vibrant-ink div.CodeMirror-selected { background: #35493c; }\\n.cm-s-vibrant-ink .CodeMirror-line::selection, .cm-s-vibrant-ink .CodeMirror-line > span::selection, .cm-s-vibrant-ink .CodeMirror-line > span > span::selection { background: rgba(53, 73, 60, 0.99); }\\n.cm-s-vibrant-ink .CodeMirror-line::-moz-selection, .cm-s-vibrant-ink .CodeMirror-line > span::-moz-selection, .cm-s-vibrant-ink .CodeMirror-line > span > span::-moz-selection { background: rgba(53, 73, 60, 0.99); }\\n\\n.cm-s-vibrant-ink .CodeMirror-gutters { background: #002240; border-right: 1px solid #aaa; }\\n.cm-s-vibrant-ink .CodeMirror-guttermarker { color: white; }\\n.cm-s-vibrant-ink .CodeMirror-guttermarker-subtle { color: #d0d0d0; }\\n.cm-s-vibrant-ink .CodeMirror-linenumber { color: #d0d0d0; }\\n.cm-s-vibrant-ink .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-vibrant-ink .cm-keyword { color: #CC7832; }\\n.cm-s-vibrant-ink .cm-atom { color: #FC0; }\\n.cm-s-vibrant-ink .cm-number { color:  #FFEE98; }\\n.cm-s-vibrant-ink .cm-def { color: #8DA6CE; }\\n.cm-s-vibrant-ink span.cm-variable-2, .cm-s-vibrant span.cm-tag { color: #FFC66D; }\\n.cm-s-vibrant-ink span.cm-variable-3, .cm-s-vibrant span.cm-def, .cm-s-vibrant span.cm-type { color: #FFC66D; }\\n.cm-s-vibrant-ink .cm-operator { color: #888; }\\n.cm-s-vibrant-ink .cm-comment { color: gray; font-weight: bold; }\\n.cm-s-vibrant-ink .cm-string { color:  #A5C25C; }\\n.cm-s-vibrant-ink .cm-string-2 { color: red; }\\n.cm-s-vibrant-ink .cm-meta { color: #D8FA3C; }\\n.cm-s-vibrant-ink .cm-builtin { color: #8DA6CE; }\\n.cm-s-vibrant-ink .cm-tag { color: #8DA6CE; }\\n.cm-s-vibrant-ink .cm-attribute { color: #8DA6CE; }\\n.cm-s-vibrant-ink .cm-header { color: #FF6400; }\\n.cm-s-vibrant-ink .cm-hr { color: #AEAEAE; }\\n.cm-s-vibrant-ink .cm-link { color: #5656F3; }\\n.cm-s-vibrant-ink .cm-error { border-bottom: 1px solid red; }\\n\\n.cm-s-vibrant-ink .CodeMirror-activeline-background { background: #27282E; }\\n.cm-s-vibrant-ink .CodeMirror-matchingbracket { outline:1px solid grey; color:white !important; }\\n\"","export default \"/*\\nCopyright (C) 2011 by MarkLogic Corporation\\nAuthor: Mike Brevoort <mike@brevoort.com>\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n*/\\n.cm-s-xq-dark.CodeMirror { background: #0a001f; color: #f8f8f8; }\\n.cm-s-xq-dark div.CodeMirror-selected { background: #27007A; }\\n.cm-s-xq-dark .CodeMirror-line::selection, .cm-s-xq-dark .CodeMirror-line > span::selection, .cm-s-xq-dark .CodeMirror-line > span > span::selection { background: rgba(39, 0, 122, 0.99); }\\n.cm-s-xq-dark .CodeMirror-line::-moz-selection, .cm-s-xq-dark .CodeMirror-line > span::-moz-selection, .cm-s-xq-dark .CodeMirror-line > span > span::-moz-selection { background: rgba(39, 0, 122, 0.99); }\\n.cm-s-xq-dark .CodeMirror-gutters { background: #0a001f; border-right: 1px solid #aaa; }\\n.cm-s-xq-dark .CodeMirror-guttermarker { color: #FFBD40; }\\n.cm-s-xq-dark .CodeMirror-guttermarker-subtle { color: #f8f8f8; }\\n.cm-s-xq-dark .CodeMirror-linenumber { color: #f8f8f8; }\\n.cm-s-xq-dark .CodeMirror-cursor { border-left: 1px solid white; }\\n\\n.cm-s-xq-dark span.cm-keyword { color: #FFBD40; }\\n.cm-s-xq-dark span.cm-atom { color: #6C8CD5; }\\n.cm-s-xq-dark span.cm-number { color: #164; }\\n.cm-s-xq-dark span.cm-def { color: #FFF; text-decoration:underline; }\\n.cm-s-xq-dark span.cm-variable { color: #FFF; }\\n.cm-s-xq-dark span.cm-variable-2 { color: #EEE; }\\n.cm-s-xq-dark span.cm-variable-3, .cm-s-xq-dark span.cm-type { color: #DDD; }\\n.cm-s-xq-dark span.cm-property {}\\n.cm-s-xq-dark span.cm-operator {}\\n.cm-s-xq-dark span.cm-comment { color: gray; }\\n.cm-s-xq-dark span.cm-string { color: #9FEE00; }\\n.cm-s-xq-dark span.cm-meta { color: yellow; }\\n.cm-s-xq-dark span.cm-qualifier { color: #FFF700; }\\n.cm-s-xq-dark span.cm-builtin { color: #30a; }\\n.cm-s-xq-dark span.cm-bracket { color: #cc7; }\\n.cm-s-xq-dark span.cm-tag { color: #FFBD40; }\\n.cm-s-xq-dark span.cm-attribute { color: #FFF700; }\\n.cm-s-xq-dark span.cm-error { color: #f00; }\\n\\n.cm-s-xq-dark .CodeMirror-activeline-background { background: #27282E; }\\n.cm-s-xq-dark .CodeMirror-matchingbracket { outline:1px solid grey; color:white !important; }\\n\"","export default \"/*\\nCopyright (C) 2011 by MarkLogic Corporation\\nAuthor: Mike Brevoort <mike@brevoort.com>\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in\\nall copies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\nTHE SOFTWARE.\\n*/\\n.cm-s-xq-light span.cm-keyword { line-height: 1em; font-weight: bold; color: #5A5CAD; }\\n.cm-s-xq-light span.cm-atom { color: #6C8CD5; }\\n.cm-s-xq-light span.cm-number { color: #164; }\\n.cm-s-xq-light span.cm-def { text-decoration:underline; }\\n.cm-s-xq-light span.cm-variable { color: black; }\\n.cm-s-xq-light span.cm-variable-2 { color:black; }\\n.cm-s-xq-light span.cm-variable-3, .cm-s-xq-light span.cm-type { color: black; }\\n.cm-s-xq-light span.cm-property {}\\n.cm-s-xq-light span.cm-operator {}\\n.cm-s-xq-light span.cm-comment { color: #0080FF; font-style: italic; }\\n.cm-s-xq-light span.cm-string { color: red; }\\n.cm-s-xq-light span.cm-meta { color: yellow; }\\n.cm-s-xq-light span.cm-qualifier { color: grey; }\\n.cm-s-xq-light span.cm-builtin { color: #7EA656; }\\n.cm-s-xq-light span.cm-bracket { color: #cc7; }\\n.cm-s-xq-light span.cm-tag { color: #3F7F7F; }\\n.cm-s-xq-light span.cm-attribute { color: #7F007F; }\\n.cm-s-xq-light span.cm-error { color: #f00; }\\n\\n.cm-s-xq-light .CodeMirror-activeline-background { background: #e8f2ff; }\\n.cm-s-xq-light .CodeMirror-matchingbracket { outline:1px solid grey;color:black !important;background:yellow; }\\n\"","export default \"/*\\n\\n    Name:       yeti\\n    Author:     Michael Kaminsky (http://github.com/mkaminsky11)\\n\\n    Original yeti color scheme by Jesse Weed (https://github.com/jesseweed/yeti-syntax)\\n\\n*/\\n\\n\\n.cm-s-yeti.CodeMirror {\\n  background-color: #ECEAE8 !important;\\n  color: #d1c9c0 !important;\\n  border: none;\\n}\\n\\n.cm-s-yeti .CodeMirror-gutters {\\n  color: #adaba6;\\n  background-color: #E5E1DB;\\n  border: none;\\n}\\n.cm-s-yeti .CodeMirror-cursor { border-left: solid thin #d1c9c0; }\\n.cm-s-yeti .CodeMirror-linenumber { color: #adaba6; }\\n.cm-s-yeti.CodeMirror-focused div.CodeMirror-selected { background: #DCD8D2; }\\n.cm-s-yeti .CodeMirror-line::selection, .cm-s-yeti .CodeMirror-line > span::selection, .cm-s-yeti .CodeMirror-line > span > span::selection { background: #DCD8D2; }\\n.cm-s-yeti .CodeMirror-line::-moz-selection, .cm-s-yeti .CodeMirror-line > span::-moz-selection, .cm-s-yeti .CodeMirror-line > span > span::-moz-selection { background: #DCD8D2; }\\n.cm-s-yeti span.cm-comment { color: #d4c8be; }\\n.cm-s-yeti span.cm-string, .cm-s-yeti span.cm-string-2 { color: #96c0d8; }\\n.cm-s-yeti span.cm-number { color: #a074c4; }\\n.cm-s-yeti span.cm-variable { color: #55b5db; }\\n.cm-s-yeti span.cm-variable-2 { color: #a074c4; }\\n.cm-s-yeti span.cm-def { color: #55b5db; }\\n.cm-s-yeti span.cm-operator { color: #9fb96e; }\\n.cm-s-yeti span.cm-keyword { color: #9fb96e; }\\n.cm-s-yeti span.cm-atom { color: #a074c4; }\\n.cm-s-yeti span.cm-meta { color: #96c0d8; }\\n.cm-s-yeti span.cm-tag { color: #96c0d8; }\\n.cm-s-yeti span.cm-attribute { color: #9fb96e; }\\n.cm-s-yeti span.cm-qualifier { color: #96c0d8; }\\n.cm-s-yeti span.cm-property { color: #a074c4; }\\n.cm-s-yeti span.cm-builtin { color: #a074c4; }\\n.cm-s-yeti span.cm-variable-3, .cm-s-yeti span.cm-type { color: #96c0d8; }\\n.cm-s-yeti .CodeMirror-activeline-background { background: #E7E4E0; }\\n.cm-s-yeti .CodeMirror-matchingbracket { text-decoration: underline; }\\n\"","export default \"/*\\n\\n    Name:       yonc\\n    Author:     Thomas MacLean (http://github.com/thomasmaclean)\\n\\n    Original yonc color scheme by Mina Markham (https://github.com/minamarkham)\\n\\n*/\\n\\n.cm-s-yonce.CodeMirror { background: #1C1C1C; color: #d4d4d4; } /**/\\n.cm-s-yonce div.CodeMirror-selected { background: rgba(252, 69, 133, 0.478); } /**/\\n.cm-s-yonce .CodeMirror-selectedtext,\\n.cm-s-yonce .CodeMirror-selected,\\n.cm-s-yonce .CodeMirror-line::selection,\\n.cm-s-yonce .CodeMirror-line > span::selection,\\n.cm-s-yonce .CodeMirror-line > span > span::selection,\\n.cm-s-yonce .CodeMirror-line::-moz-selection,\\n.cm-s-yonce .CodeMirror-line > span::-moz-selection,\\n.cm-s-yonce .CodeMirror-line > span > span::-moz-selection { background: rgba(252, 67, 132, 0.47); }\\n\\n.cm-s-yonce.CodeMirror pre { padding-left: 0px; }\\n.cm-s-yonce .CodeMirror-gutters {background: #1C1C1C; border-right: 0px;}\\n.cm-s-yonce .CodeMirror-linenumber {color: #777777;  padding-right: 10px; }\\n.cm-s-yonce .CodeMirror-activeline .CodeMirror-linenumber.CodeMirror-gutter-elt { background: #1C1C1C; color: #fc4384; }\\n.cm-s-yonce .CodeMirror-linenumber { color: #777; }\\n.cm-s-yonce .CodeMirror-cursor { border-left: 2px solid #FC4384; }\\n.cm-s-yonce .cm-searching { background: rgb(243, 155, 53, .3) !important; outline: 1px solid #F39B35; }\\n.cm-s-yonce .cm-searching.CodeMirror-selectedtext { background: rgb(243, 155, 53, .7) !important; color: white; }\\n\\n.cm-s-yonce .cm-keyword { color: #00A7AA; } /**/\\n.cm-s-yonce .cm-atom { color: #F39B35; }\\n.cm-s-yonce .cm-number, .cm-s-yonce span.cm-type { color:  #A06FCA; } /**/\\n.cm-s-yonce .cm-def { color: #98E342; }\\n.cm-s-yonce .cm-property,\\n.cm-s-yonce span.cm-variable { color: #D4D4D4; font-style: italic; }\\n.cm-s-yonce span.cm-variable-2 { color: #da7dae; font-style: italic; }\\n.cm-s-yonce span.cm-variable-3 { color: #A06FCA; }\\n.cm-s-yonce .cm-type.cm-def { color: #FC4384; font-style: normal; text-decoration: underline; }\\n.cm-s-yonce .cm-property.cm-def { color: #FC4384; font-style: normal; }\\n.cm-s-yonce .cm-callee { color: #FC4384; font-style: normal; }\\n.cm-s-yonce .cm-operator { color: #FC4384; } /**/\\n.cm-s-yonce .cm-qualifier,\\n.cm-s-yonce .cm-tag { color: #FC4384; }\\n.cm-s-yonce .cm-tag.cm-bracket { color: #D4D4D4; }\\n.cm-s-yonce .cm-attribute { color: #A06FCA; }\\n.cm-s-yonce .cm-comment { color:#696d70; font-style:italic; font-weight:normal; } /**/\\n.cm-s-yonce .cm-comment.cm-tag { color: #FC4384 }\\n.cm-s-yonce .cm-comment.cm-attribute { color: #D4D4D4; }\\n.cm-s-yonce .cm-string { color:#E6DB74; } /**/\\n.cm-s-yonce .cm-string-2 { color:#F39B35; } /*?*/\\n.cm-s-yonce .cm-meta { color: #D4D4D4; background: inherit; }\\n.cm-s-yonce .cm-builtin { color: #FC4384; } /*?*/\\n.cm-s-yonce .cm-header { color: #da7dae; }\\n.cm-s-yonce .cm-hr { color: #98E342; }\\n.cm-s-yonce .cm-link { color:#696d70; font-style:italic; text-decoration:none; } /**/\\n.cm-s-yonce .cm-error { border-bottom: 1px solid #C42412; }\\n\\n.cm-s-yonce .CodeMirror-activeline-background { background: #272727; }\\n.cm-s-yonce .CodeMirror-matchingbracket { outline:1px solid grey; color:#D4D4D4 !important; }\\n\"","export default \"/**\\n * \\\"\\n *  Using Zenburn color palette from the Emacs Zenburn Theme\\n *  https://github.com/bbatsov/zenburn-emacs/blob/master/zenburn-theme.el\\n *\\n *  Also using parts of https://github.com/xavi/coderay-lighttable-theme\\n * \\\"\\n * From: https://github.com/wisenomad/zenburn-lighttable-theme/blob/master/zenburn.css\\n */\\n\\n.cm-s-zenburn .CodeMirror-gutters { background: #3f3f3f !important; }\\n.cm-s-zenburn .CodeMirror-foldgutter-open, .CodeMirror-foldgutter-folded { color: #999; }\\n.cm-s-zenburn .CodeMirror-cursor { border-left: 1px solid white; }\\n.cm-s-zenburn { background-color: #3f3f3f; color: #dcdccc; }\\n.cm-s-zenburn span.cm-builtin { color: #dcdccc; font-weight: bold; }\\n.cm-s-zenburn span.cm-comment { color: #7f9f7f; }\\n.cm-s-zenburn span.cm-keyword { color: #f0dfaf; font-weight: bold; }\\n.cm-s-zenburn span.cm-atom { color: #bfebbf; }\\n.cm-s-zenburn span.cm-def { color: #dcdccc; }\\n.cm-s-zenburn span.cm-variable { color: #dfaf8f; }\\n.cm-s-zenburn span.cm-variable-2 { color: #dcdccc; }\\n.cm-s-zenburn span.cm-string { color: #cc9393; }\\n.cm-s-zenburn span.cm-string-2 { color: #cc9393; }\\n.cm-s-zenburn span.cm-number { color: #dcdccc; }\\n.cm-s-zenburn span.cm-tag { color: #93e0e3; }\\n.cm-s-zenburn span.cm-property { color: #dfaf8f; }\\n.cm-s-zenburn span.cm-attribute { color: #dfaf8f; }\\n.cm-s-zenburn span.cm-qualifier { color: #7cb8bb; }\\n.cm-s-zenburn span.cm-meta { color: #f0dfaf; }\\n.cm-s-zenburn span.cm-header { color: #f0efd0; }\\n.cm-s-zenburn span.cm-operator { color: #f0efd0; }\\n.cm-s-zenburn span.CodeMirror-matchingbracket { box-sizing: border-box; background: transparent; border-bottom: 1px solid; }\\n.cm-s-zenburn span.CodeMirror-nonmatchingbracket { border-bottom: 1px solid; background: none; }\\n.cm-s-zenburn .CodeMirror-activeline { background: #000000; }\\n.cm-s-zenburn .CodeMirror-activeline-background { background: #000000; }\\n.cm-s-zenburn div.CodeMirror-selected { background: #545454; }\\n.cm-s-zenburn .CodeMirror-focused div.CodeMirror-selected { background: #4f4f4f; }\\n\"","export default \"function __inject_style(src) {\\n    var script = document.constructor.prototype.createElement.call(document, 'style');\\n    script.innerHTML = src;\\n    document.documentElement.appendChild(script);\\n}\\nvar cm_bindings = (function () {\\n    function cm_bindings(mapName, addKeyMap, styleName, styleCSS, vim_disable_keys, disable_keys) {\\n        this.loaded_styles = [];\\n        this.queue = [];\\n        this.mirrors = [];\\n        this.set_style(styleName, styleCSS);\\n        this.set_keymap(mapName, addKeyMap);\\n        this.vim_disable_keys = vim_disable_keys;\\n        this.disable_keys = disable_keys;\\n        this.find_and_inject();\\n        setInterval(this.find_and_inject.bind(this), 500);\\n    }\\n    cm_bindings.prototype.find_and_inject = function () {\\n        var _this = this;\\n        document\\n            .querySelectorAll('.CodeMirror:not([__cm-instance])')\\n            .forEach(function (el) {\\n            el.setAttribute('__cm-instance', '');\\n            _this.queue.push(el);\\n        });\\n        var _loop_1 = function (i) {\\n            var el = this_1.queue[i];\\n            if (el['CodeMirror']) {\\n                var cm_1 = el['CodeMirror'];\\n                this_1.disable_keys.forEach(function (key) {\\n                    delete cm_1.constructor['keyMap'].emacsy[key];\\n                });\\n                cm_1.constructor['vim_disable_keys'] = this_1.vim_disable_keys;\\n                this_1.inject_bindings(cm_1);\\n                var _data = { cm: cm_1, theme: cm_1.options.theme };\\n                this_1.inject_style(_data);\\n                this_1.mirrors.push(_data);\\n                this_1.queue.splice(i, 1);\\n                i--;\\n            }\\n            out_i_1 = i;\\n        };\\n        var this_1 = this, out_i_1;\\n        for (var i = 0; i < this.queue.length; i++) {\\n            _loop_1(i);\\n            i = out_i_1;\\n        }\\n    };\\n    cm_bindings.prototype.inject_style = function (cm_data) {\\n        if (this.styleName === 'default') {\\n            console.log('injecting default syle: ' + cm_data.theme);\\n            cm_data.cm.setOption('theme', cm_data.theme);\\n            console.log('injecting default syle');\\n        }\\n        else {\\n            console.log('injecting default syle: ' + this.styleName);\\n            cm_data.cm.setOption('theme', this.styleName);\\n        }\\n    };\\n    cm_bindings.prototype.inject_bindings = function (cm) {\\n        if (!cm.constructor[this.mapName]) {\\n            console.log('about to add KeyMap');\\n            this.addKeyMap(cm.constructor);\\n            console.log('KeyMap added');\\n        }\\n        console.log('about to set options');\\n        try {\\n            cm.setOption('keyMap', this.mapName);\\n        }\\n        catch (e) {\\n            console.log('got error: ', e);\\n        }\\n        console.log('options set');\\n    };\\n    cm_bindings.prototype.set_keymap = function (mapName, addKeyMap) {\\n        var _this = this;\\n        this.mapName = mapName;\\n        this.addKeyMap = addKeyMap;\\n        this.mirrors.map(function (cm_data) { return _this.inject_bindings(cm_data.cm); });\\n    };\\n    cm_bindings.prototype.set_style = function (styleName, styleCSS) {\\n        var _this = this;\\n        if (styleName !== 'default' &&\\n            this.loaded_styles.indexOf(styleName) === -1) {\\n            console.log('injecting CSS: ', styleCSS);\\n            __inject_style(styleCSS);\\n            this.loaded_styles.push(styleName);\\n        }\\n        this.styleName = styleName;\\n        this.mirrors.map(function (cm_data) { return _this.inject_style(cm_data); });\\n    };\\n    return cm_bindings;\\n}());\\n;\\n(function (__mapName, __addKeyMap, __styleName, __styleCSS, __vim_disable_keys, __default_disable_keys) {\\n    window.__cm_global_config = new cm_bindings(__mapName, __addKeyMap, __styleName, __styleCSS, __vim_disable_keys, __default_disable_keys);\\n})(__mapName, __addKeyMap, __styleName, __styleCSS, __vim_disable_keys, __default_disable_keys);\\n//# sourceMappingURL=page.js.map\"","export default \"// CodeMirror, copyright (c) by Marijn Haverbeke and others\\n// Distributed under an MIT license: https://codemirror.net/LICENSE\\n\\n/**\\n * Supported keybindings:\\n *   Too many to list. Refer to defaultKeymap below.\\n *\\n * Supported Ex commands:\\n *   Refer to defaultExCommandMap below.\\n *\\n * Registers: unnamed, -, a-z, A-Z, 0-9\\n *   (Does not respect the special case for number registers when delete\\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\\n *   TODO: Implement the remaining registers.\\n *\\n * Marks: a-z, A-Z, and 0-9\\n *   TODO: Implement the remaining special marks. They have more complex\\n *       behavior.\\n *\\n * Events:\\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\\n *                      Event object: {mode: \\\"visual\\\", subMode: \\\"linewise\\\"}\\n *\\n * Code structure:\\n *  1. Default keymap\\n *  2. Variable declarations and short basic helpers\\n *  3. Instance (External API) implementation\\n *  4. Internal state tracking objects (input state, counter) implementation\\n *     and instantiation\\n *  5. Key handler (the main command dispatcher) implementation\\n *  6. Motion, operator, and action implementations\\n *  7. Helper functions for the key handler, motions, operators, and actions\\n *  8. Set up Vim to work as a keymap for CodeMirror.\\n *  9. Ex command implementations.\\n */\\n\\n//-- (function(mod) {\\n//--   if (typeof exports == \\\"object\\\" && typeof module == \\\"object\\\") // CommonJS\\n//--     mod(require(\\\"../lib/codemirror\\\"), require(\\\"../addon/search/searchcursor\\\"), require(\\\"../addon/dialog/dialog\\\"), require(\\\"../addon/edit/matchbrackets.js\\\"));\\n//--   else if (typeof define == \\\"function\\\" && define.amd) // AMD\\n//--     define([\\\"../lib/codemirror\\\", \\\"../addon/search/searchcursor\\\", \\\"../addon/dialog/dialog\\\", \\\"../addon/edit/matchbrackets\\\"], mod);\\n//--   else // Plain browser env\\n//--     mod(CodeMirror);\\n//-- })(\\n\\nfunction inject_map(CodeMirror) {\\n  'use strict';\\n\\n  var defaultKeymap = [\\n    // Key to key mapping. This goes first to make it possible to override\\n    // existing mappings.\\n    { keys: '<Left>', type: 'keyToKey', toKeys: 'h' },\\n    { keys: '<Right>', type: 'keyToKey', toKeys: 'l' },\\n    { keys: '<Up>', type: 'keyToKey', toKeys: 'k' },\\n    { keys: '<Down>', type: 'keyToKey', toKeys: 'j' },\\n    { keys: '<Space>', type: 'keyToKey', toKeys: 'l' },\\n    { keys: '<BS>', type: 'keyToKey', toKeys: 'h', context: 'normal'},\\n    { keys: '<Del>', type: 'keyToKey', toKeys: 'x', context: 'normal'},\\n    { keys: '<C-Space>', type: 'keyToKey', toKeys: 'W' },\\n    { keys: '<C-BS>', type: 'keyToKey', toKeys: 'B', context: 'normal' },\\n    { keys: '<S-Space>', type: 'keyToKey', toKeys: 'w' },\\n    { keys: '<S-BS>', type: 'keyToKey', toKeys: 'b', context: 'normal' },\\n    { keys: '<C-n>', type: 'keyToKey', toKeys: 'j' },\\n    { keys: '<C-p>', type: 'keyToKey', toKeys: 'k' },\\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>' },\\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>' },\\n    { keys: '<C-[>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\\n    { keys: '<C-c>', type: 'keyToKey', toKeys: '<Esc>', context: 'insert' },\\n    { keys: 's', type: 'keyToKey', toKeys: 'cl', context: 'normal' },\\n    { keys: 's', type: 'keyToKey', toKeys: 'c', context: 'visual'},\\n    { keys: 'S', type: 'keyToKey', toKeys: 'cc', context: 'normal' },\\n    { keys: 'S', type: 'keyToKey', toKeys: 'VdO', context: 'visual' },\\n    { keys: '<Home>', type: 'keyToKey', toKeys: '0' },\\n    { keys: '<End>', type: 'keyToKey', toKeys: '$' },\\n    { keys: '<PageUp>', type: 'keyToKey', toKeys: '<C-b>' },\\n    { keys: '<PageDown>', type: 'keyToKey', toKeys: '<C-f>' },\\n    { keys: '<CR>', type: 'keyToKey', toKeys: 'j^', context: 'normal' },\\n    { keys: '<Ins>', type: 'action', action: 'toggleOverwrite', context: 'insert' },\\n    // Motions\\n    { keys: 'H', type: 'motion', motion: 'moveToTopLine', motionArgs: { linewise: true, toJumplist: true }},\\n    { keys: 'M', type: 'motion', motion: 'moveToMiddleLine', motionArgs: { linewise: true, toJumplist: true }},\\n    { keys: 'L', type: 'motion', motion: 'moveToBottomLine', motionArgs: { linewise: true, toJumplist: true }},\\n    { keys: 'h', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: false }},\\n    { keys: 'l', type: 'motion', motion: 'moveByCharacters', motionArgs: { forward: true }},\\n    { keys: 'j', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, linewise: true }},\\n    { keys: 'k', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, linewise: true }},\\n    { keys: 'gj', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: true }},\\n    { keys: 'gk', type: 'motion', motion: 'moveByDisplayLines', motionArgs: { forward: false }},\\n    { keys: 'w', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false }},\\n    { keys: 'W', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: false, bigWord: true }},\\n    { keys: 'e', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, inclusive: true }},\\n    { keys: 'E', type: 'motion', motion: 'moveByWords', motionArgs: { forward: true, wordEnd: true, bigWord: true, inclusive: true }},\\n    { keys: 'b', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }},\\n    { keys: 'B', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false, bigWord: true }},\\n    { keys: 'ge', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, inclusive: true }},\\n    { keys: 'gE', type: 'motion', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: true, bigWord: true, inclusive: true }},\\n    { keys: '{', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: false, toJumplist: true }},\\n    { keys: '}', type: 'motion', motion: 'moveByParagraph', motionArgs: { forward: true, toJumplist: true }},\\n    { keys: '(', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: false }},\\n    { keys: ')', type: 'motion', motion: 'moveBySentence', motionArgs: { forward: true }},\\n    { keys: '<C-f>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: true }},\\n    { keys: '<C-b>', type: 'motion', motion: 'moveByPage', motionArgs: { forward: false }},\\n    { keys: '<C-d>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: true, explicitRepeat: true }},\\n    { keys: '<C-u>', type: 'motion', motion: 'moveByScroll', motionArgs: { forward: false, explicitRepeat: true }},\\n    { keys: 'gg', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: false, explicitRepeat: true, linewise: true, toJumplist: true }},\\n    { keys: 'G', type: 'motion', motion: 'moveToLineOrEdgeOfDocument', motionArgs: { forward: true, explicitRepeat: true, linewise: true, toJumplist: true }},\\n    { keys: '0', type: 'motion', motion: 'moveToStartOfLine' },\\n    { keys: '^', type: 'motion', motion: 'moveToFirstNonWhiteSpaceCharacter' },\\n    { keys: '+', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true }},\\n    { keys: '-', type: 'motion', motion: 'moveByLines', motionArgs: { forward: false, toFirstChar:true }},\\n    { keys: '_', type: 'motion', motion: 'moveByLines', motionArgs: { forward: true, toFirstChar:true, repeatOffset:-1 }},\\n    { keys: '$', type: 'motion', motion: 'moveToEol', motionArgs: { inclusive: true }},\\n    { keys: '%', type: 'motion', motion: 'moveToMatchedSymbol', motionArgs: { inclusive: true, toJumplist: true }},\\n    { keys: 'f<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: true , inclusive: true }},\\n    { keys: 'F<character>', type: 'motion', motion: 'moveToCharacter', motionArgs: { forward: false }},\\n    { keys: 't<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: true, inclusive: true }},\\n    { keys: 'T<character>', type: 'motion', motion: 'moveTillCharacter', motionArgs: { forward: false }},\\n    { keys: ';', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: true }},\\n    { keys: ',', type: 'motion', motion: 'repeatLastCharacterSearch', motionArgs: { forward: false }},\\n    { keys: '\\\\'<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true, linewise: true}},\\n    { keys: '`<character>', type: 'motion', motion: 'goToMark', motionArgs: {toJumplist: true}},\\n    { keys: ']`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true } },\\n    { keys: '[`', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false } },\\n    { keys: ']\\\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: true, linewise: true } },\\n    { keys: '[\\\\'', type: 'motion', motion: 'jumpToMark', motionArgs: { forward: false, linewise: true } },\\n    // the next two aren't motions but must come before more general motion declarations\\n    { keys: ']p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true, matchIndent: true}},\\n    { keys: '[p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true, matchIndent: true}},\\n    { keys: ']<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: true, toJumplist: true}},\\n    { keys: '[<character>', type: 'motion', motion: 'moveToSymbol', motionArgs: { forward: false, toJumplist: true}},\\n    { keys: '|', type: 'motion', motion: 'moveToColumn'},\\n    { keys: 'o', type: 'motion', motion: 'moveToOtherHighlightedEnd', context:'visual'},\\n    { keys: 'O', type: 'motion', motion: 'moveToOtherHighlightedEnd', motionArgs: {sameLine: true}, context:'visual'},\\n    // Operators\\n    { keys: 'd', type: 'operator', operator: 'delete' },\\n    { keys: 'y', type: 'operator', operator: 'yank' },\\n    { keys: 'c', type: 'operator', operator: 'change' },\\n    { keys: '=', type: 'operator', operator: 'indentAuto' },\\n    { keys: '>', type: 'operator', operator: 'indent', operatorArgs: { indentRight: true }},\\n    { keys: '<', type: 'operator', operator: 'indent', operatorArgs: { indentRight: false }},\\n    { keys: 'g~', type: 'operator', operator: 'changeCase' },\\n    { keys: 'gu', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, isEdit: true },\\n    { keys: 'gU', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, isEdit: true },\\n    { keys: 'n', type: 'motion', motion: 'findNext', motionArgs: { forward: true, toJumplist: true }},\\n    { keys: 'N', type: 'motion', motion: 'findNext', motionArgs: { forward: false, toJumplist: true }},\\n    // Operator-Motion dual commands\\n    { keys: 'x', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorMotionArgs: { visualLine: false }},\\n    { keys: 'X', type: 'operatorMotion', operator: 'delete', motion: 'moveByCharacters', motionArgs: { forward: false }, operatorMotionArgs: { visualLine: true }},\\n    { keys: 'D', type: 'operatorMotion', operator: 'delete', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\\n    { keys: 'D', type: 'operator', operator: 'delete', operatorArgs: { linewise: true }, context: 'visual'},\\n    { keys: 'Y', type: 'operatorMotion', operator: 'yank', motion: 'expandToLine', motionArgs: { linewise: true }, context: 'normal'},\\n    { keys: 'Y', type: 'operator', operator: 'yank', operatorArgs: { linewise: true }, context: 'visual'},\\n    { keys: 'C', type: 'operatorMotion', operator: 'change', motion: 'moveToEol', motionArgs: { inclusive: true }, context: 'normal'},\\n    { keys: 'C', type: 'operator', operator: 'change', operatorArgs: { linewise: true }, context: 'visual'},\\n    { keys: '~', type: 'operatorMotion', operator: 'changeCase', motion: 'moveByCharacters', motionArgs: { forward: true }, operatorArgs: { shouldMoveCursor: true }, context: 'normal'},\\n    { keys: '~', type: 'operator', operator: 'changeCase', context: 'visual'},\\n    { keys: '<C-w>', type: 'operatorMotion', operator: 'delete', motion: 'moveByWords', motionArgs: { forward: false, wordEnd: false }, context: 'insert' },\\n    //ignore C-w in normal mode\\n    { keys: '<C-w>', type: 'idle', context: 'normal' },\\n    // Actions\\n    { keys: '<C-i>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: true }},\\n    { keys: '<C-o>', type: 'action', action: 'jumpListWalk', actionArgs: { forward: false }},\\n    { keys: '<C-e>', type: 'action', action: 'scroll', actionArgs: { forward: true, linewise: true }},\\n    { keys: '<C-y>', type: 'action', action: 'scroll', actionArgs: { forward: false, linewise: true }},\\n    { keys: 'a', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'charAfter' }, context: 'normal' },\\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'eol' }, context: 'normal' },\\n    { keys: 'A', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'endOfSelectedArea' }, context: 'visual' },\\n    { keys: 'i', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'inplace' }, context: 'normal' },\\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'firstNonBlank'}, context: 'normal' },\\n    { keys: 'I', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { insertAt: 'startOfSelectedArea' }, context: 'visual' },\\n    { keys: 'o', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: true }, context: 'normal' },\\n    { keys: 'O', type: 'action', action: 'newLineAndEnterInsertMode', isEdit: true, interlaceInsertRepeat: true, actionArgs: { after: false }, context: 'normal' },\\n    { keys: 'v', type: 'action', action: 'toggleVisualMode' },\\n    { keys: 'V', type: 'action', action: 'toggleVisualMode', actionArgs: { linewise: true }},\\n    { keys: '<C-v>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\\n    { keys: '<C-q>', type: 'action', action: 'toggleVisualMode', actionArgs: { blockwise: true }},\\n    { keys: 'gv', type: 'action', action: 'reselectLastSelection' },\\n    { keys: 'J', type: 'action', action: 'joinLines', isEdit: true },\\n    { keys: 'p', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: true, isEdit: true }},\\n    { keys: 'P', type: 'action', action: 'paste', isEdit: true, actionArgs: { after: false, isEdit: true }},\\n    { keys: 'r<character>', type: 'action', action: 'replace', isEdit: true },\\n    { keys: '@<character>', type: 'action', action: 'replayMacro' },\\n    { keys: 'q<character>', type: 'action', action: 'enterMacroRecordMode' },\\n    // Handle Replace-mode as a special case of insert mode.\\n    { keys: 'R', type: 'action', action: 'enterInsertMode', isEdit: true, actionArgs: { replace: true }},\\n    { keys: 'u', type: 'action', action: 'undo', context: 'normal' },\\n    { keys: 'u', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: true}, context: 'visual', isEdit: true },\\n    { keys: 'U', type: 'operator', operator: 'changeCase', operatorArgs: {toLower: false}, context: 'visual', isEdit: true },\\n    { keys: '<C-r>', type: 'action', action: 'redo' },\\n    { keys: 'm<character>', type: 'action', action: 'setMark' },\\n    { keys: '\\\"<character>', type: 'action', action: 'setRegister' },\\n    { keys: 'zz', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }},\\n    { keys: 'z.', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'center' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\\n    { keys: 'zt', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }},\\n    { keys: 'z<CR>', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'top' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\\n    { keys: 'z-', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }},\\n    { keys: 'zb', type: 'action', action: 'scrollToCursor', actionArgs: { position: 'bottom' }, motion: 'moveToFirstNonWhiteSpaceCharacter' },\\n    { keys: '.', type: 'action', action: 'repeatLastEdit' },\\n    { keys: '<C-a>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: true, backtrack: false}},\\n    { keys: '<C-x>', type: 'action', action: 'incrementNumberToken', isEdit: true, actionArgs: {increase: false, backtrack: false}},\\n    { keys: '<C-t>', type: 'action', action: 'indent', actionArgs: { indentRight: true }, context: 'insert' },\\n    { keys: '<C-d>', type: 'action', action: 'indent', actionArgs: { indentRight: false }, context: 'insert' },\\n    // Text object motions\\n    { keys: 'a<character>', type: 'motion', motion: 'textObjectManipulation' },\\n    { keys: 'i<character>', type: 'motion', motion: 'textObjectManipulation', motionArgs: { textObjectInner: true }},\\n    // Search\\n    { keys: '/', type: 'search', searchArgs: { forward: true, querySrc: 'prompt', toJumplist: true }},\\n    { keys: '?', type: 'search', searchArgs: { forward: false, querySrc: 'prompt', toJumplist: true }},\\n    { keys: '*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\\n    { keys: '#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', wholeWordOnly: true, toJumplist: true }},\\n    { keys: 'g*', type: 'search', searchArgs: { forward: true, querySrc: 'wordUnderCursor', toJumplist: true }},\\n    { keys: 'g#', type: 'search', searchArgs: { forward: false, querySrc: 'wordUnderCursor', toJumplist: true }},\\n    // Ex command\\n    { keys: ':', type: 'ex' }\\n  ];\\n\\n\\n    console.log(\\\"CodeMirror.vim_disable_keys: \\\", CodeMirror.vim_disable_keys)\\n    if(CodeMirror.vim_disable_keys){\\n        console.log(\\\"from: \\\" + defaultKeymap.length)\\n        defaultKeymap = defaultKeymap.filter(km => CodeMirror.vim_disable_keys.indexOf(km.keys) === -1)\\n        console.log(\\\"to: \\\" + defaultKeymap.length)\\n    }\\n\\n  var defaultKeymapLength = defaultKeymap.length;\\n\\n  /**\\n   * Ex commands\\n   * Care must be taken when adding to the default Ex command map. For any\\n   * pair of commands that have a shared prefix, at least one of their\\n   * shortNames must not match the prefix of the other command.\\n   */\\n  var defaultExCommandMap = [\\n    { name: 'colorscheme', shortName: 'colo' },\\n    { name: 'map' },\\n    { name: 'imap', shortName: 'im' },\\n    { name: 'nmap', shortName: 'nm' },\\n    { name: 'vmap', shortName: 'vm' },\\n    { name: 'unmap' },\\n    { name: 'write', shortName: 'w' },\\n    { name: 'undo', shortName: 'u' },\\n    { name: 'redo', shortName: 'red' },\\n    { name: 'set', shortName: 'se' },\\n    { name: 'set', shortName: 'se' },\\n    { name: 'setlocal', shortName: 'setl' },\\n    { name: 'setglobal', shortName: 'setg' },\\n    { name: 'sort', shortName: 'sor' },\\n    { name: 'substitute', shortName: 's', possiblyAsync: true },\\n    { name: 'nohlsearch', shortName: 'noh' },\\n    { name: 'yank', shortName: 'y' },\\n    { name: 'delmarks', shortName: 'delm' },\\n    { name: 'registers', shortName: 'reg', excludeFromCommandHistory: true },\\n    { name: 'global', shortName: 'g' }\\n  ];\\n\\n  var Pos = CodeMirror.Pos;\\n\\n  var Vim = function() {\\n    function enterVimMode(cm) {\\n      cm.setOption('disableInput', true);\\n      cm.setOption('showCursorWhenSelecting', false);\\n      CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"normal\\\"});\\n      cm.on('cursorActivity', onCursorActivity);\\n      maybeInitVimState(cm);\\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\\n    }\\n\\n    function leaveVimMode(cm) {\\n      cm.setOption('disableInput', false);\\n      cm.off('cursorActivity', onCursorActivity);\\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\\n      cm.state.vim = null;\\n    }\\n\\n    function detachVimMap(cm, next) {\\n      if (this == CodeMirror.keyMap.vim) {\\n        CodeMirror.rmClass(cm.getWrapperElement(), \\\"cm-fat-cursor\\\");\\n        if (cm.getOption(\\\"inputStyle\\\") == \\\"contenteditable\\\" && document.body.style.caretColor != null) {\\n          disableFatCursorMark(cm);\\n          cm.getInputField().style.caretColor = \\\"\\\";\\n        }\\n      }\\n\\n      if (!next || next.attach != attachVimMap)\\n        leaveVimMode(cm);\\n    }\\n    function attachVimMap(cm, prev) {\\n      if (this == CodeMirror.keyMap.vim) {\\n        CodeMirror.addClass(cm.getWrapperElement(), \\\"cm-fat-cursor\\\");\\n        if (cm.getOption(\\\"inputStyle\\\") == \\\"contenteditable\\\" && document.body.style.caretColor != null) {\\n          enableFatCursorMark(cm);\\n          cm.getInputField().style.caretColor = \\\"transparent\\\";\\n        }\\n      }\\n\\n      if (!prev || prev.attach != attachVimMap)\\n        enterVimMode(cm);\\n    }\\n\\n    function fatCursorMarks(cm) {\\n      var ranges = cm.listSelections(), result = []\\n      for (var i = 0; i < ranges.length; i++) {\\n        var range = ranges[i]\\n        if (range.empty()) {\\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1),\\n                                    {className: \\\"cm-fat-cursor-mark\\\"}))\\n          } else {\\n            var widget = document.createElement(\\\"span\\\")\\n            widget.textContent = \\\"\\\\u00a0\\\"\\n            widget.className = \\\"cm-fat-cursor-mark\\\"\\n            result.push(cm.setBookmark(range.anchor, {widget: widget}))\\n          }\\n        }\\n      }\\n      return result\\n    }\\n\\n    function updateFatCursorMark(cm) {\\n      var marks = cm.state.fatCursorMarks\\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear()\\n      cm.state.fatCursorMarks = fatCursorMarks(cm)\\n    }\\n\\n    function enableFatCursorMark(cm) {\\n      cm.state.fatCursorMarks = fatCursorMarks(cm)\\n      cm.on(\\\"cursorActivity\\\", updateFatCursorMark)\\n    }\\n\\n    function disableFatCursorMark(cm) {\\n      var marks = cm.state.fatCursorMarks\\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear()\\n      cm.state.fatCursorMarks = null\\n      cm.off(\\\"cursorActivity\\\", updateFatCursorMark)\\n    }\\n\\n    // Deprecated, simply setting the keymap works again.\\n    CodeMirror.defineOption('vimMode', false, function(cm, val, prev) {\\n      if (val && cm.getOption(\\\"keyMap\\\") != \\\"vim\\\")\\n        cm.setOption(\\\"keyMap\\\", \\\"vim\\\");\\n      else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\\\"keyMap\\\")))\\n        cm.setOption(\\\"keyMap\\\", \\\"default\\\");\\n    });\\n\\n    function cmKey(key, cm) {\\n      if (!cm) { return undefined; }\\n      if (this[key]) { return this[key]; }\\n      var vimKey = cmKeyToVimKey(key);\\n      if (!vimKey) {\\n        return false;\\n      }\\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\\n      if (typeof cmd == 'function') {\\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\\n      }\\n      return cmd;\\n    }\\n\\n    var modifiers = {'Shift': 'S', 'Ctrl': 'C', 'Alt': 'A', 'Cmd': 'D', 'Mod': 'A'};\\n    var specialKeys = {Enter:'CR',Backspace:'BS',Delete:'Del',Insert:'Ins'};\\n    function cmKeyToVimKey(key) {\\n      if (key.charAt(0) == '\\\\'') {\\n        // Keypress character binding of format \\\"'a'\\\"\\n        return key.charAt(1);\\n      }\\n      var pieces = key.split(/-(?!$)/);\\n      var lastPiece = pieces[pieces.length - 1];\\n      if (pieces.length == 1 && pieces[0].length == 1) {\\n        // No-modifier bindings use literal character bindings above. Skip.\\n        return false;\\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\\n        // Ignore Shift+char bindings as they should be handled by literal character.\\n        return false;\\n      }\\n      var hasCharacter = false;\\n      for (var i = 0; i < pieces.length; i++) {\\n        var piece = pieces[i];\\n        if (piece in modifiers) { pieces[i] = modifiers[piece]; }\\n        else { hasCharacter = true; }\\n        if (piece in specialKeys) { pieces[i] = specialKeys[piece]; }\\n      }\\n      if (!hasCharacter) {\\n        // Vim does not support modifier only keys.\\n        return false;\\n      }\\n      // TODO: Current bindings expect the character to be lower case, but\\n      // it looks like vim key notation uses upper case.\\n      if (isUpperCase(lastPiece)) {\\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\\n      }\\n      return '<' + pieces.join('-') + '>';\\n    }\\n\\n    function getOnPasteFn(cm) {\\n      var vim = cm.state.vim;\\n      if (!vim.onPasteFn) {\\n        vim.onPasteFn = function() {\\n          if (!vim.insertMode) {\\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\\n            actions.enterInsertMode(cm, {}, vim);\\n          }\\n        };\\n      }\\n      return vim.onPasteFn;\\n    }\\n\\n    var numberRegex = /[\\\\d]/;\\n    var wordCharTest = [CodeMirror.isWordChar, function(ch) {\\n      return ch && !CodeMirror.isWordChar(ch) && !/\\\\s/.test(ch);\\n    }], bigWordCharTest = [function(ch) {\\n      return /\\\\S/.test(ch);\\n    }];\\n    function makeKeyRange(start, size) {\\n      var keys = [];\\n      for (var i = start; i < start + size; i++) {\\n        keys.push(String.fromCharCode(i));\\n      }\\n      return keys;\\n    }\\n    var upperCaseAlphabet = makeKeyRange(65, 26);\\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\\n    var numbers = makeKeyRange(48, 10);\\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\\\"', '.', ':', '/']);\\n\\n    function isLine(cm, line) {\\n      return line >= cm.firstLine() && line <= cm.lastLine();\\n    }\\n    function isLowerCase(k) {\\n      return (/^[a-z]$/).test(k);\\n    }\\n    function isMatchableSymbol(k) {\\n      return '()[]{}'.indexOf(k) != -1;\\n    }\\n    function isNumber(k) {\\n      return numberRegex.test(k);\\n    }\\n    function isUpperCase(k) {\\n      return (/^[A-Z]$/).test(k);\\n    }\\n    function isWhiteSpaceString(k) {\\n      return (/^\\\\s*$/).test(k);\\n    }\\n    function isEndOfSentenceSymbol(k) {\\n      return '.?!'.indexOf(k) != -1;\\n    }\\n    function inArray(val, arr) {\\n      for (var i = 0; i < arr.length; i++) {\\n        if (arr[i] == val) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n\\n    var options = {};\\n    function defineOption(name, defaultValue, type, aliases, callback) {\\n      if (defaultValue === undefined && !callback) {\\n        throw Error('defaultValue is required unless callback is provided');\\n      }\\n      if (!type) { type = 'string'; }\\n      options[name] = {\\n        type: type,\\n        defaultValue: defaultValue,\\n        callback: callback\\n      };\\n      if (aliases) {\\n        for (var i = 0; i < aliases.length; i++) {\\n          options[aliases[i]] = options[name];\\n        }\\n      }\\n      if (defaultValue) {\\n        setOption(name, defaultValue);\\n      }\\n    }\\n\\n    function setOption(name, value, cm, cfg) {\\n      var option = options[name];\\n      cfg = cfg || {};\\n      var scope = cfg.scope;\\n      if (!option) {\\n        return new Error('Unknown option: ' + name);\\n      }\\n      if (option.type == 'boolean') {\\n        if (value && value !== true) {\\n          return new Error('Invalid argument: ' + name + '=' + value);\\n        } else if (value !== false) {\\n          // Boolean options are set to true if value is not defined.\\n          value = true;\\n        }\\n      }\\n      if (option.callback) {\\n        if (scope !== 'local') {\\n          option.callback(value, undefined);\\n        }\\n        if (scope !== 'global' && cm) {\\n          option.callback(value, cm);\\n        }\\n      } else {\\n        if (scope !== 'local') {\\n          option.value = option.type == 'boolean' ? !!value : value;\\n        }\\n        if (scope !== 'global' && cm) {\\n          cm.state.vim.options[name] = {value: value};\\n        }\\n      }\\n    }\\n\\n    function getOption(name, cm, cfg) {\\n      var option = options[name];\\n      cfg = cfg || {};\\n      var scope = cfg.scope;\\n      if (!option) {\\n        return new Error('Unknown option: ' + name);\\n      }\\n      if (option.callback) {\\n        var local = cm && option.callback(undefined, cm);\\n        if (scope !== 'global' && local !== undefined) {\\n          return local;\\n        }\\n        if (scope !== 'local') {\\n          return option.callback();\\n        }\\n        return;\\n      } else {\\n        var local = (scope !== 'global') && (cm && cm.state.vim.options[name]);\\n        return (local || (scope !== 'local') && option || {}).value;\\n      }\\n    }\\n\\n    defineOption('filetype', undefined, 'string', ['ft'], function(name, cm) {\\n      // Option is local. Do nothing for global.\\n      if (cm === undefined) {\\n        return;\\n      }\\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\\n      if (name === undefined) {\\n        var mode = cm.getOption('mode');\\n        return mode == 'null' ? '' : mode;\\n      } else {\\n        var mode = name == '' ? 'null' : name;\\n        cm.setOption('mode', mode);\\n      }\\n    });\\n\\n    var createCircularJumpList = function() {\\n      var size = 100;\\n      var pointer = -1;\\n      var head = 0;\\n      var tail = 0;\\n      var buffer = new Array(size);\\n      function add(cm, oldCur, newCur) {\\n        var current = pointer % size;\\n        var curMark = buffer[current];\\n        function useNextSlot(cursor) {\\n          var next = ++pointer % size;\\n          var trashMark = buffer[next];\\n          if (trashMark) {\\n            trashMark.clear();\\n          }\\n          buffer[next] = cm.setBookmark(cursor);\\n        }\\n        if (curMark) {\\n          var markPos = curMark.find();\\n          // avoid recording redundant cursor position\\n          if (markPos && !cursorEqual(markPos, oldCur)) {\\n            useNextSlot(oldCur);\\n          }\\n        } else {\\n          useNextSlot(oldCur);\\n        }\\n        useNextSlot(newCur);\\n        head = pointer;\\n        tail = pointer - size + 1;\\n        if (tail < 0) {\\n          tail = 0;\\n        }\\n      }\\n      function move(cm, offset) {\\n        pointer += offset;\\n        if (pointer > head) {\\n          pointer = head;\\n        } else if (pointer < tail) {\\n          pointer = tail;\\n        }\\n        var mark = buffer[(size + pointer) % size];\\n        // skip marks that are temporarily removed from text buffer\\n        if (mark && !mark.find()) {\\n          var inc = offset > 0 ? 1 : -1;\\n          var newCur;\\n          var oldCur = cm.getCursor();\\n          do {\\n            pointer += inc;\\n            mark = buffer[(size + pointer) % size];\\n            // skip marks that are the same as current position\\n            if (mark &&\\n                (newCur = mark.find()) &&\\n                !cursorEqual(oldCur, newCur)) {\\n              break;\\n            }\\n          } while (pointer < head && pointer > tail);\\n        }\\n        return mark;\\n      }\\n      return {\\n        cachedCursor: undefined, //used for # and * jumps\\n        add: add,\\n        move: move\\n      };\\n    };\\n\\n    // Returns an object to track the changes associated insert mode.  It\\n    // clones the object that is passed in, or creates an empty object one if\\n    // none is provided.\\n    var createInsertModeChanges = function(c) {\\n      if (c) {\\n        // Copy construction\\n        return {\\n          changes: c.changes,\\n          expectCursorActivityForChange: c.expectCursorActivityForChange\\n        };\\n      }\\n      return {\\n        // Change list\\n        changes: [],\\n        // Set to true on change, false on cursorActivity.\\n        expectCursorActivityForChange: false\\n      };\\n    };\\n\\n    function MacroModeState() {\\n      this.latestRegister = undefined;\\n      this.isPlaying = false;\\n      this.isRecording = false;\\n      this.replaySearchQueries = [];\\n      this.onRecordingDone = undefined;\\n      this.lastInsertModeChanges = createInsertModeChanges();\\n    }\\n    MacroModeState.prototype = {\\n      exitMacroRecordMode: function() {\\n        var macroModeState = vimGlobalState.macroModeState;\\n        if (macroModeState.onRecordingDone) {\\n          macroModeState.onRecordingDone(); // close dialog\\n        }\\n        macroModeState.onRecordingDone = undefined;\\n        macroModeState.isRecording = false;\\n      },\\n      enterMacroRecordMode: function(cm, registerName) {\\n        var register =\\n            vimGlobalState.registerController.getRegister(registerName);\\n        if (register) {\\n          register.clear();\\n          this.latestRegister = registerName;\\n          if (cm.openDialog) {\\n            this.onRecordingDone = cm.openDialog(\\n                '(recording)['+registerName+']', null, {bottom:true});\\n          }\\n          this.isRecording = true;\\n        }\\n      }\\n    };\\n\\n    function maybeInitVimState(cm) {\\n      if (!cm.state.vim) {\\n        // Store instance state in the CodeMirror object.\\n        cm.state.vim = {\\n          inputState: new InputState(),\\n          // Vim's input state that triggered the last edit, used to repeat\\n          // motions and operators with '.'.\\n          lastEditInputState: undefined,\\n          // Vim's action command before the last edit, used to repeat actions\\n          // with '.' and insert mode repeat.\\n          lastEditActionCommand: undefined,\\n          // When using jk for navigation, if you move from a longer line to a\\n          // shorter line, the cursor may clip to the end of the shorter line.\\n          // If j is pressed again and cursor goes to the next line, the\\n          // cursor should go back to its horizontal position on the longer\\n          // line if it can. This is to keep track of the horizontal position.\\n          lastHPos: -1,\\n          // Doing the same with screen-position for gj/gk\\n          lastHSPos: -1,\\n          // The last motion command run. Cleared if a non-motion command gets\\n          // executed in between.\\n          lastMotion: null,\\n          marks: {},\\n          // Mark for rendering fake cursor for visual mode.\\n          fakeCursor: null,\\n          insertMode: false,\\n          // Repeat count for changes made in insert mode, triggered by key\\n          // sequences like 3,i. Only exists when insertMode is true.\\n          insertModeRepeat: undefined,\\n          visualMode: false,\\n          // If we are in visual line mode. No effect if visualMode is false.\\n          visualLine: false,\\n          visualBlock: false,\\n          lastSelection: null,\\n          lastPastedText: null,\\n          sel: {},\\n          // Buffer-local/window-local values of vim options.\\n          options: {}\\n        };\\n      }\\n      return cm.state.vim;\\n    }\\n    var vimGlobalState;\\n    function resetVimGlobalState() {\\n      vimGlobalState = {\\n        // The current search query.\\n        searchQuery: null,\\n        // Whether we are searching backwards.\\n        searchIsReversed: false,\\n        // Replace part of the last substituted pattern\\n        lastSubstituteReplacePart: undefined,\\n        jumpList: createCircularJumpList(),\\n        macroModeState: new MacroModeState,\\n        // Recording latest f, t, F or T motion command.\\n        lastCharacterSearch: {increment:0, forward:true, selectedCharacter:''},\\n        registerController: new RegisterController({}),\\n        // search history buffer\\n        searchHistoryController: new HistoryController(),\\n        // ex Command history buffer\\n        exCommandHistoryController : new HistoryController()\\n      };\\n      for (var optionName in options) {\\n        var option = options[optionName];\\n        option.value = option.defaultValue;\\n      }\\n    }\\n\\n    var lastInsertModeKeyTimer;\\n    var vimApi= {\\n      buildKeyMap: function() {\\n        // TODO: Convert keymap into dictionary format for fast lookup.\\n      },\\n      // Testing hook, though it might be useful to expose the register\\n      // controller anyways.\\n      getRegisterController: function() {\\n        return vimGlobalState.registerController;\\n      },\\n      // Testing hook.\\n      resetVimGlobalState_: resetVimGlobalState,\\n\\n      // Testing hook.\\n      getVimGlobalState_: function() {\\n        return vimGlobalState;\\n      },\\n\\n      // Testing hook.\\n      maybeInitVimState_: maybeInitVimState,\\n\\n      suppressErrorLogging: false,\\n\\n      InsertModeKey: InsertModeKey,\\n      map: function(lhs, rhs, ctx) {\\n        // Add user defined key bindings.\\n        exCommandDispatcher.map(lhs, rhs, ctx);\\n      },\\n      unmap: function(lhs, ctx) {\\n        exCommandDispatcher.unmap(lhs, ctx);\\n      },\\n      // Non-recursive map function.\\n      // NOTE: This will not create mappings to key maps that aren't present\\n      // in the default key map. See TODO at bottom of function.\\n      noremap: function(lhs, rhs, ctx) {\\n        function toCtxArray(ctx) {\\n          return ctx ? [ctx] : ['normal', 'insert', 'visual'];\\n        }\\n        var ctxsToMap = toCtxArray(ctx);\\n        // Look through all actual defaults to find a map candidate.\\n        var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;\\n        for (var i = actualLength - origLength;\\n             i < actualLength && ctxsToMap.length;\\n             i++) {\\n          var mapping = defaultKeymap[i];\\n          // Omit mappings that operate in the wrong context(s) and those of invalid type.\\n          if (mapping.keys == rhs &&\\n              (!ctx || !mapping.context || mapping.context === ctx) &&\\n              mapping.type.substr(0, 2) !== 'ex' &&\\n              mapping.type.substr(0, 3) !== 'key') {\\n            // Make a shallow copy of the original keymap entry.\\n            var newMapping = {};\\n            for (var key in mapping) {\\n              newMapping[key] = mapping[key];\\n            }\\n            // Modify it point to the new mapping with the proper context.\\n            newMapping.keys = lhs;\\n            if (ctx && !newMapping.context) {\\n              newMapping.context = ctx;\\n            }\\n            // Add it to the keymap with a higher priority than the original.\\n            this._mapCommand(newMapping);\\n            // Record the mapped contexts as complete.\\n            var mappedCtxs = toCtxArray(mapping.context);\\n            ctxsToMap = ctxsToMap.filter(function(el) { return mappedCtxs.indexOf(el) === -1; });\\n          }\\n        }\\n        // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\\n      },\\n      // Remove all user-defined mappings for the provided context.\\n      mapclear: function(ctx) {\\n        // Partition the existing keymap into user-defined and true defaults.\\n        var actualLength = defaultKeymap.length,\\n            origLength = defaultKeymapLength;\\n        var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\\n        defaultKeymap = defaultKeymap.slice(actualLength - origLength);\\n        if (ctx) {\\n          // If a specific context is being cleared, we need to keep mappings\\n          // from all other contexts.\\n          for (var i = userKeymap.length - 1; i >= 0; i--) {\\n            var mapping = userKeymap[i];\\n            if (ctx !== mapping.context) {\\n              if (mapping.context) {\\n                this._mapCommand(mapping);\\n              } else {\\n                // `mapping` applies to all contexts so create keymap copies\\n                // for each context except the one being cleared.\\n                var contexts = ['normal', 'insert', 'visual'];\\n                for (var j in contexts) {\\n                  if (contexts[j] !== ctx) {\\n                    var newMapping = {};\\n                    for (var key in mapping) {\\n                      newMapping[key] = mapping[key];\\n                    }\\n                    newMapping.context = contexts[j];\\n                    this._mapCommand(newMapping);\\n                  }\\n                }\\n              }\\n            }\\n          }\\n        }\\n      },\\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\\n      setOption: setOption,\\n      getOption: getOption,\\n      defineOption: defineOption,\\n      defineEx: function(name, prefix, func){\\n        if (!prefix) {\\n          prefix = name;\\n        } else if (name.indexOf(prefix) !== 0) {\\n          throw new Error('(Vim.defineEx) \\\"'+prefix+'\\\" is not a prefix of \\\"'+name+'\\\", command not registered');\\n        }\\n        exCommands[name]=func;\\n        exCommandDispatcher.commandMap_[prefix]={name:name, shortName:prefix, type:'api'};\\n      },\\n      handleKey: function (cm, key, origin) {\\n        var command = this.findKey(cm, key, origin);\\n        if (typeof command === 'function') {\\n          return command();\\n        }\\n      },\\n      /**\\n       * This is the outermost function called by CodeMirror, after keys have\\n       * been mapped to their Vim equivalents.\\n       *\\n       * Finds a command based on the key (and cached keys if there is a\\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\\n       * function if a partial match is found (multi-key), and a function to\\n       * execute the bound command if a a key is matched. The function always\\n       * returns true.\\n       */\\n      findKey: function(cm, key, origin) {\\n        var vim = maybeInitVimState(cm);\\n        function handleMacroRecording() {\\n          var macroModeState = vimGlobalState.macroModeState;\\n          if (macroModeState.isRecording) {\\n            if (key == 'q') {\\n              macroModeState.exitMacroRecordMode();\\n              clearInputState(cm);\\n              return true;\\n            }\\n            if (origin != 'mapping') {\\n              logKey(macroModeState, key);\\n            }\\n          }\\n        }\\n        function handleEsc() {\\n          if (key == '<Esc>') {\\n            // Clear input state and get back to normal mode.\\n            clearInputState(cm);\\n            if (vim.visualMode) {\\n              exitVisualMode(cm);\\n            } else if (vim.insertMode) {\\n              exitInsertMode(cm);\\n            }\\n            return true;\\n          }\\n        }\\n        function doKeyToKey(keys) {\\n          // TODO: prevent infinite recursion.\\n          var match;\\n          while (keys) {\\n            // Pull off one command key, which is either a single character\\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\\n            match = (/<\\\\w+-.+?>|<\\\\w+>|./).exec(keys);\\n            key = match[0];\\n            keys = keys.substring(match.index + key.length);\\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\\n          }\\n        }\\n\\n        function handleKeyInsertMode() {\\n          if (handleEsc()) { return true; }\\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\\n          var keysAreChars = key.length == 1;\\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\\n          // Need to check all key substrings in insert mode.\\n          while (keys.length > 1 && match.type != 'full') {\\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\\n            if (thisMatch.type != 'none') { match = thisMatch; }\\n          }\\n          if (match.type == 'none') { clearInputState(cm); return false; }\\n          else if (match.type == 'partial') {\\n            if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\\n            lastInsertModeKeyTimer = window.setTimeout(\\n              function() { if (vim.insertMode && vim.inputState.keyBuffer) { clearInputState(cm); } },\\n              getOption('insertModeEscKeysTimeout'));\\n            return !keysAreChars;\\n          }\\n\\n          if (lastInsertModeKeyTimer) { window.clearTimeout(lastInsertModeKeyTimer); }\\n          if (keysAreChars) {\\n            var selections = cm.listSelections();\\n            for (var i = 0; i < selections.length; i++) {\\n              var here = selections[i].head;\\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\\n            }\\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\\n          }\\n          clearInputState(cm);\\n          return match.command;\\n        }\\n\\n        function handleKeyNonInsertMode() {\\n          if (handleMacroRecording() || handleEsc()) { return true; }\\n\\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\\n          if (/^[1-9]\\\\d*$/.test(keys)) { return true; }\\n\\n          var keysMatcher = /^(\\\\d*)(.*)$/.exec(keys);\\n          if (!keysMatcher) { clearInputState(cm); return false; }\\n          var context = vim.visualMode ? 'visual' :\\n                                         'normal';\\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\\n          if (match.type == 'none') { clearInputState(cm); return false; }\\n          else if (match.type == 'partial') { return true; }\\n\\n          vim.inputState.keyBuffer = '';\\n          var keysMatcher = /^(\\\\d*)(.*)$/.exec(keys);\\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\\n          }\\n          return match.command;\\n        }\\n\\n        var command;\\n        if (vim.insertMode) { command = handleKeyInsertMode(); }\\n        else { command = handleKeyNonInsertMode(); }\\n        if (command === false) {\\n          return !vim.insertMode && key.length === 1 ? function() { return true; } : undefined;\\n        } else if (command === true) {\\n          // TODO: Look into using CodeMirror's multi-key handling.\\n          // Return no-op since we are caching the key. Counts as handled, but\\n          // don't want act on it just yet.\\n          return function() { return true; };\\n        } else {\\n          return function() {\\n            return cm.operation(function() {\\n              cm.curOp.isVimOp = true;\\n              try {\\n                if (command.type == 'keyToKey') {\\n                  doKeyToKey(command.toKeys);\\n                } else {\\n                  commandDispatcher.processCommand(cm, vim, command);\\n                }\\n              } catch (e) {\\n                // clear VIM state in case it's in a bad state.\\n                cm.state.vim = undefined;\\n                maybeInitVimState(cm);\\n                if (!CodeMirror.Vim.suppressErrorLogging) {\\n                  console['log'](e);\\n                }\\n                throw e;\\n              }\\n              return true;\\n            });\\n          };\\n        }\\n      },\\n      handleEx: function(cm, input) {\\n        exCommandDispatcher.processCommand(cm, input);\\n      },\\n\\n      defineMotion: defineMotion,\\n      defineAction: defineAction,\\n      defineOperator: defineOperator,\\n      mapCommand: mapCommand,\\n      _mapCommand: _mapCommand,\\n\\n      defineRegister: defineRegister,\\n\\n      exitVisualMode: exitVisualMode,\\n      exitInsertMode: exitInsertMode\\n    };\\n\\n    // Represents the current input state.\\n    function InputState() {\\n      this.prefixRepeat = [];\\n      this.motionRepeat = [];\\n\\n      this.operator = null;\\n      this.operatorArgs = null;\\n      this.motion = null;\\n      this.motionArgs = null;\\n      this.keyBuffer = []; // For matching multi-key commands.\\n      this.registerName = null; // Defaults to the unnamed register.\\n    }\\n    InputState.prototype.pushRepeatDigit = function(n) {\\n      if (!this.operator) {\\n        this.prefixRepeat = this.prefixRepeat.concat(n);\\n      } else {\\n        this.motionRepeat = this.motionRepeat.concat(n);\\n      }\\n    };\\n    InputState.prototype.getRepeat = function() {\\n      var repeat = 0;\\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\\n        repeat = 1;\\n        if (this.prefixRepeat.length > 0) {\\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\\n        }\\n        if (this.motionRepeat.length > 0) {\\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\\n        }\\n      }\\n      return repeat;\\n    };\\n\\n    function clearInputState(cm, reason) {\\n      cm.state.vim.inputState = new InputState();\\n      CodeMirror.signal(cm, 'vim-command-done', reason);\\n    }\\n\\n    /*\\n     * Register stores information about copy and paste registers.  Besides\\n     * text, a register must store whether it is linewise (i.e., when it is\\n     * pasted, should it insert itself into a new line, or should the text be\\n     * inserted at the cursor position.)\\n     */\\n    function Register(text, linewise, blockwise) {\\n      this.clear();\\n      this.keyBuffer = [text || ''];\\n      this.insertModeChanges = [];\\n      this.searchQueries = [];\\n      this.linewise = !!linewise;\\n      this.blockwise = !!blockwise;\\n    }\\n    Register.prototype = {\\n      setText: function(text, linewise, blockwise) {\\n        this.keyBuffer = [text || ''];\\n        this.linewise = !!linewise;\\n        this.blockwise = !!blockwise;\\n      },\\n      pushText: function(text, linewise) {\\n        // if this register has ever been set to linewise, use linewise.\\n        if (linewise) {\\n          if (!this.linewise) {\\n            this.keyBuffer.push('\\\\n');\\n          }\\n          this.linewise = true;\\n        }\\n        this.keyBuffer.push(text);\\n      },\\n      pushInsertModeChanges: function(changes) {\\n        this.insertModeChanges.push(createInsertModeChanges(changes));\\n      },\\n      pushSearchQuery: function(query) {\\n        this.searchQueries.push(query);\\n      },\\n      clear: function() {\\n        this.keyBuffer = [];\\n        this.insertModeChanges = [];\\n        this.searchQueries = [];\\n        this.linewise = false;\\n      },\\n      toString: function() {\\n        return this.keyBuffer.join('');\\n      }\\n    };\\n\\n    /**\\n     * Defines an external register.\\n     *\\n     * The name should be a single character that will be used to reference the register.\\n     * The register should support setText, pushText, clear, and toString(). See Register\\n     * for a reference implementation.\\n     */\\n    function defineRegister(name, register) {\\n      var registers = vimGlobalState.registerController.registers;\\n      if (!name || name.length != 1) {\\n        throw Error('Register name must be 1 character');\\n      }\\n      if (registers[name]) {\\n        throw Error('Register already defined ' + name);\\n      }\\n      registers[name] = register;\\n      validRegisters.push(name);\\n    }\\n\\n    /*\\n     * vim registers allow you to keep many independent copy and paste buffers.\\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\\n     *\\n     * RegisterController keeps the state of all the registers.  An initial\\n     * state may be passed in.  The unnamed register '\\\"' will always be\\n     * overridden.\\n     */\\n    function RegisterController(registers) {\\n      this.registers = registers;\\n      this.unnamedRegister = registers['\\\"'] = new Register();\\n      registers['.'] = new Register();\\n      registers[':'] = new Register();\\n      registers['/'] = new Register();\\n    }\\n    RegisterController.prototype = {\\n      pushText: function(registerName, operator, text, linewise, blockwise) {\\n        if (linewise && text.charAt(text.length - 1) !== '\\\\n'){\\n          text += '\\\\n';\\n        }\\n        // Lowercase and uppercase registers refer to the same register.\\n        // Uppercase just means append.\\n        var register = this.isValidRegister(registerName) ?\\n            this.getRegister(registerName) : null;\\n        // if no register/an invalid register was specified, things go to the\\n        // default registers\\n        if (!register) {\\n          switch (operator) {\\n            case 'yank':\\n              // The 0 register contains the text from the most recent yank.\\n              this.registers['0'] = new Register(text, linewise, blockwise);\\n              break;\\n            case 'delete':\\n            case 'change':\\n              if (text.indexOf('\\\\n') == -1) {\\n                // Delete less than 1 line. Update the small delete register.\\n                this.registers['-'] = new Register(text, linewise);\\n              } else {\\n                // Shift down the contents of the numbered registers and put the\\n                // deleted text into register 1.\\n                this.shiftNumericRegisters_();\\n                this.registers['1'] = new Register(text, linewise);\\n              }\\n              break;\\n          }\\n          // Make sure the unnamed register is set to what just happened\\n          this.unnamedRegister.setText(text, linewise, blockwise);\\n          return;\\n        }\\n\\n        // If we've gotten to this point, we've actually specified a register\\n        var append = isUpperCase(registerName);\\n        if (append) {\\n          register.pushText(text, linewise);\\n        } else {\\n          register.setText(text, linewise, blockwise);\\n        }\\n        // The unnamed register always has the same value as the last used\\n        // register.\\n        this.unnamedRegister.setText(register.toString(), linewise);\\n      },\\n      // Gets the register named @name.  If one of @name doesn't already exist,\\n      // create it.  If @name is invalid, return the unnamedRegister.\\n      getRegister: function(name) {\\n        if (!this.isValidRegister(name)) {\\n          return this.unnamedRegister;\\n        }\\n        name = name.toLowerCase();\\n        if (!this.registers[name]) {\\n          this.registers[name] = new Register();\\n        }\\n        return this.registers[name];\\n      },\\n      isValidRegister: function(name) {\\n        return name && inArray(name, validRegisters);\\n      },\\n      shiftNumericRegisters_: function() {\\n        for (var i = 9; i >= 2; i--) {\\n          this.registers[i] = this.getRegister('' + (i - 1));\\n        }\\n      }\\n    };\\n    function HistoryController() {\\n        this.historyBuffer = [];\\n        this.iterator = 0;\\n        this.initialPrefix = null;\\n    }\\n    HistoryController.prototype = {\\n      // the input argument here acts a user entered prefix for a small time\\n      // until we start autocompletion in which case it is the autocompleted.\\n      nextMatch: function (input, up) {\\n        var historyBuffer = this.historyBuffer;\\n        var dir = up ? -1 : 1;\\n        if (this.initialPrefix === null) this.initialPrefix = input;\\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i+= dir) {\\n          var element = historyBuffer[i];\\n          for (var j = 0; j <= element.length; j++) {\\n            if (this.initialPrefix == element.substring(0, j)) {\\n              this.iterator = i;\\n              return element;\\n            }\\n          }\\n        }\\n        // should return the user input in case we reach the end of buffer.\\n        if (i >= historyBuffer.length) {\\n          this.iterator = historyBuffer.length;\\n          return this.initialPrefix;\\n        }\\n        // return the last autocompleted query or exCommand as it is.\\n        if (i < 0 ) return input;\\n      },\\n      pushInput: function(input) {\\n        var index = this.historyBuffer.indexOf(input);\\n        if (index > -1) this.historyBuffer.splice(index, 1);\\n        if (input.length) this.historyBuffer.push(input);\\n      },\\n      reset: function() {\\n        this.initialPrefix = null;\\n        this.iterator = this.historyBuffer.length;\\n      }\\n    };\\n    var commandDispatcher = {\\n      matchCommand: function(keys, keyMap, inputState, context) {\\n        var matches = commandMatches(keys, keyMap, context, inputState);\\n        if (!matches.full && !matches.partial) {\\n          return {type: 'none'};\\n        } else if (!matches.full && matches.partial) {\\n          return {type: 'partial'};\\n        }\\n\\n        var bestMatch;\\n        for (var i = 0; i < matches.full.length; i++) {\\n          var match = matches.full[i];\\n          if (!bestMatch) {\\n            bestMatch = match;\\n          }\\n        }\\n        if (bestMatch.keys.slice(-11) == '<character>') {\\n          var character = lastChar(keys);\\n          if (!character) return {type: 'none'};\\n          inputState.selectedCharacter = character;\\n        }\\n        return {type: 'full', command: bestMatch};\\n      },\\n      processCommand: function(cm, vim, command) {\\n        vim.inputState.repeatOverride = command.repeatOverride;\\n        switch (command.type) {\\n          case 'motion':\\n            this.processMotion(cm, vim, command);\\n            break;\\n          case 'operator':\\n            this.processOperator(cm, vim, command);\\n            break;\\n          case 'operatorMotion':\\n            this.processOperatorMotion(cm, vim, command);\\n            break;\\n          case 'action':\\n            this.processAction(cm, vim, command);\\n            break;\\n          case 'search':\\n            this.processSearch(cm, vim, command);\\n            break;\\n          case 'ex':\\n          case 'keyToEx':\\n            this.processEx(cm, vim, command);\\n            break;\\n          default:\\n            break;\\n        }\\n      },\\n      processMotion: function(cm, vim, command) {\\n        vim.inputState.motion = command.motion;\\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\\n        this.evalInput(cm, vim);\\n      },\\n      processOperator: function(cm, vim, command) {\\n        var inputState = vim.inputState;\\n        if (inputState.operator) {\\n          if (inputState.operator == command.operator) {\\n            // Typing an operator twice like 'dd' makes the operator operate\\n            // linewise\\n            inputState.motion = 'expandToLine';\\n            inputState.motionArgs = { linewise: true };\\n            this.evalInput(cm, vim);\\n            return;\\n          } else {\\n            // 2 different operators in a row doesn't make sense.\\n            clearInputState(cm);\\n          }\\n        }\\n        inputState.operator = command.operator;\\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\\n        if (vim.visualMode) {\\n          // Operating on a selection in visual mode. We don't need a motion.\\n          this.evalInput(cm, vim);\\n        }\\n      },\\n      processOperatorMotion: function(cm, vim, command) {\\n        var visualMode = vim.visualMode;\\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\\n        if (operatorMotionArgs) {\\n          // Operator motions may have special behavior in visual mode.\\n          if (visualMode && operatorMotionArgs.visualLine) {\\n            vim.visualLine = true;\\n          }\\n        }\\n        this.processOperator(cm, vim, command);\\n        if (!visualMode) {\\n          this.processMotion(cm, vim, command);\\n        }\\n      },\\n      processAction: function(cm, vim, command) {\\n        var inputState = vim.inputState;\\n        var repeat = inputState.getRepeat();\\n        var repeatIsExplicit = !!repeat;\\n        var actionArgs = copyArgs(command.actionArgs) || {};\\n        if (inputState.selectedCharacter) {\\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\\n        }\\n        // Actions may or may not have motions and operators. Do these first.\\n        if (command.operator) {\\n          this.processOperator(cm, vim, command);\\n        }\\n        if (command.motion) {\\n          this.processMotion(cm, vim, command);\\n        }\\n        if (command.motion || command.operator) {\\n          this.evalInput(cm, vim);\\n        }\\n        actionArgs.repeat = repeat || 1;\\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\\n        actionArgs.registerName = inputState.registerName;\\n        clearInputState(cm);\\n        vim.lastMotion = null;\\n        if (command.isEdit) {\\n          this.recordLastEdit(vim, inputState, command);\\n        }\\n        actions[command.action](cm, actionArgs, vim);\\n      },\\n      processSearch: function(cm, vim, command) {\\n        if (!cm.getSearchCursor) {\\n          // Search depends on SearchCursor.\\n          return;\\n        }\\n        var forward = command.searchArgs.forward;\\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\\n        getSearchState(cm).setReversed(!forward);\\n        var promptPrefix = (forward) ? '/' : '?';\\n        var originalQuery = getSearchState(cm).getQuery();\\n        var originalScrollPos = cm.getScrollInfo();\\n        function handleQuery(query, ignoreCase, smartCase) {\\n          vimGlobalState.searchHistoryController.pushInput(query);\\n          vimGlobalState.searchHistoryController.reset();\\n          try {\\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\\n          } catch (e) {\\n            showConfirm(cm, 'Invalid regex: ' + query);\\n            clearInputState(cm);\\n            return;\\n          }\\n          commandDispatcher.processMotion(cm, vim, {\\n            type: 'motion',\\n            motion: 'findNext',\\n            motionArgs: { forward: true, toJumplist: command.searchArgs.toJumplist }\\n          });\\n        }\\n        function onPromptClose(query) {\\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\\n          var macroModeState = vimGlobalState.macroModeState;\\n          if (macroModeState.isRecording) {\\n            logSearchQuery(macroModeState, query);\\n          }\\n        }\\n        function onPromptKeyUp(e, query, close) {\\n          var keyName = CodeMirror.keyName(e), up, offset;\\n          if (keyName == 'Up' || keyName == 'Down') {\\n            up = keyName == 'Up' ? true : false;\\n            offset = e.target ? e.target.selectionEnd : 0;\\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\\n            close(query);\\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\\n          } else {\\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\\n              vimGlobalState.searchHistoryController.reset();\\n          }\\n          var parsedQuery;\\n          try {\\n            parsedQuery = updateSearchQuery(cm, query,\\n                true /** ignoreCase */, true /** smartCase */);\\n          } catch (e) {\\n            // Swallow bad regexes for incremental search.\\n          }\\n          if (parsedQuery) {\\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\\n          } else {\\n            clearSearchHighlight(cm);\\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\\n          }\\n        }\\n        function onPromptKeyDown(e, query, close) {\\n          var keyName = CodeMirror.keyName(e);\\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\\n              (keyName == 'Backspace' && query == '')) {\\n            vimGlobalState.searchHistoryController.pushInput(query);\\n            vimGlobalState.searchHistoryController.reset();\\n            updateSearchQuery(cm, originalQuery);\\n            clearSearchHighlight(cm);\\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\\n            CodeMirror.e_stop(e);\\n            clearInputState(cm);\\n            close();\\n            cm.focus();\\n          } else if (keyName == 'Up' || keyName == 'Down') {\\n            CodeMirror.e_stop(e);\\n          } else if (keyName == 'Ctrl-U') {\\n            // Ctrl-U clears input.\\n            CodeMirror.e_stop(e);\\n            close('');\\n          }\\n        }\\n        switch (command.searchArgs.querySrc) {\\n          case 'prompt':\\n            var macroModeState = vimGlobalState.macroModeState;\\n            if (macroModeState.isPlaying) {\\n              var query = macroModeState.replaySearchQueries.shift();\\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\\n            } else {\\n              showPrompt(cm, {\\n                  onClose: onPromptClose,\\n                  prefix: promptPrefix,\\n                  desc: searchPromptDesc,\\n                  onKeyUp: onPromptKeyUp,\\n                  onKeyDown: onPromptKeyDown\\n              });\\n            }\\n            break;\\n          case 'wordUnderCursor':\\n            var word = expandWordUnderCursor(cm, false /** inclusive */,\\n                true /** forward */, false /** bigWord */,\\n                true /** noSymbol */);\\n            var isKeyword = true;\\n            if (!word) {\\n              word = expandWordUnderCursor(cm, false /** inclusive */,\\n                  true /** forward */, false /** bigWord */,\\n                  false /** noSymbol */);\\n              isKeyword = false;\\n            }\\n            if (!word) {\\n              return;\\n            }\\n            var query = cm.getLine(word.start.line).substring(word.start.ch,\\n                word.end.ch);\\n            if (isKeyword && wholeWordOnly) {\\n                query = '\\\\\\\\b' + query + '\\\\\\\\b';\\n            } else {\\n              query = escapeRegex(query);\\n            }\\n\\n            // cachedCursor is used to save the old position of the cursor\\n            // when * or # causes vim to seek for the nearest word and shift\\n            // the cursor before entering the motion.\\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\\n            cm.setCursor(word.start);\\n\\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\\n            break;\\n        }\\n      },\\n      processEx: function(cm, vim, command) {\\n        function onPromptClose(input) {\\n          // Give the prompt some time to close so that if processCommand shows\\n          // an error, the elements don't overlap.\\n          vimGlobalState.exCommandHistoryController.pushInput(input);\\n          vimGlobalState.exCommandHistoryController.reset();\\n          exCommandDispatcher.processCommand(cm, input);\\n        }\\n        function onPromptKeyDown(e, input, close) {\\n          var keyName = CodeMirror.keyName(e), up, offset;\\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' ||\\n              (keyName == 'Backspace' && input == '')) {\\n            vimGlobalState.exCommandHistoryController.pushInput(input);\\n            vimGlobalState.exCommandHistoryController.reset();\\n            CodeMirror.e_stop(e);\\n            clearInputState(cm);\\n            close();\\n            cm.focus();\\n          }\\n          if (keyName == 'Up' || keyName == 'Down') {\\n            CodeMirror.e_stop(e);\\n            up = keyName == 'Up' ? true : false;\\n            offset = e.target ? e.target.selectionEnd : 0;\\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\\n            close(input);\\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\\n          } else if (keyName == 'Ctrl-U') {\\n            // Ctrl-U clears input.\\n            CodeMirror.e_stop(e);\\n            close('');\\n          } else {\\n            if ( keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift')\\n              vimGlobalState.exCommandHistoryController.reset();\\n          }\\n        }\\n        if (command.type == 'keyToEx') {\\n          // Handle user defined Ex to Ex mappings\\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\\n        } else {\\n          if (vim.visualMode) {\\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':', value: '\\\\'<,\\\\'>',\\n                onKeyDown: onPromptKeyDown, selectValueOnOpen: false});\\n          } else {\\n            showPrompt(cm, { onClose: onPromptClose, prefix: ':',\\n                onKeyDown: onPromptKeyDown});\\n          }\\n        }\\n      },\\n      evalInput: function(cm, vim) {\\n        // If the motion command is set, execute both the operator and motion.\\n        // Otherwise return.\\n        var inputState = vim.inputState;\\n        var motion = inputState.motion;\\n        var motionArgs = inputState.motionArgs || {};\\n        var operator = inputState.operator;\\n        var operatorArgs = inputState.operatorArgs || {};\\n        var registerName = inputState.registerName;\\n        var sel = vim.sel;\\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head): cm.getCursor('head'));\\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\\n        var oldHead = copyCursor(origHead);\\n        var oldAnchor = copyCursor(origAnchor);\\n        var newHead, newAnchor;\\n        var repeat;\\n        if (operator) {\\n          this.recordLastEdit(vim, inputState);\\n        }\\n        if (inputState.repeatOverride !== undefined) {\\n          // If repeatOverride is specified, that takes precedence over the\\n          // input state's repeat. Used by Ex mode and can be user defined.\\n          repeat = inputState.repeatOverride;\\n        } else {\\n          repeat = inputState.getRepeat();\\n        }\\n        if (repeat > 0 && motionArgs.explicitRepeat) {\\n          motionArgs.repeatIsExplicit = true;\\n        } else if (motionArgs.noRepeat ||\\n            (!motionArgs.explicitRepeat && repeat === 0)) {\\n          repeat = 1;\\n          motionArgs.repeatIsExplicit = false;\\n        }\\n        if (inputState.selectedCharacter) {\\n          // If there is a character input, stick it in all of the arg arrays.\\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\\n              inputState.selectedCharacter;\\n        }\\n        motionArgs.repeat = repeat;\\n        clearInputState(cm);\\n        if (motion) {\\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\\n          vim.lastMotion = motions[motion];\\n          if (!motionResult) {\\n            return;\\n          }\\n          if (motionArgs.toJumplist) {\\n            var jumpList = vimGlobalState.jumpList;\\n            // if the current motion is # or *, use cachedCursor\\n            var cachedCursor = jumpList.cachedCursor;\\n            if (cachedCursor) {\\n              recordJumpPosition(cm, cachedCursor, motionResult);\\n              delete jumpList.cachedCursor;\\n            } else {\\n              recordJumpPosition(cm, origHead, motionResult);\\n            }\\n          }\\n          if (motionResult instanceof Array) {\\n            newAnchor = motionResult[0];\\n            newHead = motionResult[1];\\n          } else {\\n            newHead = motionResult;\\n          }\\n          // TODO: Handle null returns from motion commands better.\\n          if (!newHead) {\\n            newHead = copyCursor(origHead);\\n          }\\n          if (vim.visualMode) {\\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\\n            }\\n            if (newAnchor) {\\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\\n            }\\n            newAnchor = newAnchor || oldAnchor;\\n            sel.anchor = newAnchor;\\n            sel.head = newHead;\\n            updateCmSelection(cm);\\n            updateMark(cm, vim, '<',\\n                cursorIsBefore(newAnchor, newHead) ? newAnchor\\n                    : newHead);\\n            updateMark(cm, vim, '>',\\n                cursorIsBefore(newAnchor, newHead) ? newHead\\n                    : newAnchor);\\n          } else if (!operator) {\\n            newHead = clipCursorToContent(cm, newHead);\\n            cm.setCursor(newHead.line, newHead.ch);\\n          }\\n        }\\n        if (operator) {\\n          if (operatorArgs.lastSel) {\\n            // Replaying a visual mode operation\\n            newAnchor = oldAnchor;\\n            var lastSel = operatorArgs.lastSel;\\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\\n            if (lastSel.visualLine) {\\n              // Linewise Visual mode: The same number of lines.\\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\\n            } else if (lastSel.visualBlock) {\\n              // Blockwise Visual mode: The same number of lines and columns.\\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\\n            } else if (lastSel.head.line == lastSel.anchor.line) {\\n              // Normal Visual mode within one line: The same number of characters.\\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\\n            } else {\\n              // Normal Visual mode with several lines: The same number of lines, in the\\n              // last line the same number of characters as in the last line the last time.\\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\\n            }\\n            vim.visualMode = true;\\n            vim.visualLine = lastSel.visualLine;\\n            vim.visualBlock = lastSel.visualBlock;\\n            sel = vim.sel = {\\n              anchor: newAnchor,\\n              head: newHead\\n            };\\n            updateCmSelection(cm);\\n          } else if (vim.visualMode) {\\n            operatorArgs.lastSel = {\\n              anchor: copyCursor(sel.anchor),\\n              head: copyCursor(sel.head),\\n              visualBlock: vim.visualBlock,\\n              visualLine: vim.visualLine\\n            };\\n          }\\n          var curStart, curEnd, linewise, mode;\\n          var cmSel;\\n          if (vim.visualMode) {\\n            // Init visual op\\n            curStart = cursorMin(sel.head, sel.anchor);\\n            curEnd = cursorMax(sel.head, sel.anchor);\\n            linewise = vim.visualLine || operatorArgs.linewise;\\n            mode = vim.visualBlock ? 'block' :\\n                   linewise ? 'line' :\\n                   'char';\\n            cmSel = makeCmSelection(cm, {\\n              anchor: curStart,\\n              head: curEnd\\n            }, mode);\\n            if (linewise) {\\n              var ranges = cmSel.ranges;\\n              if (mode == 'block') {\\n                // Linewise operators in visual block mode extend to end of line\\n                for (var i = 0; i < ranges.length; i++) {\\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\\n                }\\n              } else if (mode == 'line') {\\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\\n              }\\n            }\\n          } else {\\n            // Init motion op\\n            curStart = copyCursor(newAnchor || oldAnchor);\\n            curEnd = copyCursor(newHead || oldHead);\\n            if (cursorIsBefore(curEnd, curStart)) {\\n              var tmp = curStart;\\n              curStart = curEnd;\\n              curEnd = tmp;\\n            }\\n            linewise = motionArgs.linewise || operatorArgs.linewise;\\n            if (linewise) {\\n              // Expand selection to entire line.\\n              expandSelectionToLine(cm, curStart, curEnd);\\n            } else if (motionArgs.forward) {\\n              // Clip to trailing newlines only if the motion goes forward.\\n              clipToLine(cm, curStart, curEnd);\\n            }\\n            mode = 'char';\\n            var exclusive = !motionArgs.inclusive || linewise;\\n            cmSel = makeCmSelection(cm, {\\n              anchor: curStart,\\n              head: curEnd\\n            }, mode, exclusive);\\n          }\\n          cm.setSelections(cmSel.ranges, cmSel.primary);\\n          vim.lastMotion = null;\\n          operatorArgs.repeat = repeat; // For indent in visual mode.\\n          operatorArgs.registerName = registerName;\\n          // Keep track of linewise as it affects how paste and change behave.\\n          operatorArgs.linewise = linewise;\\n          var operatorMoveTo = operators[operator](\\n            cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\\n          if (vim.visualMode) {\\n            exitVisualMode(cm, operatorMoveTo != null);\\n          }\\n          if (operatorMoveTo) {\\n            cm.setCursor(operatorMoveTo);\\n          }\\n        }\\n      },\\n      recordLastEdit: function(vim, inputState, actionCommand) {\\n        var macroModeState = vimGlobalState.macroModeState;\\n        if (macroModeState.isPlaying) { return; }\\n        vim.lastEditInputState = inputState;\\n        vim.lastEditActionCommand = actionCommand;\\n        macroModeState.lastInsertModeChanges.changes = [];\\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\\n      }\\n    };\\n\\n    /**\\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\\n     *     position of the cursor.\\n     */\\n    // All of the functions below return Cursor objects.\\n    var motions = {\\n      moveToTopLine: function(cm, _head, motionArgs) {\\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat -1;\\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\\n      },\\n      moveToMiddleLine: function(cm) {\\n        var range = getUserVisibleLines(cm);\\n        var line = Math.floor((range.top + range.bottom) * 0.5);\\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\\n      },\\n      moveToBottomLine: function(cm, _head, motionArgs) {\\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat +1;\\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\\n      },\\n      expandToLine: function(_cm, head, motionArgs) {\\n        // Expands forward to end of line, and then to next line if repeat is\\n        // >1. Does not handle backward motion!\\n        var cur = head;\\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\\n      },\\n      findNext: function(cm, _head, motionArgs) {\\n        var state = getSearchState(cm);\\n        var query = state.getQuery();\\n        if (!query) {\\n          return;\\n        }\\n        var prev = !motionArgs.forward;\\n        // If search is initiated with ? instead of /, negate direction.\\n        prev = (state.isReversed()) ? !prev : prev;\\n        highlightSearchMatches(cm, query);\\n        return findNext(cm, prev/** prev */, query, motionArgs.repeat);\\n      },\\n      goToMark: function(cm, _head, motionArgs, vim) {\\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\\n        if (pos) {\\n          return motionArgs.linewise ? { line: pos.line, ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)) } : pos;\\n        }\\n        return null;\\n      },\\n      moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {\\n        if (vim.visualBlock && motionArgs.sameLine) {\\n          var sel = vim.sel;\\n          return [\\n            clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)),\\n            clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))\\n          ];\\n        } else {\\n          return ([vim.sel.head, vim.sel.anchor]);\\n        }\\n      },\\n      jumpToMark: function(cm, head, motionArgs, vim) {\\n        var best = head;\\n        for (var i = 0; i < motionArgs.repeat; i++) {\\n          var cursor = best;\\n          for (var key in vim.marks) {\\n            if (!isLowerCase(key)) {\\n              continue;\\n            }\\n            var mark = vim.marks[key].find();\\n            var isWrongDirection = (motionArgs.forward) ?\\n              cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\\n\\n            if (isWrongDirection) {\\n              continue;\\n            }\\n            if (motionArgs.linewise && (mark.line == cursor.line)) {\\n              continue;\\n            }\\n\\n            var equal = cursorEqual(cursor, best);\\n            var between = (motionArgs.forward) ?\\n              cursorIsBetween(cursor, mark, best) :\\n              cursorIsBetween(best, mark, cursor);\\n\\n            if (equal || between) {\\n              best = mark;\\n            }\\n          }\\n        }\\n\\n        if (motionArgs.linewise) {\\n          // Vim places the cursor on the first non-whitespace character of\\n          // the line if there is one, else it places the cursor at the end\\n          // of the line, regardless of whether a mark was found.\\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\\n        }\\n        return best;\\n      },\\n      moveByCharacters: function(_cm, head, motionArgs) {\\n        var cur = head;\\n        var repeat = motionArgs.repeat;\\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\\n        return Pos(cur.line, ch);\\n      },\\n      moveByLines: function(cm, head, motionArgs, vim) {\\n        var cur = head;\\n        var endCh = cur.ch;\\n        // Depending what our last motion was, we may want to do different\\n        // things. If our last motion was moving vertically, we want to\\n        // preserve the HPos from our last horizontal move.  If our last motion\\n        // was going to the end of a line, moving vertically we should go to\\n        // the end of the line, etc.\\n        switch (vim.lastMotion) {\\n          case this.moveByLines:\\n          case this.moveByDisplayLines:\\n          case this.moveByScroll:\\n          case this.moveToColumn:\\n          case this.moveToEol:\\n            endCh = vim.lastHPos;\\n            break;\\n          default:\\n            vim.lastHPos = endCh;\\n        }\\n        var repeat = motionArgs.repeat+(motionArgs.repeatOffset||0);\\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\\n        var first = cm.firstLine();\\n        var last = cm.lastLine();\\n        // Vim go to line begin or line end when cursor at first/last line and\\n        // move to previous/next line is triggered.\\n        if (line < first && cur.line == first){\\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\\n        }else if (line > last && cur.line == last){\\n            return this.moveToEol(cm, head, motionArgs, vim);\\n        }\\n        if (motionArgs.toFirstChar){\\n          endCh=findFirstNonWhiteSpaceCharacter(cm.getLine(line));\\n          vim.lastHPos = endCh;\\n        }\\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh),'div').left;\\n        return Pos(line, endCh);\\n      },\\n      moveByDisplayLines: function(cm, head, motionArgs, vim) {\\n        var cur = head;\\n        switch (vim.lastMotion) {\\n          case this.moveByDisplayLines:\\n          case this.moveByScroll:\\n          case this.moveByLines:\\n          case this.moveToColumn:\\n          case this.moveToEol:\\n            break;\\n          default:\\n            vim.lastHSPos = cm.charCoords(cur,'div').left;\\n        }\\n        var repeat = motionArgs.repeat;\\n        var res=cm.findPosV(cur,(motionArgs.forward ? repeat : -repeat),'line',vim.lastHSPos);\\n        if (res.hitSide) {\\n          if (motionArgs.forward) {\\n            var lastCharCoords = cm.charCoords(res, 'div');\\n            var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\\n            var res = cm.coordsChar(goalCoords, 'div');\\n          } else {\\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\\n            resCoords.left = vim.lastHSPos;\\n            res = cm.coordsChar(resCoords, 'div');\\n          }\\n        }\\n        vim.lastHPos = res.ch;\\n        return res;\\n      },\\n      moveByPage: function(cm, head, motionArgs) {\\n        // CodeMirror only exposes functions that move the cursor page down, so\\n        // doing this bad hack to move the cursor and move it back. evalInput\\n        // will move the cursor to where it should be in the end.\\n        var curStart = head;\\n        var repeat = motionArgs.repeat;\\n        return cm.findPosV(curStart, (motionArgs.forward ? repeat : -repeat), 'page');\\n      },\\n      moveByParagraph: function(cm, head, motionArgs) {\\n        var dir = motionArgs.forward ? 1 : -1;\\n        return findParagraph(cm, head, motionArgs.repeat, dir);\\n      },\\n      moveBySentence: function(cm, head, motionArgs) {\\n        var dir = motionArgs.forward ? 1 : -1;\\n        return findSentence(cm, head, motionArgs.repeat, dir);\\n      },\\n      moveByScroll: function(cm, head, motionArgs, vim) {\\n        var scrollbox = cm.getScrollInfo();\\n        var curEnd = null;\\n        var repeat = motionArgs.repeat;\\n        if (!repeat) {\\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\\n        }\\n        var orig = cm.charCoords(head, 'local');\\n        motionArgs.repeat = repeat;\\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\\n        if (!curEnd) {\\n          return null;\\n        }\\n        var dest = cm.charCoords(curEnd, 'local');\\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\\n        return curEnd;\\n      },\\n      moveByWords: function(cm, head, motionArgs) {\\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward,\\n            !!motionArgs.wordEnd, !!motionArgs.bigWord);\\n      },\\n      moveTillCharacter: function(cm, _head, motionArgs) {\\n        var repeat = motionArgs.repeat;\\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward,\\n            motionArgs.selectedCharacter);\\n        var increment = motionArgs.forward ? -1 : 1;\\n        recordLastCharacterSearch(increment, motionArgs);\\n        if (!curEnd) return null;\\n        curEnd.ch += increment;\\n        return curEnd;\\n      },\\n      moveToCharacter: function(cm, head, motionArgs) {\\n        var repeat = motionArgs.repeat;\\n        recordLastCharacterSearch(0, motionArgs);\\n        return moveToCharacter(cm, repeat, motionArgs.forward,\\n            motionArgs.selectedCharacter) || head;\\n      },\\n      moveToSymbol: function(cm, head, motionArgs) {\\n        var repeat = motionArgs.repeat;\\n        return findSymbol(cm, repeat, motionArgs.forward,\\n            motionArgs.selectedCharacter) || head;\\n      },\\n      moveToColumn: function(cm, head, motionArgs, vim) {\\n        var repeat = motionArgs.repeat;\\n        // repeat is equivalent to which column we want to move to!\\n        vim.lastHPos = repeat - 1;\\n        vim.lastHSPos = cm.charCoords(head,'div').left;\\n        return moveToColumn(cm, repeat);\\n      },\\n      moveToEol: function(cm, head, motionArgs, vim) {\\n        var cur = head;\\n        vim.lastHPos = Infinity;\\n        var retval= Pos(cur.line + motionArgs.repeat - 1, Infinity);\\n        var end=cm.clipPos(retval);\\n        end.ch--;\\n        vim.lastHSPos = cm.charCoords(end,'div').left;\\n        return retval;\\n      },\\n      moveToFirstNonWhiteSpaceCharacter: function(cm, head) {\\n        // Go to the start of the line where the text begins, or the end for\\n        // whitespace-only lines\\n        var cursor = head;\\n        return Pos(cursor.line,\\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\\n      },\\n      moveToMatchedSymbol: function(cm, head) {\\n        var cursor = head;\\n        var line = cursor.line;\\n        var ch = cursor.ch;\\n        var lineText = cm.getLine(line);\\n        var symbol;\\n        for (; ch < lineText.length; ch++) {\\n          symbol = lineText.charAt(ch);\\n          if (symbol && isMatchableSymbol(symbol)) {\\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\\n            if (style !== \\\"string\\\" && style !== \\\"comment\\\") {\\n              break;\\n            }\\n          }\\n        }\\n        if (ch < lineText.length) {\\n          // Only include angle brackets in analysis if they are being matched.\\n          var re = (ch === '<' || ch === '>') ? /[(){}[\\\\]<>]/ : /[(){}[\\\\]]/;\\n          var matched = cm.findMatchingBracket(Pos(line, ch), {bracketRegex: re});\\n          return matched.to;\\n        } else {\\n          return cursor;\\n        }\\n      },\\n      moveToStartOfLine: function(_cm, head) {\\n        return Pos(head.line, 0);\\n      },\\n      moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {\\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\\n        if (motionArgs.repeatIsExplicit) {\\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\\n        }\\n        return Pos(lineNum,\\n                   findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\\n      },\\n      textObjectManipulation: function(cm, head, motionArgs, vim) {\\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\\n        //     outside of a () block.\\n        var mirroredPairs = {'(': ')', ')': '(',\\n                             '{': '}', '}': '{',\\n                             '[': ']', ']': '[',\\n                             '<': '>', '>': '<'};\\n        var selfPaired = {'\\\\'': true, '\\\"': true};\\n\\n        var character = motionArgs.selectedCharacter;\\n        // 'b' refers to  '()' block.\\n        // 'B' refers to  '{}' block.\\n        if (character == 'b') {\\n          character = '(';\\n        } else if (character == 'B') {\\n          character = '{';\\n        }\\n\\n        // Inclusive is the difference between a and i\\n        // TODO: Instead of using the additional text object map to perform text\\n        //     object operations, merge the map into the defaultKeyMap and use\\n        //     motionArgs to define behavior. Define separate entries for 'aw',\\n        //     'iw', 'a[', 'i[', etc.\\n        var inclusive = !motionArgs.textObjectInner;\\n\\n        var tmp;\\n        if (mirroredPairs[character]) {\\n          tmp = selectCompanionObject(cm, head, character, inclusive);\\n        } else if (selfPaired[character]) {\\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\\n        } else if (character === 'W') {\\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\\n                                                     true /** bigWord */);\\n        } else if (character === 'w') {\\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */,\\n                                                     false /** bigWord */);\\n        } else if (character === 'p') {\\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\\n          motionArgs.linewise = true;\\n          if (vim.visualMode) {\\n            if (!vim.visualLine) { vim.visualLine = true; }\\n          } else {\\n            var operatorArgs = vim.inputState.operatorArgs;\\n            if (operatorArgs) { operatorArgs.linewise = true; }\\n            tmp.end.line--;\\n          }\\n        } else {\\n          // No text object defined for this, don't move.\\n          return null;\\n        }\\n\\n        if (!cm.state.vim.visualMode) {\\n          return [tmp.start, tmp.end];\\n        } else {\\n          return expandSelection(cm, tmp.start, tmp.end);\\n        }\\n      },\\n\\n      repeatLastCharacterSearch: function(cm, head, motionArgs) {\\n        var lastSearch = vimGlobalState.lastCharacterSearch;\\n        var repeat = motionArgs.repeat;\\n        var forward = motionArgs.forward === lastSearch.forward;\\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\\n        cm.moveH(-increment, 'char');\\n        motionArgs.inclusive = forward ? true : false;\\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\\n        if (!curEnd) {\\n          cm.moveH(increment, 'char');\\n          return head;\\n        }\\n        curEnd.ch += increment;\\n        return curEnd;\\n      }\\n    };\\n\\n    function defineMotion(name, fn) {\\n      motions[name] = fn;\\n    }\\n\\n    function fillArray(val, times) {\\n      var arr = [];\\n      for (var i = 0; i < times; i++) {\\n        arr.push(val);\\n      }\\n      return arr;\\n    }\\n    /**\\n     * An operator acts on a text selection. It receives the list of selections\\n     * as input. The corresponding CodeMirror selection is guaranteed to\\n    * match the input selection.\\n     */\\n    var operators = {\\n      change: function(cm, args, ranges) {\\n        var finalHead, text;\\n        var vim = cm.state.vim;\\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\\n        if (!vim.visualMode) {\\n          var anchor = ranges[0].anchor,\\n              head = ranges[0].head;\\n          text = cm.getRange(anchor, head);\\n          var lastState = vim.lastEditInputState || {};\\n          if (lastState.motion == \\\"moveByWords\\\" && !isWhiteSpaceString(text)) {\\n            // Exclude trailing whitespace if the range is not all whitespace.\\n            var match = (/\\\\s+$/).exec(text);\\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\\n              head = offsetCursor(head, 0, - match[0].length);\\n              text = text.slice(0, - match[0].length);\\n            }\\n          }\\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\\n          var wasLastLine = cm.firstLine() == cm.lastLine();\\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\\n            cm.replaceRange('', prevLineEnd, head);\\n          } else {\\n            cm.replaceRange('', anchor, head);\\n          }\\n          if (args.linewise) {\\n            // Push the next line back down, if there is a next line.\\n            if (!wasLastLine) {\\n              cm.setCursor(prevLineEnd);\\n              CodeMirror.commands.newlineAndIndent(cm);\\n            }\\n            // make sure cursor ends up at the end of the line.\\n            anchor.ch = Number.MAX_VALUE;\\n          }\\n          finalHead = anchor;\\n        } else {\\n          text = cm.getSelection();\\n          var replacement = fillArray('', ranges.length);\\n          cm.replaceSelections(replacement);\\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\\n        }\\n        vimGlobalState.registerController.pushText(\\n            args.registerName, 'change', text,\\n            args.linewise, ranges.length > 1);\\n        actions.enterInsertMode(cm, {head: finalHead}, cm.state.vim);\\n      },\\n      // delete is a javascript keyword.\\n      'delete': function(cm, args, ranges) {\\n        var finalHead, text;\\n        var vim = cm.state.vim;\\n        if (!vim.visualBlock) {\\n          var anchor = ranges[0].anchor,\\n              head = ranges[0].head;\\n          if (args.linewise &&\\n              head.line != cm.firstLine() &&\\n              anchor.line == cm.lastLine() &&\\n              anchor.line == head.line - 1) {\\n            // Special case for dd on last line (and first line).\\n            if (anchor.line == cm.firstLine()) {\\n              anchor.ch = 0;\\n            } else {\\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\\n            }\\n          }\\n          text = cm.getRange(anchor, head);\\n          cm.replaceRange('', anchor, head);\\n          finalHead = anchor;\\n          if (args.linewise) {\\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\\n          }\\n        } else {\\n          text = cm.getSelection();\\n          var replacement = fillArray('', ranges.length);\\n          cm.replaceSelections(replacement);\\n          finalHead = ranges[0].anchor;\\n        }\\n        vimGlobalState.registerController.pushText(\\n            args.registerName, 'delete', text,\\n            args.linewise, vim.visualBlock);\\n        var includeLineBreak = vim.insertMode\\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\\n      },\\n      indent: function(cm, args, ranges) {\\n        var vim = cm.state.vim;\\n        var startLine = ranges[0].anchor.line;\\n        var endLine = vim.visualBlock ?\\n          ranges[ranges.length - 1].anchor.line :\\n          ranges[0].head.line;\\n        // In visual mode, n> shifts the selection right n times, instead of\\n        // shifting n lines right once.\\n        var repeat = (vim.visualMode) ? args.repeat : 1;\\n        if (args.linewise) {\\n          // The only way to delete a newline is to delete until the start of\\n          // the next line, so in linewise mode evalInput will include the next\\n          // line. We don't want this in indent, so we go back a line.\\n          endLine--;\\n        }\\n        for (var i = startLine; i <= endLine; i++) {\\n          for (var j = 0; j < repeat; j++) {\\n            cm.indentLine(i, args.indentRight);\\n          }\\n        }\\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\\n      },\\n      indentAuto: function(cm, _args, ranges) {\\n        cm.execCommand(\\\"indentAuto\\\");\\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\\n      },\\n      changeCase: function(cm, args, ranges, oldAnchor, newHead) {\\n        var selections = cm.getSelections();\\n        var swapped = [];\\n        var toLower = args.toLower;\\n        for (var j = 0; j < selections.length; j++) {\\n          var toSwap = selections[j];\\n          var text = '';\\n          if (toLower === true) {\\n            text = toSwap.toLowerCase();\\n          } else if (toLower === false) {\\n            text = toSwap.toUpperCase();\\n          } else {\\n            for (var i = 0; i < toSwap.length; i++) {\\n              var character = toSwap.charAt(i);\\n              text += isUpperCase(character) ? character.toLowerCase() :\\n                  character.toUpperCase();\\n            }\\n          }\\n          swapped.push(text);\\n        }\\n        cm.replaceSelections(swapped);\\n        if (args.shouldMoveCursor){\\n          return newHead;\\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\\n        } else if (args.linewise){\\n          return oldAnchor;\\n        } else {\\n          return cursorMin(ranges[0].anchor, ranges[0].head);\\n        }\\n      },\\n      yank: function(cm, args, ranges, oldAnchor) {\\n        var vim = cm.state.vim;\\n        var text = cm.getSelection();\\n        var endPos = vim.visualMode\\n          ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor)\\n          : oldAnchor;\\n        vimGlobalState.registerController.pushText(\\n            args.registerName, 'yank',\\n            text, args.linewise, vim.visualBlock);\\n        return endPos;\\n      }\\n    };\\n\\n    function defineOperator(name, fn) {\\n      operators[name] = fn;\\n    }\\n\\n    var actions = {\\n      jumpListWalk: function(cm, actionArgs, vim) {\\n        if (vim.visualMode) {\\n          return;\\n        }\\n        var repeat = actionArgs.repeat;\\n        var forward = actionArgs.forward;\\n        var jumpList = vimGlobalState.jumpList;\\n\\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\\n        var markPos = mark ? mark.find() : undefined;\\n        markPos = markPos ? markPos : cm.getCursor();\\n        cm.setCursor(markPos);\\n      },\\n      scroll: function(cm, actionArgs, vim) {\\n        if (vim.visualMode) {\\n          return;\\n        }\\n        var repeat = actionArgs.repeat || 1;\\n        var lineHeight = cm.defaultTextHeight();\\n        var top = cm.getScrollInfo().top;\\n        var delta = lineHeight * repeat;\\n        var newPos = actionArgs.forward ? top + delta : top - delta;\\n        var cursor = copyCursor(cm.getCursor());\\n        var cursorCoords = cm.charCoords(cursor, 'local');\\n        if (actionArgs.forward) {\\n          if (newPos > cursorCoords.top) {\\n             cursor.line += (newPos - cursorCoords.top) / lineHeight;\\n             cursor.line = Math.ceil(cursor.line);\\n             cm.setCursor(cursor);\\n             cursorCoords = cm.charCoords(cursor, 'local');\\n             cm.scrollTo(null, cursorCoords.top);\\n          } else {\\n             // Cursor stays within bounds.  Just reposition the scroll window.\\n             cm.scrollTo(null, newPos);\\n          }\\n        } else {\\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\\n          if (newBottom < cursorCoords.bottom) {\\n             cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\\n             cursor.line = Math.floor(cursor.line);\\n             cm.setCursor(cursor);\\n             cursorCoords = cm.charCoords(cursor, 'local');\\n             cm.scrollTo(\\n                 null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\\n          } else {\\n             // Cursor stays within bounds.  Just reposition the scroll window.\\n             cm.scrollTo(null, newPos);\\n          }\\n        }\\n      },\\n      scrollToCursor: function(cm, actionArgs) {\\n        var lineNum = cm.getCursor().line;\\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\\n        var height = cm.getScrollInfo().clientHeight;\\n        var y = charCoords.top;\\n        var lineHeight = charCoords.bottom - y;\\n        switch (actionArgs.position) {\\n          case 'center': y = y - (height / 2) + lineHeight;\\n            break;\\n          case 'bottom': y = y - height + lineHeight;\\n            break;\\n        }\\n        cm.scrollTo(null, y);\\n      },\\n      replayMacro: function(cm, actionArgs, vim) {\\n        var registerName = actionArgs.selectedCharacter;\\n        var repeat = actionArgs.repeat;\\n        var macroModeState = vimGlobalState.macroModeState;\\n        if (registerName == '@') {\\n          registerName = macroModeState.latestRegister;\\n        }\\n        while(repeat--){\\n          executeMacroRegister(cm, vim, macroModeState, registerName);\\n        }\\n      },\\n      enterMacroRecordMode: function(cm, actionArgs) {\\n        var macroModeState = vimGlobalState.macroModeState;\\n        var registerName = actionArgs.selectedCharacter;\\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\\n          macroModeState.enterMacroRecordMode(cm, registerName);\\n        }\\n      },\\n      toggleOverwrite: function(cm) {\\n        if (!cm.state.overwrite) {\\n          cm.toggleOverwrite(true);\\n          cm.setOption('keyMap', 'vim-replace');\\n          CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"replace\\\"});\\n        } else {\\n          cm.toggleOverwrite(false);\\n          cm.setOption('keyMap', 'vim-insert');\\n          CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"insert\\\"});\\n        }\\n      },\\n      enterInsertMode: function(cm, actionArgs, vim) {\\n        if (cm.getOption('readOnly')) { return; }\\n        vim.insertMode = true;\\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\\n        var insertAt = (actionArgs) ? actionArgs.insertAt : null;\\n        var sel = vim.sel;\\n        var head = actionArgs.head || cm.getCursor('head');\\n        var height = cm.listSelections().length;\\n        if (insertAt == 'eol') {\\n          head = Pos(head.line, lineLength(cm, head.line));\\n        } else if (insertAt == 'charAfter') {\\n          head = offsetCursor(head, 0, 1);\\n        } else if (insertAt == 'firstNonBlank') {\\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\\n        } else if (insertAt == 'startOfSelectedArea') {\\n          if (!vim.visualBlock) {\\n            if (sel.head.line < sel.anchor.line) {\\n              head = sel.head;\\n            } else {\\n              head = Pos(sel.anchor.line, 0);\\n            }\\n          } else {\\n            head = Pos(\\n                Math.min(sel.head.line, sel.anchor.line),\\n                Math.min(sel.head.ch, sel.anchor.ch));\\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\\n          }\\n        } else if (insertAt == 'endOfSelectedArea') {\\n          if (!vim.visualBlock) {\\n            if (sel.head.line >= sel.anchor.line) {\\n              head = offsetCursor(sel.head, 0, 1);\\n            } else {\\n              head = Pos(sel.anchor.line, 0);\\n            }\\n          } else {\\n            head = Pos(\\n                Math.min(sel.head.line, sel.anchor.line),\\n                Math.max(sel.head.ch + 1, sel.anchor.ch));\\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\\n          }\\n        } else if (insertAt == 'inplace') {\\n          if (vim.visualMode){\\n            return;\\n          }\\n        }\\n        cm.setOption('disableInput', false);\\n        if (actionArgs && actionArgs.replace) {\\n          // Handle Replace-mode as a special case of insert mode.\\n          cm.toggleOverwrite(true);\\n          cm.setOption('keyMap', 'vim-replace');\\n          CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"replace\\\"});\\n        } else {\\n          cm.toggleOverwrite(false);\\n          cm.setOption('keyMap', 'vim-insert');\\n          CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"insert\\\"});\\n        }\\n        if (!vimGlobalState.macroModeState.isPlaying) {\\n          // Only record if not replaying.\\n          cm.on('change', onChange);\\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\\n        }\\n        if (vim.visualMode) {\\n          exitVisualMode(cm);\\n        }\\n        selectForInsert(cm, head, height);\\n      },\\n      toggleVisualMode: function(cm, actionArgs, vim) {\\n        var repeat = actionArgs.repeat;\\n        var anchor = cm.getCursor();\\n        var head;\\n        // TODO: The repeat should actually select number of characters/lines\\n        //     equal to the repeat times the size of the previous visual\\n        //     operation.\\n        if (!vim.visualMode) {\\n          // Entering visual mode\\n          vim.visualMode = true;\\n          vim.visualLine = !!actionArgs.linewise;\\n          vim.visualBlock = !!actionArgs.blockwise;\\n          head = clipCursorToContent(\\n              cm, Pos(anchor.line, anchor.ch + repeat - 1),\\n              true /** includeLineBreak */);\\n          vim.sel = {\\n            anchor: anchor,\\n            head: head\\n          };\\n          CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"visual\\\", subMode: vim.visualLine ? \\\"linewise\\\" : vim.visualBlock ? \\\"blockwise\\\" : \\\"\\\"});\\n          updateCmSelection(cm);\\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\\n        } else if (vim.visualLine ^ actionArgs.linewise ||\\n            vim.visualBlock ^ actionArgs.blockwise) {\\n          // Toggling between modes\\n          vim.visualLine = !!actionArgs.linewise;\\n          vim.visualBlock = !!actionArgs.blockwise;\\n          CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"visual\\\", subMode: vim.visualLine ? \\\"linewise\\\" : vim.visualBlock ? \\\"blockwise\\\" : \\\"\\\"});\\n          updateCmSelection(cm);\\n        } else {\\n          exitVisualMode(cm);\\n        }\\n      },\\n      reselectLastSelection: function(cm, _actionArgs, vim) {\\n        var lastSelection = vim.lastSelection;\\n        if (vim.visualMode) {\\n          updateLastSelection(cm, vim);\\n        }\\n        if (lastSelection) {\\n          var anchor = lastSelection.anchorMark.find();\\n          var head = lastSelection.headMark.find();\\n          if (!anchor || !head) {\\n            // If the marks have been destroyed due to edits, do nothing.\\n            return;\\n          }\\n          vim.sel = {\\n            anchor: anchor,\\n            head: head\\n          };\\n          vim.visualMode = true;\\n          vim.visualLine = lastSelection.visualLine;\\n          vim.visualBlock = lastSelection.visualBlock;\\n          updateCmSelection(cm);\\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\\n          CodeMirror.signal(cm, 'vim-mode-change', {\\n            mode: 'visual',\\n            subMode: vim.visualLine ? 'linewise' :\\n                     vim.visualBlock ? 'blockwise' : ''});\\n        }\\n      },\\n      joinLines: function(cm, actionArgs, vim) {\\n        var curStart, curEnd;\\n        if (vim.visualMode) {\\n          curStart = cm.getCursor('anchor');\\n          curEnd = cm.getCursor('head');\\n          if (cursorIsBefore(curEnd, curStart)) {\\n            var tmp = curEnd;\\n            curEnd = curStart;\\n            curStart = tmp;\\n          }\\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\\n        } else {\\n          // Repeat is the number of lines to join. Minimum 2 lines.\\n          var repeat = Math.max(actionArgs.repeat, 2);\\n          curStart = cm.getCursor();\\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1,\\n                                               Infinity));\\n        }\\n        var finalCh = 0;\\n        for (var i = curStart.line; i < curEnd.line; i++) {\\n          finalCh = lineLength(cm, curStart.line);\\n          var tmp = Pos(curStart.line + 1,\\n                        lineLength(cm, curStart.line + 1));\\n          var text = cm.getRange(curStart, tmp);\\n          text = text.replace(/\\\\n\\\\s*/g, ' ');\\n          cm.replaceRange(text, curStart, tmp);\\n        }\\n        var curFinalPos = Pos(curStart.line, finalCh);\\n        if (vim.visualMode) {\\n          exitVisualMode(cm, false);\\n        }\\n        cm.setCursor(curFinalPos);\\n      },\\n      newLineAndEnterInsertMode: function(cm, actionArgs, vim) {\\n        vim.insertMode = true;\\n        var insertAt = copyCursor(cm.getCursor());\\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\\n          // Special case for inserting newline before start of document.\\n          cm.replaceRange('\\\\n', Pos(cm.firstLine(), 0));\\n          cm.setCursor(cm.firstLine(), 0);\\n        } else {\\n          insertAt.line = (actionArgs.after) ? insertAt.line :\\n              insertAt.line - 1;\\n          insertAt.ch = lineLength(cm, insertAt.line);\\n          cm.setCursor(insertAt);\\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment ||\\n              CodeMirror.commands.newlineAndIndent;\\n          newlineFn(cm);\\n        }\\n        this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\\n      },\\n      paste: function(cm, actionArgs, vim) {\\n        var cur = copyCursor(cm.getCursor());\\n        var register = vimGlobalState.registerController.getRegister(\\n            actionArgs.registerName);\\n        var text = register.toString();\\n        if (!text) {\\n          return;\\n        }\\n        if (actionArgs.matchIndent) {\\n          var tabSize = cm.getOption(\\\"tabSize\\\");\\n          // length that considers tabs and tabSize\\n          var whitespaceLength = function(str) {\\n            var tabs = (str.split(\\\"\\\\t\\\").length - 1);\\n            var spaces = (str.split(\\\" \\\").length - 1);\\n            return tabs * tabSize + spaces * 1;\\n          };\\n          var currentLine = cm.getLine(cm.getCursor().line);\\n          var indent = whitespaceLength(currentLine.match(/^\\\\s*/)[0]);\\n          // chomp last newline b/c don't want it to match /^\\\\s*/gm\\n          var chompedText = text.replace(/\\\\n$/, '');\\n          var wasChomped = text !== chompedText;\\n          var firstIndent = whitespaceLength(text.match(/^\\\\s*/)[0]);\\n          var text = chompedText.replace(/^\\\\s*/gm, function(wspace) {\\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\\n            if (newIndent < 0) {\\n              return \\\"\\\";\\n            }\\n            else if (cm.getOption(\\\"indentWithTabs\\\")) {\\n              var quotient = Math.floor(newIndent / tabSize);\\n              return Array(quotient + 1).join('\\\\t');\\n            }\\n            else {\\n              return Array(newIndent + 1).join(' ');\\n            }\\n          });\\n          text += wasChomped ? \\\"\\\\n\\\" : \\\"\\\";\\n        }\\n        if (actionArgs.repeat > 1) {\\n          var text = Array(actionArgs.repeat + 1).join(text);\\n        }\\n        var linewise = register.linewise;\\n        var blockwise = register.blockwise;\\n        if (linewise) {\\n          if(vim.visualMode) {\\n            text = vim.visualLine ? text.slice(0, -1) : '\\\\n' + text.slice(0, text.length - 1) + '\\\\n';\\n          } else if (actionArgs.after) {\\n            // Move the newline at the end to the start instead, and paste just\\n            // before the newline character of the line we are on right now.\\n            text = '\\\\n' + text.slice(0, text.length - 1);\\n            cur.ch = lineLength(cm, cur.line);\\n          } else {\\n            cur.ch = 0;\\n          }\\n        } else {\\n          if (blockwise) {\\n            text = text.split('\\\\n');\\n            for (var i = 0; i < text.length; i++) {\\n              text[i] = (text[i] == '') ? ' ' : text[i];\\n            }\\n          }\\n          cur.ch += actionArgs.after ? 1 : 0;\\n        }\\n        var curPosFinal;\\n        var idx;\\n        if (vim.visualMode) {\\n          //  save the pasted text for reselection if the need arises\\n          vim.lastPastedText = text;\\n          var lastSelectionCurEnd;\\n          var selectedArea = getSelectedAreaRange(cm, vim);\\n          var selectionStart = selectedArea[0];\\n          var selectionEnd = selectedArea[1];\\n          var selectedText = cm.getSelection();\\n          var selections = cm.listSelections();\\n          var emptyStrings = new Array(selections.length).join('1').split('1');\\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\\n          if (vim.lastSelection) {\\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\\n          }\\n          // push the previously selected text to unnamed register\\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\\n          if (blockwise) {\\n            // first delete the selected text\\n            cm.replaceSelections(emptyStrings);\\n            // Set new selections as per the block length of the yanked text\\n            selectionEnd = Pos(selectionStart.line + text.length-1, selectionStart.ch);\\n            cm.setCursor(selectionStart);\\n            selectBlock(cm, selectionEnd);\\n            cm.replaceSelections(text);\\n            curPosFinal = selectionStart;\\n          } else if (vim.visualBlock) {\\n            cm.replaceSelections(emptyStrings);\\n            cm.setCursor(selectionStart);\\n            cm.replaceRange(text, selectionStart, selectionStart);\\n            curPosFinal = selectionStart;\\n          } else {\\n            cm.replaceRange(text, selectionStart, selectionEnd);\\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\\n          }\\n          // restore the the curEnd marker\\n          if(lastSelectionCurEnd) {\\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\\n          }\\n          if (linewise) {\\n            curPosFinal.ch=0;\\n          }\\n        } else {\\n          if (blockwise) {\\n            cm.setCursor(cur);\\n            for (var i = 0; i < text.length; i++) {\\n              var line = cur.line+i;\\n              if (line > cm.lastLine()) {\\n                cm.replaceRange('\\\\n',  Pos(line, 0));\\n              }\\n              var lastCh = lineLength(cm, line);\\n              if (lastCh < cur.ch) {\\n                extendLineToColumn(cm, line, cur.ch);\\n              }\\n            }\\n            cm.setCursor(cur);\\n            selectBlock(cm, Pos(cur.line + text.length-1, cur.ch));\\n            cm.replaceSelections(text);\\n            curPosFinal = cur;\\n          } else {\\n            cm.replaceRange(text, cur);\\n            // Now fine tune the cursor to where we want it.\\n            if (linewise && actionArgs.after) {\\n              curPosFinal = Pos(\\n              cur.line + 1,\\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\\n            } else if (linewise && !actionArgs.after) {\\n              curPosFinal = Pos(\\n                cur.line,\\n                findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\\n            } else if (!linewise && actionArgs.after) {\\n              idx = cm.indexFromPos(cur);\\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\\n            } else {\\n              idx = cm.indexFromPos(cur);\\n              curPosFinal = cm.posFromIndex(idx + text.length);\\n            }\\n          }\\n        }\\n        if (vim.visualMode) {\\n          exitVisualMode(cm, false);\\n        }\\n        cm.setCursor(curPosFinal);\\n      },\\n      undo: function(cm, actionArgs) {\\n        cm.operation(function() {\\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\\n          cm.setCursor(cm.getCursor('anchor'));\\n        });\\n      },\\n      redo: function(cm, actionArgs) {\\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\\n      },\\n      setRegister: function(_cm, actionArgs, vim) {\\n        vim.inputState.registerName = actionArgs.selectedCharacter;\\n      },\\n      setMark: function(cm, actionArgs, vim) {\\n        var markName = actionArgs.selectedCharacter;\\n        updateMark(cm, vim, markName, cm.getCursor());\\n      },\\n      replace: function(cm, actionArgs, vim) {\\n        var replaceWith = actionArgs.selectedCharacter;\\n        var curStart = cm.getCursor();\\n        var replaceTo;\\n        var curEnd;\\n        var selections = cm.listSelections();\\n        if (vim.visualMode) {\\n          curStart = cm.getCursor('start');\\n          curEnd = cm.getCursor('end');\\n        } else {\\n          var line = cm.getLine(curStart.line);\\n          replaceTo = curStart.ch + actionArgs.repeat;\\n          if (replaceTo > line.length) {\\n            replaceTo=line.length;\\n          }\\n          curEnd = Pos(curStart.line, replaceTo);\\n        }\\n        if (replaceWith=='\\\\n') {\\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\\n          // special case, where vim help says to replace by just one line-break\\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\\n        } else {\\n          var replaceWithStr = cm.getRange(curStart, curEnd);\\n          //replace all characters in range by selected, but keep linebreaks\\n          replaceWithStr = replaceWithStr.replace(/[^\\\\n]/g, replaceWith);\\n          if (vim.visualBlock) {\\n            // Tabs are split in visua block before replacing\\n            var spaces = new Array(cm.getOption(\\\"tabSize\\\")+1).join(' ');\\n            replaceWithStr = cm.getSelection();\\n            replaceWithStr = replaceWithStr.replace(/\\\\t/g, spaces).replace(/[^\\\\n]/g, replaceWith).split('\\\\n');\\n            cm.replaceSelections(replaceWithStr);\\n          } else {\\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\\n          }\\n          if (vim.visualMode) {\\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ?\\n                         selections[0].anchor : selections[0].head;\\n            cm.setCursor(curStart);\\n            exitVisualMode(cm, false);\\n          } else {\\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\\n          }\\n        }\\n      },\\n      incrementNumberToken: function(cm, actionArgs) {\\n        var cur = cm.getCursor();\\n        var lineStr = cm.getLine(cur.line);\\n        var re = /(-?)(?:(0x)([\\\\da-f]+)|(0b|0|)(\\\\d+))/gi;\\n        var match;\\n        var start;\\n        var end;\\n        var numberStr;\\n        while ((match = re.exec(lineStr)) !== null) {\\n          start = match.index;\\n          end = start + match[0].length;\\n          if (cur.ch < end)break;\\n        }\\n        if (!actionArgs.backtrack && (end <= cur.ch))return;\\n        if (match) {\\n          var baseStr = match[2] || match[4]\\n          var digits = match[3] || match[5]\\n          var increment = actionArgs.increase ? 1 : -1;\\n          var base = {'0b': 2, '0': 8, '': 10, '0x': 16}[baseStr.toLowerCase()];\\n          var number = parseInt(match[1] + digits, base) + (increment * actionArgs.repeat);\\n          numberStr = number.toString(base);\\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : ''\\n          if (numberStr.charAt(0) === '-') {\\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\\n          } else {\\n            numberStr = baseStr + zeroPadding + numberStr;\\n          }\\n          var from = Pos(cur.line, start);\\n          var to = Pos(cur.line, end);\\n          cm.replaceRange(numberStr, from, to);\\n        } else {\\n          return;\\n        }\\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\\n      },\\n      repeatLastEdit: function(cm, actionArgs, vim) {\\n        var lastEditInputState = vim.lastEditInputState;\\n        if (!lastEditInputState) { return; }\\n        var repeat = actionArgs.repeat;\\n        if (repeat && actionArgs.repeatIsExplicit) {\\n          vim.lastEditInputState.repeatOverride = repeat;\\n        } else {\\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\\n        }\\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\\n      },\\n      indent: function(cm, actionArgs) {\\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\\n      },\\n      exitInsertMode: exitInsertMode\\n    };\\n\\n    function defineAction(name, fn) {\\n      actions[name] = fn;\\n    }\\n\\n    /*\\n     * Below are miscellaneous utility functions used by vim.js\\n     */\\n\\n    /**\\n     * Clips cursor to ensure that line is within the buffer's range\\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\\n     */\\n    function clipCursorToContent(cm, cur, includeLineBreak) {\\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine() );\\n      var maxCh = lineLength(cm, line) - 1;\\n      maxCh = (includeLineBreak) ? maxCh + 1 : maxCh;\\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\\n      return Pos(line, ch);\\n    }\\n    function copyArgs(args) {\\n      var ret = {};\\n      for (var prop in args) {\\n        if (args.hasOwnProperty(prop)) {\\n          ret[prop] = args[prop];\\n        }\\n      }\\n      return ret;\\n    }\\n    function offsetCursor(cur, offsetLine, offsetCh) {\\n      if (typeof offsetLine === 'object') {\\n        offsetCh = offsetLine.ch;\\n        offsetLine = offsetLine.line;\\n      }\\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\\n    }\\n    function getOffset(anchor, head) {\\n      return {\\n        line: head.line - anchor.line,\\n        ch: head.line - anchor.line\\n      };\\n    }\\n    function commandMatches(keys, keyMap, context, inputState) {\\n      // Partial matches are not applied. They inform the key handler\\n      // that the current key sequence is a subsequence of a valid key\\n      // sequence, so that the key buffer is not cleared.\\n      var match, partial = [], full = [];\\n      for (var i = 0; i < keyMap.length; i++) {\\n        var command = keyMap[i];\\n        if (context == 'insert' && command.context != 'insert' ||\\n            command.context && command.context != context ||\\n            inputState.operator && command.type == 'action' ||\\n            !(match = commandMatch(keys, command.keys))) { continue; }\\n        if (match == 'partial') { partial.push(command); }\\n        if (match == 'full') { full.push(command); }\\n      }\\n      return {\\n        partial: partial.length && partial,\\n        full: full.length && full\\n      };\\n    }\\n    function commandMatch(pressed, mapped) {\\n      if (mapped.slice(-11) == '<character>') {\\n        // Last character matches anything.\\n        var prefixLen = mapped.length - 11;\\n        var pressedPrefix = pressed.slice(0, prefixLen);\\n        var mappedPrefix = mapped.slice(0, prefixLen);\\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' :\\n               mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\\n      } else {\\n        return pressed == mapped ? 'full' :\\n               mapped.indexOf(pressed) == 0 ? 'partial' : false;\\n      }\\n    }\\n    function lastChar(keys) {\\n      var match = /^.*(<[^>]+>)$/.exec(keys);\\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\\n      if (selectedCharacter.length > 1){\\n        switch(selectedCharacter){\\n          case '<CR>':\\n            selectedCharacter='\\\\n';\\n            break;\\n          case '<Space>':\\n            selectedCharacter=' ';\\n            break;\\n          default:\\n            selectedCharacter='';\\n            break;\\n        }\\n      }\\n      return selectedCharacter;\\n    }\\n    function repeatFn(cm, fn, repeat) {\\n      return function() {\\n        for (var i = 0; i < repeat; i++) {\\n          fn(cm);\\n        }\\n      };\\n    }\\n    function copyCursor(cur) {\\n      return Pos(cur.line, cur.ch);\\n    }\\n    function cursorEqual(cur1, cur2) {\\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\\n    }\\n    function cursorIsBefore(cur1, cur2) {\\n      if (cur1.line < cur2.line) {\\n        return true;\\n      }\\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\\n        return true;\\n      }\\n      return false;\\n    }\\n    function cursorMin(cur1, cur2) {\\n      if (arguments.length > 2) {\\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\\n      }\\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\\n    }\\n    function cursorMax(cur1, cur2) {\\n      if (arguments.length > 2) {\\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\\n      }\\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\\n    }\\n    function cursorIsBetween(cur1, cur2, cur3) {\\n      // returns true if cur2 is between cur1 and cur3.\\n      var cur1before2 = cursorIsBefore(cur1, cur2);\\n      var cur2before3 = cursorIsBefore(cur2, cur3);\\n      return cur1before2 && cur2before3;\\n    }\\n    function lineLength(cm, lineNum) {\\n      return cm.getLine(lineNum).length;\\n    }\\n    function trim(s) {\\n      if (s.trim) {\\n        return s.trim();\\n      }\\n      return s.replace(/^\\\\s+|\\\\s+$/g, '');\\n    }\\n    function escapeRegex(s) {\\n      return s.replace(/([.?*+$\\\\[\\\\]\\\\/\\\\\\\\(){}|\\\\-])/g, '\\\\\\\\$1');\\n    }\\n    function extendLineToColumn(cm, lineNum, column) {\\n      var endCh = lineLength(cm, lineNum);\\n      var spaces = new Array(column-endCh+1).join(' ');\\n      cm.setCursor(Pos(lineNum, endCh));\\n      cm.replaceRange(spaces, cm.getCursor());\\n    }\\n    // This functions selects a rectangular block\\n    // of text with selectionEnd as any of its corner\\n    // Height of block:\\n    // Difference in selectionEnd.line and first/last selection.line\\n    // Width of the block:\\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\\n    function selectBlock(cm, selectionEnd) {\\n      var selections = [], ranges = cm.listSelections();\\n      var head = copyCursor(cm.clipPos(selectionEnd));\\n      var isClipped = !cursorEqual(selectionEnd, head);\\n      var curHead = cm.getCursor('head');\\n      var primIndex = getIndex(ranges, curHead);\\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\\n      var max = ranges.length - 1;\\n      var index = max - primIndex > primIndex ? max : 0;\\n      var base = ranges[index].anchor;\\n\\n      var firstLine = Math.min(base.line, head.line);\\n      var lastLine = Math.max(base.line, head.line);\\n      var baseCh = base.ch, headCh = head.ch;\\n\\n      var dir = ranges[index].head.ch - baseCh;\\n      var newDir = headCh - baseCh;\\n      if (dir > 0 && newDir <= 0) {\\n        baseCh++;\\n        if (!isClipped) { headCh--; }\\n      } else if (dir < 0 && newDir >= 0) {\\n        baseCh--;\\n        if (!wasClipped) { headCh++; }\\n      } else if (dir < 0 && newDir == -1) {\\n        baseCh--;\\n        headCh++;\\n      }\\n      for (var line = firstLine; line <= lastLine; line++) {\\n        var range = {anchor: new Pos(line, baseCh), head: new Pos(line, headCh)};\\n        selections.push(range);\\n      }\\n      cm.setSelections(selections);\\n      selectionEnd.ch = headCh;\\n      base.ch = baseCh;\\n      return base;\\n    }\\n    function selectForInsert(cm, head, height) {\\n      var sel = [];\\n      for (var i = 0; i < height; i++) {\\n        var lineHead = offsetCursor(head, i, 0);\\n        sel.push({anchor: lineHead, head: lineHead});\\n      }\\n      cm.setSelections(sel, 0);\\n    }\\n    // getIndex returns the index of the cursor in the selections.\\n    function getIndex(ranges, cursor, end) {\\n      for (var i = 0; i < ranges.length; i++) {\\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\\n        if (atAnchor || atHead) {\\n          return i;\\n        }\\n      }\\n      return -1;\\n    }\\n    function getSelectedAreaRange(cm, vim) {\\n      var lastSelection = vim.lastSelection;\\n      var getCurrentSelectedAreaRange = function() {\\n        var selections = cm.listSelections();\\n        var start =  selections[0];\\n        var end = selections[selections.length-1];\\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\\n        return [selectionStart, selectionEnd];\\n      };\\n      var getLastSelectedAreaRange = function() {\\n        var selectionStart = cm.getCursor();\\n        var selectionEnd = cm.getCursor();\\n        var block = lastSelection.visualBlock;\\n        if (block) {\\n          var width = block.width;\\n          var height = block.height;\\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\\n          var selections = [];\\n          // selectBlock creates a 'proper' rectangular block.\\n          // We do not want that in all cases, so we manually set selections.\\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\\n            var anchor = Pos(i, selectionStart.ch);\\n            var head = Pos(i, selectionEnd.ch);\\n            var range = {anchor: anchor, head: head};\\n            selections.push(range);\\n          }\\n          cm.setSelections(selections);\\n        } else {\\n          var start = lastSelection.anchorMark.find();\\n          var end = lastSelection.headMark.find();\\n          var line = end.line - start.line;\\n          var ch = end.ch - start.ch;\\n          selectionEnd = {line: selectionEnd.line + line, ch: line ? selectionEnd.ch : ch + selectionEnd.ch};\\n          if (lastSelection.visualLine) {\\n            selectionStart = Pos(selectionStart.line, 0);\\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\\n          }\\n          cm.setSelection(selectionStart, selectionEnd);\\n        }\\n        return [selectionStart, selectionEnd];\\n      };\\n      if (!vim.visualMode) {\\n      // In case of replaying the action.\\n        return getLastSelectedAreaRange();\\n      } else {\\n        return getCurrentSelectedAreaRange();\\n      }\\n    }\\n    // Updates the previous selection with the current selection's values. This\\n    // should only be called in visual mode.\\n    function updateLastSelection(cm, vim) {\\n      var anchor = vim.sel.anchor;\\n      var head = vim.sel.head;\\n      // To accommodate the effect of lastPastedText in the last selection\\n      if (vim.lastPastedText) {\\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\\n        vim.lastPastedText = null;\\n      }\\n      vim.lastSelection = {'anchorMark': cm.setBookmark(anchor),\\n                           'headMark': cm.setBookmark(head),\\n                           'anchor': copyCursor(anchor),\\n                           'head': copyCursor(head),\\n                           'visualMode': vim.visualMode,\\n                           'visualLine': vim.visualLine,\\n                           'visualBlock': vim.visualBlock};\\n    }\\n    function expandSelection(cm, start, end) {\\n      var sel = cm.state.vim.sel;\\n      var head = sel.head;\\n      var anchor = sel.anchor;\\n      var tmp;\\n      if (cursorIsBefore(end, start)) {\\n        tmp = end;\\n        end = start;\\n        start = tmp;\\n      }\\n      if (cursorIsBefore(head, anchor)) {\\n        head = cursorMin(start, head);\\n        anchor = cursorMax(anchor, end);\\n      } else {\\n        anchor = cursorMin(start, anchor);\\n        head = cursorMax(head, end);\\n        head = offsetCursor(head, 0, -1);\\n        if (head.ch == -1 && head.line != cm.firstLine()) {\\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\\n        }\\n      }\\n      return [anchor, head];\\n    }\\n    /**\\n     * Updates the CodeMirror selection to match the provided vim selection.\\n     * If no arguments are given, it uses the current vim selection state.\\n     */\\n    function updateCmSelection(cm, sel, mode) {\\n      var vim = cm.state.vim;\\n      sel = sel || vim.sel;\\n      var mode = mode ||\\n        vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\\n      var cmSel = makeCmSelection(cm, sel, mode);\\n      cm.setSelections(cmSel.ranges, cmSel.primary);\\n      updateFakeCursor(cm);\\n    }\\n    function makeCmSelection(cm, sel, mode, exclusive) {\\n      var head = copyCursor(sel.head);\\n      var anchor = copyCursor(sel.anchor);\\n      if (mode == 'char') {\\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\\n        head = offsetCursor(sel.head, 0, headOffset);\\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\\n        return {\\n          ranges: [{anchor: anchor, head: head}],\\n          primary: 0\\n        };\\n      } else if (mode == 'line') {\\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\\n          anchor.ch = 0;\\n\\n          var lastLine = cm.lastLine();\\n          if (head.line > lastLine) {\\n            head.line = lastLine;\\n          }\\n          head.ch = lineLength(cm, head.line);\\n        } else {\\n          head.ch = 0;\\n          anchor.ch = lineLength(cm, anchor.line);\\n        }\\n        return {\\n          ranges: [{anchor: anchor, head: head}],\\n          primary: 0\\n        };\\n      } else if (mode == 'block') {\\n        var top = Math.min(anchor.line, head.line),\\n            left = Math.min(anchor.ch, head.ch),\\n            bottom = Math.max(anchor.line, head.line),\\n            right = Math.max(anchor.ch, head.ch) + 1;\\n        var height = bottom - top + 1;\\n        var primary = head.line == top ? 0 : height - 1;\\n        var ranges = [];\\n        for (var i = 0; i < height; i++) {\\n          ranges.push({\\n            anchor: Pos(top + i, left),\\n            head: Pos(top + i, right)\\n          });\\n        }\\n        return {\\n          ranges: ranges,\\n          primary: primary\\n        };\\n      }\\n    }\\n    function getHead(cm) {\\n      var cur = cm.getCursor('head');\\n      if (cm.getSelection().length == 1) {\\n        // Small corner case when only 1 character is selected. The \\\"real\\\"\\n        // head is the left of head and anchor.\\n        cur = cursorMin(cur, cm.getCursor('anchor'));\\n      }\\n      return cur;\\n    }\\n\\n    /**\\n     * If moveHead is set to false, the CodeMirror selection will not be\\n     * touched. The caller assumes the responsibility of putting the cursor\\n    * in the right place.\\n     */\\n    function exitVisualMode(cm, moveHead) {\\n      var vim = cm.state.vim;\\n      if (moveHead !== false) {\\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\\n      }\\n      updateLastSelection(cm, vim);\\n      vim.visualMode = false;\\n      vim.visualLine = false;\\n      vim.visualBlock = false;\\n      CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"normal\\\"});\\n      if (vim.fakeCursor) {\\n        vim.fakeCursor.clear();\\n      }\\n    }\\n\\n    // Remove any trailing newlines from the selection. For\\n    // example, with the caret at the start of the last word on the line,\\n    // 'dw' should word, but not the newline, while 'w' should advance the\\n    // caret to the first character of the next line.\\n    function clipToLine(cm, curStart, curEnd) {\\n      var selection = cm.getRange(curStart, curEnd);\\n      // Only clip if the selection ends with trailing newline + whitespace\\n      if (/\\\\n\\\\s*$/.test(selection)) {\\n        var lines = selection.split('\\\\n');\\n        // We know this is all whitespace.\\n        lines.pop();\\n\\n        // Cases:\\n        // 1. Last word is an empty line - do not clip the trailing '\\\\n'\\n        // 2. Last word is not an empty line - clip the trailing '\\\\n'\\n        var line;\\n        // Find the line containing the last word, and clip all whitespace up\\n        // to it.\\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\\n          curEnd.line--;\\n          curEnd.ch = 0;\\n        }\\n        // If the last word is not an empty line, clip an additional newline\\n        if (line) {\\n          curEnd.line--;\\n          curEnd.ch = lineLength(cm, curEnd.line);\\n        } else {\\n          curEnd.ch = 0;\\n        }\\n      }\\n    }\\n\\n    // Expand the selection to line ends.\\n    function expandSelectionToLine(_cm, curStart, curEnd) {\\n      curStart.ch = 0;\\n      curEnd.ch = 0;\\n      curEnd.line++;\\n    }\\n\\n    function findFirstNonWhiteSpaceCharacter(text) {\\n      if (!text) {\\n        return 0;\\n      }\\n      var firstNonWS = text.search(/\\\\S/);\\n      return firstNonWS == -1 ? text.length : firstNonWS;\\n    }\\n\\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\\n      var cur = getHead(cm);\\n      var line = cm.getLine(cur.line);\\n      var idx = cur.ch;\\n\\n      // Seek to first word or non-whitespace character, depending on if\\n      // noSymbol is true.\\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest [0];\\n      while (!test(line.charAt(idx))) {\\n        idx++;\\n        if (idx >= line.length) { return null; }\\n      }\\n\\n      if (bigWord) {\\n        test = bigWordCharTest[0];\\n      } else {\\n        test = wordCharTest[0];\\n        if (!test(line.charAt(idx))) {\\n          test = wordCharTest[1];\\n        }\\n      }\\n\\n      var end = idx, start = idx;\\n      while (test(line.charAt(end)) && end < line.length) { end++; }\\n      while (test(line.charAt(start)) && start >= 0) { start--; }\\n      start++;\\n\\n      if (inclusive) {\\n        // If present, include all whitespace after word.\\n        // Otherwise, include all whitespace before word, except indentation.\\n        var wordEnd = end;\\n        while (/\\\\s/.test(line.charAt(end)) && end < line.length) { end++; }\\n        if (wordEnd == end) {\\n          var wordStart = start;\\n          while (/\\\\s/.test(line.charAt(start - 1)) && start > 0) { start--; }\\n          if (!start) { start = wordStart; }\\n        }\\n      }\\n      return { start: Pos(cur.line, start), end: Pos(cur.line, end) };\\n    }\\n\\n    function recordJumpPosition(cm, oldCur, newCur) {\\n      if (!cursorEqual(oldCur, newCur)) {\\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\\n      }\\n    }\\n\\n    function recordLastCharacterSearch(increment, args) {\\n        vimGlobalState.lastCharacterSearch.increment = increment;\\n        vimGlobalState.lastCharacterSearch.forward = args.forward;\\n        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\\n    }\\n\\n    var symbolToMode = {\\n        '(': 'bracket', ')': 'bracket', '{': 'bracket', '}': 'bracket',\\n        '[': 'section', ']': 'section',\\n        '*': 'comment', '/': 'comment',\\n        'm': 'method', 'M': 'method',\\n        '#': 'preprocess'\\n    };\\n    var findSymbolModes = {\\n      bracket: {\\n        isComplete: function(state) {\\n          if (state.nextCh === state.symb) {\\n            state.depth++;\\n            if (state.depth >= 1)return true;\\n          } else if (state.nextCh === state.reverseSymb) {\\n            state.depth--;\\n          }\\n          return false;\\n        }\\n      },\\n      section: {\\n        init: function(state) {\\n          state.curMoveThrough = true;\\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\\n        },\\n        isComplete: function(state) {\\n          return state.index === 0 && state.nextCh === state.symb;\\n        }\\n      },\\n      comment: {\\n        isComplete: function(state) {\\n          var found = state.lastCh === '*' && state.nextCh === '/';\\n          state.lastCh = state.nextCh;\\n          return found;\\n        }\\n      },\\n      // TODO: The original Vim implementation only operates on level 1 and 2.\\n      // The current implementation doesn't check for code block level and\\n      // therefore it operates on any levels.\\n      method: {\\n        init: function(state) {\\n          state.symb = (state.symb === 'm' ? '{' : '}');\\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\\n        },\\n        isComplete: function(state) {\\n          if (state.nextCh === state.symb)return true;\\n          return false;\\n        }\\n      },\\n      preprocess: {\\n        init: function(state) {\\n          state.index = 0;\\n        },\\n        isComplete: function(state) {\\n          if (state.nextCh === '#') {\\n            var token = state.lineText.match(/#(\\\\w+)/)[1];\\n            if (token === 'endif') {\\n              if (state.forward && state.depth === 0) {\\n                return true;\\n              }\\n              state.depth++;\\n            } else if (token === 'if') {\\n              if (!state.forward && state.depth === 0) {\\n                return true;\\n              }\\n              state.depth--;\\n            }\\n            if (token === 'else' && state.depth === 0)return true;\\n          }\\n          return false;\\n        }\\n      }\\n    };\\n    function findSymbol(cm, repeat, forward, symb) {\\n      var cur = copyCursor(cm.getCursor());\\n      var increment = forward ? 1 : -1;\\n      var endLine = forward ? cm.lineCount() : -1;\\n      var curCh = cur.ch;\\n      var line = cur.line;\\n      var lineText = cm.getLine(line);\\n      var state = {\\n        lineText: lineText,\\n        nextCh: lineText.charAt(curCh),\\n        lastCh: null,\\n        index: curCh,\\n        symb: symb,\\n        reverseSymb: (forward ?  { ')': '(', '}': '{' } : { '(': ')', '{': '}' })[symb],\\n        forward: forward,\\n        depth: 0,\\n        curMoveThrough: false\\n      };\\n      var mode = symbolToMode[symb];\\n      if (!mode)return cur;\\n      var init = findSymbolModes[mode].init;\\n      var isComplete = findSymbolModes[mode].isComplete;\\n      if (init) { init(state); }\\n      while (line !== endLine && repeat) {\\n        state.index += increment;\\n        state.nextCh = state.lineText.charAt(state.index);\\n        if (!state.nextCh) {\\n          line += increment;\\n          state.lineText = cm.getLine(line) || '';\\n          if (increment > 0) {\\n            state.index = 0;\\n          } else {\\n            var lineLen = state.lineText.length;\\n            state.index = (lineLen > 0) ? (lineLen-1) : 0;\\n          }\\n          state.nextCh = state.lineText.charAt(state.index);\\n        }\\n        if (isComplete(state)) {\\n          cur.line = line;\\n          cur.ch = state.index;\\n          repeat--;\\n        }\\n      }\\n      if (state.nextCh || state.curMoveThrough) {\\n        return Pos(line, state.index);\\n      }\\n      return cur;\\n    }\\n\\n    /*\\n     * Returns the boundaries of the next word. If the cursor in the middle of\\n     * the word, then returns the boundaries of the current word, starting at\\n     * the cursor. If the cursor is at the start/end of a word, and we are going\\n     * forward/backward, respectively, find the boundaries of the next word.\\n     *\\n     * @param {CodeMirror} cm CodeMirror object.\\n     * @param {Cursor} cur The cursor position.\\n     * @param {boolean} forward True to search forward. False to search\\n     *     backward.\\n     * @param {boolean} bigWord True if punctuation count as part of the word.\\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\\n     *     as words.\\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\\n     *     the word, or null if there are no more words.\\n     */\\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\\n      var lineNum = cur.line;\\n      var pos = cur.ch;\\n      var line = cm.getLine(lineNum);\\n      var dir = forward ? 1 : -1;\\n      var charTests = bigWord ? bigWordCharTest: wordCharTest;\\n\\n      if (emptyLineIsWord && line == '') {\\n        lineNum += dir;\\n        line = cm.getLine(lineNum);\\n        if (!isLine(cm, lineNum)) {\\n          return null;\\n        }\\n        pos = (forward) ? 0 : line.length;\\n      }\\n\\n      while (true) {\\n        if (emptyLineIsWord && line == '') {\\n          return { from: 0, to: 0, line: lineNum };\\n        }\\n        var stop = (dir > 0) ? line.length : -1;\\n        var wordStart = stop, wordEnd = stop;\\n        // Find bounds of next word.\\n        while (pos != stop) {\\n          var foundWord = false;\\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\\n            if (charTests[i](line.charAt(pos))) {\\n              wordStart = pos;\\n              // Advance to end of word.\\n              while (pos != stop && charTests[i](line.charAt(pos))) {\\n                pos += dir;\\n              }\\n              wordEnd = pos;\\n              foundWord = wordStart != wordEnd;\\n              if (wordStart == cur.ch && lineNum == cur.line &&\\n                  wordEnd == wordStart + dir) {\\n                // We started at the end of a word. Find the next one.\\n                continue;\\n              } else {\\n                return {\\n                  from: Math.min(wordStart, wordEnd + 1),\\n                  to: Math.max(wordStart, wordEnd),\\n                  line: lineNum };\\n              }\\n            }\\n          }\\n          if (!foundWord) {\\n            pos += dir;\\n          }\\n        }\\n        // Advance to next/prev line.\\n        lineNum += dir;\\n        if (!isLine(cm, lineNum)) {\\n          return null;\\n        }\\n        line = cm.getLine(lineNum);\\n        pos = (dir > 0) ? 0 : line.length;\\n      }\\n    }\\n\\n    /**\\n     * @param {CodeMirror} cm CodeMirror object.\\n     * @param {Pos} cur The position to start from.\\n     * @param {int} repeat Number of words to move past.\\n     * @param {boolean} forward True to search forward. False to search\\n     *     backward.\\n     * @param {boolean} wordEnd True to move to end of word. False to move to\\n     *     beginning of word.\\n     * @param {boolean} bigWord True if punctuation count as part of the word.\\n     *     False if only alphabet characters count as part of the word.\\n     * @return {Cursor} The position the cursor should move to.\\n     */\\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\\n      var curStart = copyCursor(cur);\\n      var words = [];\\n      if (forward && !wordEnd || !forward && wordEnd) {\\n        repeat++;\\n      }\\n      // For 'e', empty lines are not considered words, go figure.\\n      var emptyLineIsWord = !(forward && wordEnd);\\n      for (var i = 0; i < repeat; i++) {\\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\\n        if (!word) {\\n          var eodCh = lineLength(cm, cm.lastLine());\\n          words.push(forward\\n              ? {line: cm.lastLine(), from: eodCh, to: eodCh}\\n              : {line: 0, from: 0, to: 0});\\n          break;\\n        }\\n        words.push(word);\\n        cur = Pos(word.line, forward ? (word.to - 1) : word.from);\\n      }\\n      var shortCircuit = words.length != repeat;\\n      var firstWord = words[0];\\n      var lastWord = words.pop();\\n      if (forward && !wordEnd) {\\n        // w\\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\\n          // We did not start in the middle of a word. Discard the extra word at the end.\\n          lastWord = words.pop();\\n        }\\n        return Pos(lastWord.line, lastWord.from);\\n      } else if (forward && wordEnd) {\\n        return Pos(lastWord.line, lastWord.to - 1);\\n      } else if (!forward && wordEnd) {\\n        // ge\\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\\n          // We did not start in the middle of a word. Discard the extra word at the end.\\n          lastWord = words.pop();\\n        }\\n        return Pos(lastWord.line, lastWord.to);\\n      } else {\\n        // b\\n        return Pos(lastWord.line, lastWord.from);\\n      }\\n    }\\n\\n    function moveToCharacter(cm, repeat, forward, character) {\\n      var cur = cm.getCursor();\\n      var start = cur.ch;\\n      var idx;\\n      for (var i = 0; i < repeat; i ++) {\\n        var line = cm.getLine(cur.line);\\n        idx = charIdxInLine(start, line, character, forward, true);\\n        if (idx == -1) {\\n          return null;\\n        }\\n        start = idx;\\n      }\\n      return Pos(cm.getCursor().line, idx);\\n    }\\n\\n    function moveToColumn(cm, repeat) {\\n      // repeat is always >= 1, so repeat - 1 always corresponds\\n      // to the column we want to go to.\\n      var line = cm.getCursor().line;\\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\\n    }\\n\\n    function updateMark(cm, vim, markName, pos) {\\n      if (!inArray(markName, validMarks)) {\\n        return;\\n      }\\n      if (vim.marks[markName]) {\\n        vim.marks[markName].clear();\\n      }\\n      vim.marks[markName] = cm.setBookmark(pos);\\n    }\\n\\n    function charIdxInLine(start, line, character, forward, includeChar) {\\n      // Search for char in line.\\n      // motion_options: {forward, includeChar}\\n      // If includeChar = true, include it too.\\n      // If forward = true, search forward, else search backwards.\\n      // If char is not found on this line, do nothing\\n      var idx;\\n      if (forward) {\\n        idx = line.indexOf(character, start + 1);\\n        if (idx != -1 && !includeChar) {\\n          idx -= 1;\\n        }\\n      } else {\\n        idx = line.lastIndexOf(character, start - 1);\\n        if (idx != -1 && !includeChar) {\\n          idx += 1;\\n        }\\n      }\\n      return idx;\\n    }\\n\\n    function findParagraph(cm, head, repeat, dir, inclusive) {\\n      var line = head.line;\\n      var min = cm.firstLine();\\n      var max = cm.lastLine();\\n      var start, end, i = line;\\n      function isEmpty(i) { return !cm.getLine(i); }\\n      function isBoundary(i, dir, any) {\\n        if (any) { return isEmpty(i) != isEmpty(i + dir); }\\n        return !isEmpty(i) && isEmpty(i + dir);\\n      }\\n      if (dir) {\\n        while (min <= i && i <= max && repeat > 0) {\\n          if (isBoundary(i, dir)) { repeat--; }\\n          i += dir;\\n        }\\n        return new Pos(i, 0);\\n      }\\n\\n      var vim = cm.state.vim;\\n      if (vim.visualLine && isBoundary(line, 1, true)) {\\n        var anchor = vim.sel.anchor;\\n        if (isBoundary(anchor.line, -1, true)) {\\n          if (!inclusive || anchor.line != line) {\\n            line += 1;\\n          }\\n        }\\n      }\\n      var startState = isEmpty(line);\\n      for (i = line; i <= max && repeat; i++) {\\n        if (isBoundary(i, 1, true)) {\\n          if (!inclusive || isEmpty(i) != startState) {\\n            repeat--;\\n          }\\n        }\\n      }\\n      end = new Pos(i, 0);\\n      // select boundary before paragraph for the last one\\n      if (i > max && !startState) { startState = true; }\\n      else { inclusive = false; }\\n      for (i = line; i > min; i--) {\\n        if (!inclusive || isEmpty(i) == startState || i == line) {\\n          if (isBoundary(i, -1, true)) { break; }\\n        }\\n      }\\n      start = new Pos(i, 0);\\n      return { start: start, end: end };\\n    }\\n\\n    function findSentence(cm, cur, repeat, dir) {\\n\\n      /*\\n        Takes an index object\\n        {\\n          line: the line string,\\n          ln: line number,\\n          pos: index in line,\\n          dir: direction of traversal (-1 or 1)\\n        }\\n        and modifies the line, ln, and pos members to represent the\\n        next valid position or sets them to null if there are\\n        no more valid positions.\\n       */\\n      function nextChar(cm, idx) {\\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\\n          idx.ln += idx.dir;\\n          if (!isLine(cm, idx.ln)) {\\n            idx.line = null;\\n            idx.ln = null;\\n            idx.pos = null;\\n            return;\\n          }\\n          idx.line = cm.getLine(idx.ln);\\n          idx.pos = (idx.dir > 0) ? 0 : idx.line.length - 1;\\n        }\\n        else {\\n          idx.pos += idx.dir;\\n        }\\n      }\\n\\n      /*\\n        Performs one iteration of traversal in forward direction\\n        Returns an index object of the new location\\n       */\\n      function forward(cm, ln, pos, dir) {\\n        var line = cm.getLine(ln);\\n        var stop = (line === \\\"\\\");\\n\\n        var curr = {\\n          line: line,\\n          ln: ln,\\n          pos: pos,\\n          dir: dir,\\n        }\\n\\n        var last_valid = {\\n          ln: curr.ln,\\n          pos: curr.pos,\\n        }\\n\\n        var skip_empty_lines = (curr.line === \\\"\\\");\\n\\n        // Move one step to skip character we start on\\n        nextChar(cm, curr);\\n\\n        while (curr.line !== null) {\\n          last_valid.ln = curr.ln;\\n          last_valid.pos = curr.pos;\\n\\n          if (curr.line === \\\"\\\" && !skip_empty_lines) {\\n            return { ln: curr.ln, pos: curr.pos, };\\n          }\\n          else if (stop && curr.line !== \\\"\\\" && !isWhiteSpaceString(curr.line[curr.pos])) {\\n            return { ln: curr.ln, pos: curr.pos, };\\n          }\\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\\n            && !stop\\n            && (curr.pos === curr.line.length - 1\\n              || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\\n            stop = true;\\n          }\\n\\n          nextChar(cm, curr);\\n        }\\n\\n        /*\\n          Set the position to the last non whitespace character on the last\\n          valid line in the case that we reach the end of the document.\\n        */\\n        var line = cm.getLine(last_valid.ln);\\n        last_valid.pos = 0;\\n        for(var i = line.length - 1; i >= 0; --i) {\\n          if (!isWhiteSpaceString(line[i])) {\\n            last_valid.pos = i;\\n            break;\\n          }\\n        }\\n\\n        return last_valid;\\n\\n      }\\n\\n      /*\\n        Performs one iteration of traversal in reverse direction\\n        Returns an index object of the new location\\n       */\\n      function reverse(cm, ln, pos, dir) {\\n        var line = cm.getLine(ln);\\n\\n        var curr = {\\n          line: line,\\n          ln: ln,\\n          pos: pos,\\n          dir: dir,\\n        }\\n\\n        var last_valid = {\\n          ln: curr.ln,\\n          pos: null,\\n        };\\n\\n        var skip_empty_lines = (curr.line === \\\"\\\");\\n\\n        // Move one step to skip character we start on\\n        nextChar(cm, curr);\\n\\n        while (curr.line !== null) {\\n\\n          if (curr.line === \\\"\\\" && !skip_empty_lines) {\\n            if (last_valid.pos !== null) {\\n              return last_valid;\\n            }\\n            else {\\n              return { ln: curr.ln, pos: curr.pos };\\n            }\\n          }\\n          else if (isEndOfSentenceSymbol(curr.line[curr.pos])\\n              && last_valid.pos !== null\\n              && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\\n            return last_valid;\\n          }\\n          else if (curr.line !== \\\"\\\" && !isWhiteSpaceString(curr.line[curr.pos])) {\\n            skip_empty_lines = false;\\n            last_valid = { ln: curr.ln, pos: curr.pos }\\n          }\\n\\n          nextChar(cm, curr);\\n        }\\n\\n        /*\\n          Set the position to the first non whitespace character on the last\\n          valid line in the case that we reach the beginning of the document.\\n        */\\n        var line = cm.getLine(last_valid.ln);\\n        last_valid.pos = 0;\\n        for(var i = 0; i < line.length; ++i) {\\n          if (!isWhiteSpaceString(line[i])) {\\n            last_valid.pos = i;\\n            break;\\n          }\\n        }\\n        return last_valid;\\n      }\\n\\n      var curr_index = {\\n        ln: cur.line,\\n        pos: cur.ch,\\n      };\\n\\n      while (repeat > 0) {\\n        if (dir < 0) {\\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\\n        }\\n        else {\\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\\n        }\\n        repeat--;\\n      }\\n\\n      return Pos(curr_index.ln, curr_index.pos);\\n    }\\n\\n    // TODO: perhaps this finagling of start and end positions belonds\\n    // in codemirror/replaceRange?\\n    function selectCompanionObject(cm, head, symb, inclusive) {\\n      var cur = head, start, end;\\n\\n      var bracketRegexp = ({\\n        '(': /[()]/, ')': /[()]/,\\n        '[': /[[\\\\]]/, ']': /[[\\\\]]/,\\n        '{': /[{}]/, '}': /[{}]/,\\n        '<': /[<>]/, '>': /[<>]/})[symb];\\n      var openSym = ({\\n        '(': '(', ')': '(',\\n        '[': '[', ']': '[',\\n        '{': '{', '}': '{',\\n        '<': '<', '>': '<'})[symb];\\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\\n      // Due to the behavior of scanForBracket, we need to add an offset if the\\n      // cursor is on a matching open bracket.\\n      var offset = curChar === openSym ? 1 : 0;\\n\\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {'bracketRegex': bracketRegexp});\\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {'bracketRegex': bracketRegexp});\\n\\n      if (!start || !end) {\\n        return { start: cur, end: cur };\\n      }\\n\\n      start = start.pos;\\n      end = end.pos;\\n\\n      if ((start.line == end.line && start.ch > end.ch)\\n          || (start.line > end.line)) {\\n        var tmp = start;\\n        start = end;\\n        end = tmp;\\n      }\\n\\n      if (inclusive) {\\n        end.ch += 1;\\n      } else {\\n        start.ch += 1;\\n      }\\n\\n      return { start: start, end: end };\\n    }\\n\\n    // Takes in a symbol and a cursor and tries to simulate text objects that\\n    // have identical opening and closing symbols\\n    // TODO support across multiple lines\\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\\n      var cur = copyCursor(head);\\n      var line = cm.getLine(cur.line);\\n      var chars = line.split('');\\n      var start, end, i, len;\\n      var firstIndex = chars.indexOf(symb);\\n\\n      // the decision tree is to always look backwards for the beginning first,\\n      // but if the cursor is in front of the first instance of the symb,\\n      // then move the cursor forward\\n      if (cur.ch < firstIndex) {\\n        cur.ch = firstIndex;\\n        // Why is this line even here???\\n        // cm.setCursor(cur.line, firstIndex+1);\\n      }\\n      // otherwise if the cursor is currently on the closing symbol\\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\\n        end = cur.ch; // assign end to the current cursor\\n        --cur.ch; // make sure to look backwards\\n      }\\n\\n      // if we're currently on the symbol, we've got a start\\n      if (chars[cur.ch] == symb && !end) {\\n        start = cur.ch + 1; // assign start to ahead of the cursor\\n      } else {\\n        // go backwards to find the start\\n        for (i = cur.ch; i > -1 && !start; i--) {\\n          if (chars[i] == symb) {\\n            start = i + 1;\\n          }\\n        }\\n      }\\n\\n      // look forwards for the end symbol\\n      if (start && !end) {\\n        for (i = start, len = chars.length; i < len && !end; i++) {\\n          if (chars[i] == symb) {\\n            end = i;\\n          }\\n        }\\n      }\\n\\n      // nothing found\\n      if (!start || !end) {\\n        return { start: cur, end: cur };\\n      }\\n\\n      // include the symbols\\n      if (inclusive) {\\n        --start; ++end;\\n      }\\n\\n      return {\\n        start: Pos(cur.line, start),\\n        end: Pos(cur.line, end)\\n      };\\n    }\\n\\n    // Search functions\\n    defineOption('pcre', true, 'boolean');\\n    function SearchState() {}\\n    SearchState.prototype = {\\n      getQuery: function() {\\n        return vimGlobalState.query;\\n      },\\n      setQuery: function(query) {\\n        vimGlobalState.query = query;\\n      },\\n      getOverlay: function() {\\n        return this.searchOverlay;\\n      },\\n      setOverlay: function(overlay) {\\n        this.searchOverlay = overlay;\\n      },\\n      isReversed: function() {\\n        return vimGlobalState.isReversed;\\n      },\\n      setReversed: function(reversed) {\\n        vimGlobalState.isReversed = reversed;\\n      },\\n      getScrollbarAnnotate: function() {\\n        return this.annotate;\\n      },\\n      setScrollbarAnnotate: function(annotate) {\\n        this.annotate = annotate;\\n      }\\n    };\\n    function getSearchState(cm) {\\n      var vim = cm.state.vim;\\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\\n    }\\n    function dialog(cm, template, shortText, onClose, options) {\\n      if (cm.openDialog) {\\n        cm.openDialog(template, onClose, { bottom: true, value: options.value,\\n            onKeyDown: options.onKeyDown, onKeyUp: options.onKeyUp,\\n            selectValueOnOpen: false});\\n      }\\n      else {\\n        onClose(prompt(shortText, ''));\\n      }\\n    }\\n    function splitBySlash(argString) {\\n      return splitBySeparator(argString, '/');\\n    }\\n\\n    function findUnescapedSlashes(argString) {\\n      return findUnescapedSeparators(argString, '/');\\n    }\\n\\n    function splitBySeparator(argString, separator) {\\n      var slashes = findUnescapedSeparators(argString, separator) || [];\\n      if (!slashes.length) return [];\\n      var tokens = [];\\n      // in case of strings like foo/bar\\n      if (slashes[0] !== 0) return;\\n      for (var i = 0; i < slashes.length; i++) {\\n        if (typeof slashes[i] == 'number')\\n          tokens.push(argString.substring(slashes[i] + 1, slashes[i+1]));\\n      }\\n      return tokens;\\n    }\\n\\n    function findUnescapedSeparators(str, separator) {\\n      if (!separator)\\n        separator = '/';\\n\\n      var escapeNextChar = false;\\n      var slashes = [];\\n      for (var i = 0; i < str.length; i++) {\\n        var c = str.charAt(i);\\n        if (!escapeNextChar && c == separator) {\\n          slashes.push(i);\\n        }\\n        escapeNextChar = !escapeNextChar && (c == '\\\\\\\\');\\n      }\\n      return slashes;\\n    }\\n\\n    // Translates a search string from ex (vim) syntax into javascript form.\\n    function translateRegex(str) {\\n      // When these match, add a '\\\\' if unescaped or remove one if escaped.\\n      var specials = '|(){';\\n      // Remove, but never add, a '\\\\' for these.\\n      var unescape = '}';\\n      var escapeNextChar = false;\\n      var out = [];\\n      for (var i = -1; i < str.length; i++) {\\n        var c = str.charAt(i) || '';\\n        var n = str.charAt(i+1) || '';\\n        var specialComesNext = (n && specials.indexOf(n) != -1);\\n        if (escapeNextChar) {\\n          if (c !== '\\\\\\\\' || !specialComesNext) {\\n            out.push(c);\\n          }\\n          escapeNextChar = false;\\n        } else {\\n          if (c === '\\\\\\\\') {\\n            escapeNextChar = true;\\n            // Treat the unescape list as special for removing, but not adding '\\\\'.\\n            if (n && unescape.indexOf(n) != -1) {\\n              specialComesNext = true;\\n            }\\n            // Not passing this test means removing a '\\\\'.\\n            if (!specialComesNext || n === '\\\\\\\\') {\\n              out.push(c);\\n            }\\n          } else {\\n            out.push(c);\\n            if (specialComesNext && n !== '\\\\\\\\') {\\n              out.push('\\\\\\\\');\\n            }\\n          }\\n        }\\n      }\\n      return out.join('');\\n    }\\n\\n    // Translates the replace part of a search and replace from ex (vim) syntax into\\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\\n    // (translates '\\\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\\n    var charUnescapes = {'\\\\\\\\n': '\\\\n', '\\\\\\\\r': '\\\\r', '\\\\\\\\t': '\\\\t'};\\n    function translateRegexReplace(str) {\\n      var escapeNextChar = false;\\n      var out = [];\\n      for (var i = -1; i < str.length; i++) {\\n        var c = str.charAt(i) || '';\\n        var n = str.charAt(i+1) || '';\\n        if (charUnescapes[c + n]) {\\n          out.push(charUnescapes[c+n]);\\n          i++;\\n        } else if (escapeNextChar) {\\n          // At any point in the loop, escapeNextChar is true if the previous\\n          // character was a '\\\\' and was not escaped.\\n          out.push(c);\\n          escapeNextChar = false;\\n        } else {\\n          if (c === '\\\\\\\\') {\\n            escapeNextChar = true;\\n            if ((isNumber(n) || n === '$')) {\\n              out.push('$');\\n            } else if (n !== '/' && n !== '\\\\\\\\') {\\n              out.push('\\\\\\\\');\\n            }\\n          } else {\\n            if (c === '$') {\\n              out.push('$');\\n            }\\n            out.push(c);\\n            if (n === '/') {\\n              out.push('\\\\\\\\');\\n            }\\n          }\\n        }\\n      }\\n      return out.join('');\\n    }\\n\\n    // Unescape \\\\ and / in the replace part, for PCRE mode.\\n    var unescapes = {'\\\\\\\\/': '/', '\\\\\\\\\\\\\\\\': '\\\\\\\\', '\\\\\\\\n': '\\\\n', '\\\\\\\\r': '\\\\r', '\\\\\\\\t': '\\\\t'};\\n    function unescapeRegexReplace(str) {\\n      var stream = new CodeMirror.StringStream(str);\\n      var output = [];\\n      while (!stream.eol()) {\\n        // Search for \\\\.\\n        while (stream.peek() && stream.peek() != '\\\\\\\\') {\\n          output.push(stream.next());\\n        }\\n        var matched = false;\\n        for (var matcher in unescapes) {\\n          if (stream.match(matcher, true)) {\\n            matched = true;\\n            output.push(unescapes[matcher]);\\n            break;\\n          }\\n        }\\n        if (!matched) {\\n          // Don't change anything\\n          output.push(stream.next());\\n        }\\n      }\\n      return output.join('');\\n    }\\n\\n    /**\\n     * Extract the regular expression from the query and return a Regexp object.\\n     * Returns null if the query is blank.\\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\\n     * If smartCase is passed in, and the query contains upper case letters,\\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\\n     * If the query contains the /i in the flag part of the regular expression,\\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\\n     *   through to the Regex object.\\n     */\\n    function parseQuery(query, ignoreCase, smartCase) {\\n      // First update the last search register\\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\\n      lastSearchRegister.setText(query);\\n      // Check if the query is already a regex.\\n      if (query instanceof RegExp) { return query; }\\n      // First try to extract regex + flags from the input. If no flags found,\\n      // extract just the regex. IE does not accept flags directly defined in\\n      // the regex string in the form /regex/flags\\n      var slashes = findUnescapedSlashes(query);\\n      var regexPart;\\n      var forceIgnoreCase;\\n      if (!slashes.length) {\\n        // Query looks like 'regexp'\\n        regexPart = query;\\n      } else {\\n        // Query looks like 'regexp/...'\\n        regexPart = query.substring(0, slashes[0]);\\n        var flagsPart = query.substring(slashes[0]);\\n        forceIgnoreCase = (flagsPart.indexOf('i') != -1);\\n      }\\n      if (!regexPart) {\\n        return null;\\n      }\\n      if (!getOption('pcre')) {\\n        regexPart = translateRegex(regexPart);\\n      }\\n      if (smartCase) {\\n        ignoreCase = (/^[^A-Z]*$/).test(regexPart);\\n      }\\n      var regexp = new RegExp(regexPart,\\n          (ignoreCase || forceIgnoreCase) ? 'i' : undefined);\\n      return regexp;\\n    }\\n    function showConfirm(cm, text) {\\n      if (cm.openNotification) {\\n        cm.openNotification('<span style=\\\"color: red\\\">' + text + '</span>',\\n                            {bottom: true, duration: 5000});\\n      } else {\\n        alert(text);\\n      }\\n    }\\n    function makePrompt(prefix, desc) {\\n      var raw = '<span style=\\\"font-family: monospace; white-space: pre\\\">' +\\n          (prefix || \\\"\\\") + '<input type=\\\"text\\\"></span>';\\n      if (desc)\\n        raw += ' <span style=\\\"color: #888\\\">' + desc + '</span>';\\n      return raw;\\n    }\\n    var searchPromptDesc = '(Javascript regexp)';\\n    function showPrompt(cm, options) {\\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\\n      var prompt = makePrompt(options.prefix, options.desc);\\n      dialog(cm, prompt, shortText, options.onClose, options);\\n    }\\n    function regexEqual(r1, r2) {\\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\\n          var props = ['global', 'multiline', 'ignoreCase', 'source'];\\n          for (var i = 0; i < props.length; i++) {\\n              var prop = props[i];\\n              if (r1[prop] !== r2[prop]) {\\n                  return false;\\n              }\\n          }\\n          return true;\\n      }\\n      return false;\\n    }\\n    // Returns true if the query is valid.\\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\\n      if (!rawQuery) {\\n        return;\\n      }\\n      var state = getSearchState(cm);\\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\\n      if (!query) {\\n        return;\\n      }\\n      highlightSearchMatches(cm, query);\\n      if (regexEqual(query, state.getQuery())) {\\n        return query;\\n      }\\n      state.setQuery(query);\\n      return query;\\n    }\\n    function searchOverlay(query) {\\n      if (query.source.charAt(0) == '^') {\\n        var matchSol = true;\\n      }\\n      return {\\n        token: function(stream) {\\n          if (matchSol && !stream.sol()) {\\n            stream.skipToEnd();\\n            return;\\n          }\\n          var match = stream.match(query, false);\\n          if (match) {\\n            if (match[0].length == 0) {\\n              // Matched empty string, skip to next.\\n              stream.next();\\n              return 'searching';\\n            }\\n            if (!stream.sol()) {\\n              // Backtrack 1 to match \\\\b\\n              stream.backUp(1);\\n              if (!query.exec(stream.next() + match[0])) {\\n                stream.next();\\n                return null;\\n              }\\n            }\\n            stream.match(query);\\n            return 'searching';\\n          }\\n          while (!stream.eol()) {\\n            stream.next();\\n            if (stream.match(query, false)) break;\\n          }\\n        },\\n        query: query\\n      };\\n    }\\n    function highlightSearchMatches(cm, query) {\\n      var searchState = getSearchState(cm);\\n      var overlay = searchState.getOverlay();\\n      if (!overlay || query != overlay.query) {\\n        if (overlay) {\\n          cm.removeOverlay(overlay);\\n        }\\n        overlay = searchOverlay(query);\\n        cm.addOverlay(overlay);\\n        if (cm.showMatchesOnScrollbar) {\\n          if (searchState.getScrollbarAnnotate()) {\\n            searchState.getScrollbarAnnotate().clear();\\n          }\\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\\n        }\\n        searchState.setOverlay(overlay);\\n      }\\n    }\\n    function findNext(cm, prev, query, repeat) {\\n      if (repeat === undefined) { repeat = 1; }\\n      return cm.operation(function() {\\n        var pos = cm.getCursor();\\n        var cursor = cm.getSearchCursor(query, pos);\\n        for (var i = 0; i < repeat; i++) {\\n          var found = cursor.find(prev);\\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) { found = cursor.find(prev); }\\n          if (!found) {\\n            // SearchCursor may have returned null because it hit EOF, wrap\\n            // around and try again.\\n            cursor = cm.getSearchCursor(query,\\n                (prev) ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0) );\\n            if (!cursor.find(prev)) {\\n              return;\\n            }\\n          }\\n        }\\n        return cursor.from();\\n      });\\n    }\\n    function clearSearchHighlight(cm) {\\n      var state = getSearchState(cm);\\n      cm.removeOverlay(getSearchState(cm).getOverlay());\\n      state.setOverlay(null);\\n      if (state.getScrollbarAnnotate()) {\\n        state.getScrollbarAnnotate().clear();\\n        state.setScrollbarAnnotate(null);\\n      }\\n    }\\n    /**\\n     * Check if pos is in the specified range, INCLUSIVE.\\n     * Range can be specified with 1 or 2 arguments.\\n     * If the first range argument is an array, treat it as an array of line\\n     * numbers. Match pos against any of the lines.\\n     * If the first range argument is a number,\\n     *   if there is only 1 range argument, check if pos has the same line\\n     *       number\\n     *   if there are 2 range arguments, then check if pos is in between the two\\n     *       range arguments.\\n     */\\n    function isInRange(pos, start, end) {\\n      if (typeof pos != 'number') {\\n        // Assume it is a cursor position. Get the line number.\\n        pos = pos.line;\\n      }\\n      if (start instanceof Array) {\\n        return inArray(pos, start);\\n      } else {\\n        if (end) {\\n          return (pos >= start && pos <= end);\\n        } else {\\n          return pos == start;\\n        }\\n      }\\n    }\\n    function getUserVisibleLines(cm) {\\n      var scrollInfo = cm.getScrollInfo();\\n      var occludeToleranceTop = 6;\\n      var occludeToleranceBottom = 10;\\n      var from = cm.coordsChar({left:0, top: occludeToleranceTop + scrollInfo.top}, 'local');\\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\\n      var to = cm.coordsChar({left:0, top: bottomY}, 'local');\\n      return {top: from.line, bottom: to.line};\\n    }\\n\\n    function getMarkPos(cm, vim, markName) {\\n      if (markName == '\\\\'') {\\n        var history = cm.doc.history.done;\\n        var event = history[history.length - 2];\\n        return event && event.ranges && event.ranges[0].head;\\n      } else if (markName == '.') {\\n        if (cm.doc.history.lastModTime == 0) {\\n          return  // If no changes, bail out; don't bother to copy or reverse history array.\\n        } else {\\n          var changeHistory = cm.doc.history.done.filter(function(el){ if (el.changes !== undefined) { return el } });\\n          changeHistory.reverse();\\n          var lastEditPos = changeHistory[0].changes[0].to;\\n        }\\n        return lastEditPos;\\n      }\\n\\n      var mark = vim.marks[markName];\\n      return mark && mark.find();\\n    }\\n\\n    var ExCommandDispatcher = function() {\\n      this.buildCommandMap_();\\n    };\\n    ExCommandDispatcher.prototype = {\\n      processCommand: function(cm, input, opt_params) {\\n        var that = this;\\n        cm.operation(function () {\\n          cm.curOp.isVimOp = true;\\n          that._processCommand(cm, input, opt_params);\\n        });\\n      },\\n      _processCommand: function(cm, input, opt_params) {\\n        var vim = cm.state.vim;\\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\\n        var previousCommand = commandHistoryRegister.toString();\\n        if (vim.visualMode) {\\n          exitVisualMode(cm);\\n        }\\n        var inputStream = new CodeMirror.StringStream(input);\\n        // update \\\": with the latest command whether valid or invalid\\n        commandHistoryRegister.setText(input);\\n        var params = opt_params || {};\\n        params.input = input;\\n        try {\\n          this.parseInput_(cm, inputStream, params);\\n        } catch(e) {\\n          showConfirm(cm, e);\\n          throw e;\\n        }\\n        var command;\\n        var commandName;\\n        if (!params.commandName) {\\n          // If only a line range is defined, move to the line.\\n          if (params.line !== undefined) {\\n            commandName = 'move';\\n          }\\n        } else {\\n          command = this.matchCommand_(params.commandName);\\n          if (command) {\\n            commandName = command.name;\\n            if (command.excludeFromCommandHistory) {\\n              commandHistoryRegister.setText(previousCommand);\\n            }\\n            this.parseCommandArgs_(inputStream, params, command);\\n            if (command.type == 'exToKey') {\\n              // Handle Ex to Key mapping.\\n              for (var i = 0; i < command.toKeys.length; i++) {\\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\\n              }\\n              return;\\n            } else if (command.type == 'exToEx') {\\n              // Handle Ex to Ex mapping.\\n              this.processCommand(cm, command.toInput);\\n              return;\\n            }\\n          }\\n        }\\n        if (!commandName) {\\n          showConfirm(cm, 'Not an editor command \\\":' + input + '\\\"');\\n          return;\\n        }\\n        try {\\n          exCommands[commandName](cm, params);\\n          // Possibly asynchronous commands (e.g. substitute, which might have a\\n          // user confirmation), are responsible for calling the callback when\\n          // done. All others have it taken care of for them here.\\n          if ((!command || !command.possiblyAsync) && params.callback) {\\n            params.callback();\\n          }\\n        } catch(e) {\\n          showConfirm(cm, e);\\n          throw e;\\n        }\\n      },\\n      parseInput_: function(cm, inputStream, result) {\\n        inputStream.eatWhile(':');\\n        // Parse range.\\n        if (inputStream.eat('%')) {\\n          result.line = cm.firstLine();\\n          result.lineEnd = cm.lastLine();\\n        } else {\\n          result.line = this.parseLineSpec_(cm, inputStream);\\n          if (result.line !== undefined && inputStream.eat(',')) {\\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\\n          }\\n        }\\n\\n        // Parse command name.\\n        var commandMatch = inputStream.match(/^(\\\\w+)/);\\n        if (commandMatch) {\\n          result.commandName = commandMatch[1];\\n        } else {\\n          result.commandName = inputStream.match(/.*/)[0];\\n        }\\n\\n        return result;\\n      },\\n      parseLineSpec_: function(cm, inputStream) {\\n        var numberMatch = inputStream.match(/^(\\\\d+)/);\\n        if (numberMatch) {\\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\\n          // not something the user actually wanted. (NB: vim does allow this.)\\n          return parseInt(numberMatch[1], 10) - 1;\\n        }\\n        switch (inputStream.next()) {\\n          case '.':\\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\\n          case '$':\\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\\n          case '\\\\'':\\n            var markName = inputStream.next();\\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\\n            if (!markPos) throw new Error('Mark not set');\\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\\n          case '-':\\n          case '+':\\n            inputStream.backUp(1);\\n            // Offset is relative to current line if not otherwise specified.\\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\\n          default:\\n            inputStream.backUp(1);\\n            return undefined;\\n        }\\n      },\\n      parseLineSpecOffset_: function(inputStream, line) {\\n        var offsetMatch = inputStream.match(/^([+-])?(\\\\d+)/);\\n        if (offsetMatch) {\\n          var offset = parseInt(offsetMatch[2], 10);\\n          if (offsetMatch[1] == \\\"-\\\") {\\n            line -= offset;\\n          } else {\\n            line += offset;\\n          }\\n        }\\n        return line;\\n      },\\n      parseCommandArgs_: function(inputStream, params, command) {\\n        if (inputStream.eol()) {\\n          return;\\n        }\\n        params.argString = inputStream.match(/.*/)[0];\\n        // Parse command-line arguments\\n        var delim = command.argDelimiter || /\\\\s+/;\\n        var args = trim(params.argString).split(delim);\\n        if (args.length && args[0]) {\\n          params.args = args;\\n        }\\n      },\\n      matchCommand_: function(commandName) {\\n        // Return the command in the command map that matches the shortest\\n        // prefix of the passed in command name. The match is guaranteed to be\\n        // unambiguous if the defaultExCommandMap's shortNames are set up\\n        // correctly. (see @code{defaultExCommandMap}).\\n        for (var i = commandName.length; i > 0; i--) {\\n          var prefix = commandName.substring(0, i);\\n          if (this.commandMap_[prefix]) {\\n            var command = this.commandMap_[prefix];\\n            if (command.name.indexOf(commandName) === 0) {\\n              return command;\\n            }\\n          }\\n        }\\n        return null;\\n      },\\n      buildCommandMap_: function() {\\n        this.commandMap_ = {};\\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\\n          var command = defaultExCommandMap[i];\\n          var key = command.shortName || command.name;\\n          this.commandMap_[key] = command;\\n        }\\n      },\\n      map: function(lhs, rhs, ctx) {\\n        if (lhs != ':' && lhs.charAt(0) == ':') {\\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\\n          var commandName = lhs.substring(1);\\n          if (rhs != ':' && rhs.charAt(0) == ':') {\\n            // Ex to Ex mapping\\n            this.commandMap_[commandName] = {\\n              name: commandName,\\n              type: 'exToEx',\\n              toInput: rhs.substring(1),\\n              user: true\\n            };\\n          } else {\\n            // Ex to key mapping\\n            this.commandMap_[commandName] = {\\n              name: commandName,\\n              type: 'exToKey',\\n              toKeys: rhs,\\n              user: true\\n            };\\n          }\\n        } else {\\n          if (rhs != ':' && rhs.charAt(0) == ':') {\\n            // Key to Ex mapping.\\n            var mapping = {\\n              keys: lhs,\\n              type: 'keyToEx',\\n              exArgs: { input: rhs.substring(1) }\\n            };\\n            if (ctx) { mapping.context = ctx; }\\n            defaultKeymap.unshift(mapping);\\n          } else {\\n            // Key to key mapping\\n            var mapping = {\\n              keys: lhs,\\n              type: 'keyToKey',\\n              toKeys: rhs\\n            };\\n            if (ctx) { mapping.context = ctx; }\\n            defaultKeymap.unshift(mapping);\\n          }\\n        }\\n      },\\n      unmap: function(lhs, ctx) {\\n        if (lhs != ':' && lhs.charAt(0) == ':') {\\n          // Ex to Ex or Ex to key mapping\\n          if (ctx) { throw Error('Mode not supported for ex mappings'); }\\n          var commandName = lhs.substring(1);\\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\\n            delete this.commandMap_[commandName];\\n            return;\\n          }\\n        } else {\\n          // Key to Ex or key to key mapping\\n          var keys = lhs;\\n          for (var i = 0; i < defaultKeymap.length; i++) {\\n            if (keys == defaultKeymap[i].keys\\n                && defaultKeymap[i].context === ctx) {\\n              defaultKeymap.splice(i, 1);\\n              return;\\n            }\\n          }\\n        }\\n        throw Error('No such mapping.');\\n      }\\n    };\\n\\n    var exCommands = {\\n      colorscheme: function(cm, params) {\\n        if (!params.args || params.args.length < 1) {\\n          showConfirm(cm, cm.getOption('theme'));\\n          return;\\n        }\\n        cm.setOption('theme', params.args[0]);\\n      },\\n      map: function(cm, params, ctx) {\\n        var mapArgs = params.args;\\n        if (!mapArgs || mapArgs.length < 2) {\\n          if (cm) {\\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\\n          }\\n          return;\\n        }\\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\\n      },\\n      imap: function(cm, params) { this.map(cm, params, 'insert'); },\\n      nmap: function(cm, params) { this.map(cm, params, 'normal'); },\\n      vmap: function(cm, params) { this.map(cm, params, 'visual'); },\\n      unmap: function(cm, params, ctx) {\\n        var mapArgs = params.args;\\n        if (!mapArgs || mapArgs.length < 1) {\\n          if (cm) {\\n            showConfirm(cm, 'No such mapping: ' + params.input);\\n          }\\n          return;\\n        }\\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\\n      },\\n      move: function(cm, params) {\\n        commandDispatcher.processCommand(cm, cm.state.vim, {\\n            type: 'motion',\\n            motion: 'moveToLineOrEdgeOfDocument',\\n            motionArgs: { forward: false, explicitRepeat: true,\\n              linewise: true },\\n            repeatOverride: params.line+1});\\n      },\\n      set: function(cm, params) {\\n        var setArgs = params.args;\\n        // Options passed through to the setOption/getOption calls. May be passed in by the\\n        // local/global versions of the set command\\n        var setCfg = params.setCfg || {};\\n        if (!setArgs || setArgs.length < 1) {\\n          if (cm) {\\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\\n          }\\n          return;\\n        }\\n        var expr = setArgs[0].split('=');\\n        var optionName = expr[0];\\n        var value = expr[1];\\n        var forceGet = false;\\n\\n        if (optionName.charAt(optionName.length - 1) == '?') {\\n          // If post-fixed with ?, then the set is actually a get.\\n          if (value) { throw Error('Trailing characters: ' + params.argString); }\\n          optionName = optionName.substring(0, optionName.length - 1);\\n          forceGet = true;\\n        }\\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\\n          // To set boolean options to false, the option name is prefixed with\\n          // 'no'.\\n          optionName = optionName.substring(2);\\n          value = false;\\n        }\\n\\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\\n        if (optionIsBoolean && value == undefined) {\\n          // Calling set with a boolean option sets it to true.\\n          value = true;\\n        }\\n        // If no value is provided, then we assume this is a get.\\n        if (!optionIsBoolean && value === undefined || forceGet) {\\n          var oldValue = getOption(optionName, cm, setCfg);\\n          if (oldValue instanceof Error) {\\n            showConfirm(cm, oldValue.message);\\n          } else if (oldValue === true || oldValue === false) {\\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\\n          } else {\\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\\n          }\\n        } else {\\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\\n          if (setOptionReturn instanceof Error) {\\n            showConfirm(cm, setOptionReturn.message);\\n          }\\n        }\\n      },\\n      setlocal: function (cm, params) {\\n        // setCfg is passed through to setOption\\n        params.setCfg = {scope: 'local'};\\n        this.set(cm, params);\\n      },\\n      setglobal: function (cm, params) {\\n        // setCfg is passed through to setOption\\n        params.setCfg = {scope: 'global'};\\n        this.set(cm, params);\\n      },\\n      registers: function(cm, params) {\\n        var regArgs = params.args;\\n        var registers = vimGlobalState.registerController.registers;\\n        var regInfo = '----------Registers----------<br><br>';\\n        if (!regArgs) {\\n          for (var registerName in registers) {\\n            var text = registers[registerName].toString();\\n            if (text.length) {\\n              regInfo += '\\\"' + registerName + '    ' + text + '<br>';\\n            }\\n          }\\n        } else {\\n          var registerName;\\n          regArgs = regArgs.join('');\\n          for (var i = 0; i < regArgs.length; i++) {\\n            registerName = regArgs.charAt(i);\\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\\n              continue;\\n            }\\n            var register = registers[registerName] || new Register();\\n            regInfo += '\\\"' + registerName + '    ' + register.toString() + '<br>';\\n          }\\n        }\\n        showConfirm(cm, regInfo);\\n      },\\n      sort: function(cm, params) {\\n        var reverse, ignoreCase, unique, number, pattern;\\n        function parseArgs() {\\n          if (params.argString) {\\n            var args = new CodeMirror.StringStream(params.argString);\\n            if (args.eat('!')) { reverse = true; }\\n            if (args.eol()) { return; }\\n            if (!args.eatSpace()) { return 'Invalid arguments'; }\\n            var opts = args.match(/([dinuox]+)?\\\\s*(\\\\/.+\\\\/)?\\\\s*/);\\n            if (!opts && !args.eol()) { return 'Invalid arguments'; }\\n            if (opts[1]) {\\n              ignoreCase = opts[1].indexOf('i') != -1;\\n              unique = opts[1].indexOf('u') != -1;\\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\\n              var hex = opts[1].indexOf('x') != -1 && 1;\\n              var octal = opts[1].indexOf('o') != -1 && 1;\\n              if (decimal + hex + octal > 1) { return 'Invalid arguments'; }\\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\\n            }\\n            if (opts[2]) {\\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\\n            }\\n          }\\n        }\\n        var err = parseArgs();\\n        if (err) {\\n          showConfirm(cm, err + ': ' + params.argString);\\n          return;\\n        }\\n        var lineStart = params.line || cm.firstLine();\\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\\n        if (lineStart == lineEnd) { return; }\\n        var curStart = Pos(lineStart, 0);\\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\\n        var text = cm.getRange(curStart, curEnd).split('\\\\n');\\n        var numberRegex = pattern ? pattern :\\n           (number == 'decimal') ? /(-?)([\\\\d]+)/ :\\n           (number == 'hex') ? /(-?)(?:0x)?([0-9a-f]+)/i :\\n           (number == 'octal') ? /([0-7]+)/ : null;\\n        var radix = (number == 'decimal') ? 10 : (number == 'hex') ? 16 : (number == 'octal') ? 8 : null;\\n        var numPart = [], textPart = [];\\n        if (number || pattern) {\\n          for (var i = 0; i < text.length; i++) {\\n            var matchPart = pattern ? text[i].match(pattern) : null;\\n            if (matchPart && matchPart[0] != '') {\\n              numPart.push(matchPart);\\n            } else if (!pattern && numberRegex.exec(text[i])) {\\n              numPart.push(text[i]);\\n            } else {\\n              textPart.push(text[i]);\\n            }\\n          }\\n        } else {\\n          textPart = text;\\n        }\\n        function compareFn(a, b) {\\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\\n          if (ignoreCase) { a = a.toLowerCase(); b = b.toLowerCase(); }\\n          var anum = number && numberRegex.exec(a);\\n          var bnum = number && numberRegex.exec(b);\\n          if (!anum) { return a < b ? -1 : 1; }\\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\\n          return anum - bnum;\\n        }\\n        function comparePatternFn(a, b) {\\n          if (reverse) { var tmp; tmp = a; a = b; b = tmp; }\\n          if (ignoreCase) { a[0] = a[0].toLowerCase(); b[0] = b[0].toLowerCase(); }\\n          return (a[0] < b[0]) ? -1 : 1;\\n        }\\n        numPart.sort(pattern ? comparePatternFn : compareFn);\\n        if (pattern) {\\n          for (var i = 0; i < numPart.length; i++) {\\n            numPart[i] = numPart[i].input;\\n          }\\n        } else if (!number) { textPart.sort(compareFn); }\\n        text = (!reverse) ? textPart.concat(numPart) : numPart.concat(textPart);\\n        if (unique) { // Remove duplicate lines\\n          var textOld = text;\\n          var lastLine;\\n          text = [];\\n          for (var i = 0; i < textOld.length; i++) {\\n            if (textOld[i] != lastLine) {\\n              text.push(textOld[i]);\\n            }\\n            lastLine = textOld[i];\\n          }\\n        }\\n        cm.replaceRange(text.join('\\\\n'), curStart, curEnd);\\n      },\\n      global: function(cm, params) {\\n        // a global command is of the form\\n        // :[range]g/pattern/[cmd]\\n        // argString holds the string /pattern/[cmd]\\n        var argString = params.argString;\\n        if (!argString) {\\n          showConfirm(cm, 'Regular Expression missing from global');\\n          return;\\n        }\\n        // range is specified here\\n        var lineStart = (params.line !== undefined) ? params.line : cm.firstLine();\\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\\n        // get the tokens from argString\\n        var tokens = splitBySlash(argString);\\n        var regexPart = argString, cmd;\\n        if (tokens.length) {\\n          regexPart = tokens[0];\\n          cmd = tokens.slice(1, tokens.length).join('/');\\n        }\\n        if (regexPart) {\\n          // If regex part is empty, then use the previous query. Otherwise\\n          // use the regex part as the new query.\\n          try {\\n           updateSearchQuery(cm, regexPart, true /** ignoreCase */,\\n             true /** smartCase */);\\n          } catch (e) {\\n           showConfirm(cm, 'Invalid regex: ' + regexPart);\\n           return;\\n          }\\n        }\\n        // now that we have the regexPart, search for regex matches in the\\n        // specified range of lines\\n        var query = getSearchState(cm).getQuery();\\n        var matchedLines = [], content = '';\\n        for (var i = lineStart; i <= lineEnd; i++) {\\n          var matched = query.test(cm.getLine(i));\\n          if (matched) {\\n            matchedLines.push(i+1);\\n            content+= cm.getLine(i) + '<br>';\\n          }\\n        }\\n        // if there is no [cmd], just display the list of matched lines\\n        if (!cmd) {\\n          showConfirm(cm, content);\\n          return;\\n        }\\n        var index = 0;\\n        var nextCommand = function() {\\n          if (index < matchedLines.length) {\\n            var command = matchedLines[index] + cmd;\\n            exCommandDispatcher.processCommand(cm, command, {\\n              callback: nextCommand\\n            });\\n          }\\n          index++;\\n        };\\n        nextCommand();\\n      },\\n      substitute: function(cm, params) {\\n        if (!cm.getSearchCursor) {\\n          throw new Error('Search feature not available. Requires searchcursor.js or ' +\\n              'any other getSearchCursor implementation.');\\n        }\\n        var argString = params.argString;\\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\\n        var regexPart, replacePart = '', trailing, flagsPart, count;\\n        var confirm = false; // Whether to confirm each replace.\\n        var global = false; // True to replace all instances on a line, false to replace only 1.\\n        if (tokens.length) {\\n          regexPart = tokens[0];\\n          replacePart = tokens[1];\\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\\\\\n';\\n            replacePart = replacePart ? replacePart + '\\\\n' : '\\\\n';\\n          }\\n          if (replacePart !== undefined) {\\n            if (getOption('pcre')) {\\n              replacePart = unescapeRegexReplace(replacePart);\\n            } else {\\n              replacePart = translateRegexReplace(replacePart);\\n            }\\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\\n          }\\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\\n        } else {\\n          // either the argString is empty or its of the form ' hello/world'\\n          // actually splitBySlash returns a list of tokens\\n          // only if the string starts with a '/'\\n          if (argString && argString.length) {\\n            showConfirm(cm, 'Substitutions should be of the form ' +\\n                ':s/pattern/replace/');\\n            return;\\n          }\\n        }\\n        // After the 3rd slash, we can have flags followed by a space followed\\n        // by count.\\n        if (trailing) {\\n          flagsPart = trailing[0];\\n          count = parseInt(trailing[1]);\\n          if (flagsPart) {\\n            if (flagsPart.indexOf('c') != -1) {\\n              confirm = true;\\n              flagsPart.replace('c', '');\\n            }\\n            if (flagsPart.indexOf('g') != -1) {\\n              global = true;\\n              flagsPart.replace('g', '');\\n            }\\n            regexPart = regexPart.replace(/\\\\//g, \\\"\\\\\\\\/\\\") + '/' + flagsPart;\\n          }\\n        }\\n        if (regexPart) {\\n          // If regex part is empty, then use the previous query. Otherwise use\\n          // the regex part as the new query.\\n          try {\\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */,\\n              true /** smartCase */);\\n          } catch (e) {\\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\\n            return;\\n          }\\n        }\\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\\n        if (replacePart === undefined) {\\n          showConfirm(cm, 'No previous substitute regular expression');\\n          return;\\n        }\\n        var state = getSearchState(cm);\\n        var query = state.getQuery();\\n        var lineStart = (params.line !== undefined) ? params.line : cm.getCursor().line;\\n        var lineEnd = params.lineEnd || lineStart;\\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\\n          lineEnd = Infinity;\\n        }\\n        if (count) {\\n          lineStart = lineEnd;\\n          lineEnd = lineStart + count - 1;\\n        }\\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\\n        var cursor = cm.getSearchCursor(query, startPos);\\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\\n      },\\n      redo: CodeMirror.commands.redo,\\n      undo: CodeMirror.commands.undo,\\n      write: function(cm) {\\n        if (CodeMirror.commands.save) {\\n          // If a save command is defined, call it.\\n          CodeMirror.commands.save(cm);\\n        } else if (cm.save) {\\n          // Saves to text area if no save command is defined and cm.save() is available.\\n          cm.save();\\n        }\\n      },\\n      nohlsearch: function(cm) {\\n        clearSearchHighlight(cm);\\n      },\\n      yank: function (cm) {\\n        var cur = copyCursor(cm.getCursor());\\n        var line = cur.line;\\n        var lineText = cm.getLine(line);\\n        vimGlobalState.registerController.pushText(\\n          '0', 'yank', lineText, true, true);\\n      },\\n      delmarks: function(cm, params) {\\n        if (!params.argString || !trim(params.argString)) {\\n          showConfirm(cm, 'Argument required');\\n          return;\\n        }\\n\\n        var state = cm.state.vim;\\n        var stream = new CodeMirror.StringStream(trim(params.argString));\\n        while (!stream.eol()) {\\n          stream.eatSpace();\\n\\n          // Record the streams position at the beginning of the loop for use\\n          // in error messages.\\n          var count = stream.pos;\\n\\n          if (!stream.match(/[a-zA-Z]/, false)) {\\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\\n            return;\\n          }\\n\\n          var sym = stream.next();\\n          // Check if this symbol is part of a range\\n          if (stream.match('-', true)) {\\n            // This symbol is part of a range.\\n\\n            // The range must terminate at an alphabetic character.\\n            if (!stream.match(/[a-zA-Z]/, false)) {\\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\\n              return;\\n            }\\n\\n            var startMark = sym;\\n            var finishMark = stream.next();\\n            // The range must terminate at an alphabetic character which\\n            // shares the same case as the start of the range.\\n            if (isLowerCase(startMark) && isLowerCase(finishMark) ||\\n                isUpperCase(startMark) && isUpperCase(finishMark)) {\\n              var start = startMark.charCodeAt(0);\\n              var finish = finishMark.charCodeAt(0);\\n              if (start >= finish) {\\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\\n                return;\\n              }\\n\\n              // Because marks are always ASCII values, and we have\\n              // determined that they are the same case, we can use\\n              // their char codes to iterate through the defined range.\\n              for (var j = 0; j <= finish - start; j++) {\\n                var mark = String.fromCharCode(start + j);\\n                delete state.marks[mark];\\n              }\\n            } else {\\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\\n              return;\\n            }\\n          } else {\\n            // This symbol is a valid mark, and is not part of a range.\\n            delete state.marks[sym];\\n          }\\n        }\\n      }\\n    };\\n\\n    var exCommandDispatcher = new ExCommandDispatcher();\\n\\n    /**\\n    * @param {CodeMirror} cm CodeMirror instance we are in.\\n    * @param {boolean} confirm Whether to confirm each replace.\\n    * @param {Cursor} lineStart Line to start replacing from.\\n    * @param {Cursor} lineEnd Line to stop replacing at.\\n    * @param {RegExp} query Query for performing matches with.\\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\\n    *     $2, etc for replacing captured groups using Javascript replace.\\n    * @param {function()} callback A callback for when the replace is done.\\n    */\\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query,\\n        replaceWith, callback) {\\n      // Set up all the functions.\\n      cm.state.vim.exMode = true;\\n      var done = false;\\n      var lastPos = searchCursor.from();\\n      function replaceAll() {\\n        cm.operation(function() {\\n          while (!done) {\\n            replace();\\n            next();\\n          }\\n          stop();\\n        });\\n      }\\n      function replace() {\\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\\n        var newText = text.replace(query, replaceWith);\\n        searchCursor.replace(newText);\\n      }\\n      function next() {\\n        // The below only loops to skip over multiple occurrences on the same\\n        // line when 'global' is not true.\\n        while(searchCursor.findNext() &&\\n              isInRange(searchCursor.from(), lineStart, lineEnd)) {\\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\\n            continue;\\n          }\\n          cm.scrollIntoView(searchCursor.from(), 30);\\n          cm.setSelection(searchCursor.from(), searchCursor.to());\\n          lastPos = searchCursor.from();\\n          done = false;\\n          return;\\n        }\\n        done = true;\\n      }\\n      function stop(close) {\\n        if (close) { close(); }\\n        cm.focus();\\n        if (lastPos) {\\n          cm.setCursor(lastPos);\\n          var vim = cm.state.vim;\\n          vim.exMode = false;\\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\\n        }\\n        if (callback) { callback(); }\\n      }\\n      function onPromptKeyDown(e, _value, close) {\\n        // Swallow all keys.\\n        CodeMirror.e_stop(e);\\n        var keyName = CodeMirror.keyName(e);\\n        switch (keyName) {\\n          case 'Y':\\n            replace(); next(); break;\\n          case 'N':\\n            next(); break;\\n          case 'A':\\n            // replaceAll contains a call to close of its own. We don't want it\\n            // to fire too early or multiple times.\\n            var savedCallback = callback;\\n            callback = undefined;\\n            cm.operation(replaceAll);\\n            callback = savedCallback;\\n            break;\\n          case 'L':\\n            replace();\\n            // fall through and exit.\\n          case 'Q':\\n          case 'Esc':\\n          case 'Ctrl-C':\\n          case 'Ctrl-[':\\n            stop(close);\\n            break;\\n        }\\n        if (done) { stop(close); }\\n        return true;\\n      }\\n\\n      // Actually do replace.\\n      next();\\n      if (done) {\\n        showConfirm(cm, 'No matches for ' + query.source);\\n        return;\\n      }\\n      if (!confirm) {\\n        replaceAll();\\n        if (callback) { callback(); }\\n        return;\\n      }\\n      showPrompt(cm, {\\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\\n        onKeyDown: onPromptKeyDown\\n      });\\n    }\\n\\n    CodeMirror.keyMap.vim = {\\n      attach: attachVimMap,\\n      detach: detachVimMap,\\n      call: cmKey\\n    };\\n\\n    function exitInsertMode(cm) {\\n      var vim = cm.state.vim;\\n      var macroModeState = vimGlobalState.macroModeState;\\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\\n      var isPlaying = macroModeState.isPlaying;\\n      var lastChange = macroModeState.lastInsertModeChanges;\\n      if (!isPlaying) {\\n        cm.off('change', onChange);\\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\\n      }\\n      if (!isPlaying && vim.insertModeRepeat > 1) {\\n        // Perform insert mode repeat for commands like 3,a and 3,o.\\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1,\\n            true /** repeatForInsert */);\\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\\n      }\\n      delete vim.insertModeRepeat;\\n      vim.insertMode = false;\\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch-1);\\n      cm.setOption('keyMap', 'vim');\\n      cm.setOption('disableInput', true);\\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\\n      // update the \\\". register before exiting insert mode\\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\\n      CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"normal\\\"});\\n      if (macroModeState.isRecording) {\\n        logInsertModeChange(macroModeState);\\n      }\\n    }\\n\\n    function _mapCommand(command) {\\n      defaultKeymap.unshift(command);\\n    }\\n\\n    function mapCommand(keys, type, name, args, extra) {\\n      var command = {keys: keys, type: type};\\n      command[type] = name;\\n      command[type + \\\"Args\\\"] = args;\\n      for (var key in extra)\\n        command[key] = extra[key];\\n      _mapCommand(command);\\n    }\\n\\n    // The timeout in milliseconds for the two-character ESC keymap should be\\n    // adjusted according to your typing speed to prevent false positives.\\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\\n\\n    CodeMirror.keyMap['vim-insert'] = {\\n      // TODO: override navigation keys so that Esc will cancel automatic\\n      // indentation from o, O, i_<CR>\\n      fallthrough: ['default'],\\n      attach: attachVimMap,\\n      detach: detachVimMap,\\n      call: cmKey\\n    };\\n\\n    CodeMirror.keyMap['vim-replace'] = {\\n      'Backspace': 'goCharLeft',\\n      fallthrough: ['vim-insert'],\\n      attach: attachVimMap,\\n      detach: detachVimMap,\\n      call: cmKey\\n    };\\n\\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\\n      var register = vimGlobalState.registerController.getRegister(registerName);\\n      if (registerName == ':') {\\n        // Read-only register containing last Ex command.\\n        if (register.keyBuffer[0]) {\\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\\n        }\\n        macroModeState.isPlaying = false;\\n        return;\\n      }\\n      var keyBuffer = register.keyBuffer;\\n      var imc = 0;\\n      macroModeState.isPlaying = true;\\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\\n      for (var i = 0; i < keyBuffer.length; i++) {\\n        var text = keyBuffer[i];\\n        var match, key;\\n        while (text) {\\n          // Pull off one command key, which is either a single character\\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\\n          match = (/<\\\\w+-.+?>|<\\\\w+>|./).exec(text);\\n          key = match[0];\\n          text = text.substring(match.index + key.length);\\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\\n          if (vim.insertMode) {\\n            var changes = register.insertModeChanges[imc++].changes;\\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes =\\n                changes;\\n            repeatInsertModeChanges(cm, changes, 1);\\n            exitInsertMode(cm);\\n          }\\n        }\\n      }\\n      macroModeState.isPlaying = false;\\n    }\\n\\n    function logKey(macroModeState, key) {\\n      if (macroModeState.isPlaying) { return; }\\n      var registerName = macroModeState.latestRegister;\\n      var register = vimGlobalState.registerController.getRegister(registerName);\\n      if (register) {\\n        register.pushText(key);\\n      }\\n    }\\n\\n    function logInsertModeChange(macroModeState) {\\n      if (macroModeState.isPlaying) { return; }\\n      var registerName = macroModeState.latestRegister;\\n      var register = vimGlobalState.registerController.getRegister(registerName);\\n      if (register && register.pushInsertModeChanges) {\\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\\n      }\\n    }\\n\\n    function logSearchQuery(macroModeState, query) {\\n      if (macroModeState.isPlaying) { return; }\\n      var registerName = macroModeState.latestRegister;\\n      var register = vimGlobalState.registerController.getRegister(registerName);\\n      if (register && register.pushSearchQuery) {\\n        register.pushSearchQuery(query);\\n      }\\n    }\\n\\n    /**\\n     * Listens for changes made in insert mode.\\n     * Should only be active in insert mode.\\n     */\\n    function onChange(cm, changeObj) {\\n      var macroModeState = vimGlobalState.macroModeState;\\n      var lastChange = macroModeState.lastInsertModeChanges;\\n      if (!macroModeState.isPlaying) {\\n        while(changeObj) {\\n          lastChange.expectCursorActivityForChange = true;\\n          if (lastChange.ignoreCount > 1) {\\n            lastChange.ignoreCount--;\\n          } else if (changeObj.origin == '+input' || changeObj.origin == 'paste'\\n              || changeObj.origin === undefined /* only in testing */) {\\n            var selectionCount = cm.listSelections().length;\\n            if (selectionCount > 1)\\n              lastChange.ignoreCount = selectionCount;\\n            var text = changeObj.text.join('\\\\n');\\n            if (lastChange.maybeReset) {\\n              lastChange.changes = [];\\n              lastChange.maybeReset = false;\\n            }\\n            if (text) {\\n              if (cm.state.overwrite && !/\\\\n/.test(text)) {\\n                lastChange.changes.push([text]);\\n              } else {\\n                lastChange.changes.push(text);\\n              }\\n            }\\n          }\\n          // Change objects may be chained with next.\\n          changeObj = changeObj.next;\\n        }\\n      }\\n    }\\n\\n    /**\\n    * Listens for any kind of cursor activity on CodeMirror.\\n    */\\n    function onCursorActivity(cm) {\\n      var vim = cm.state.vim;\\n      if (vim.insertMode) {\\n        // Tracking cursor activity in insert mode (for macro support).\\n        var macroModeState = vimGlobalState.macroModeState;\\n        if (macroModeState.isPlaying) { return; }\\n        var lastChange = macroModeState.lastInsertModeChanges;\\n        if (lastChange.expectCursorActivityForChange) {\\n          lastChange.expectCursorActivityForChange = false;\\n        } else {\\n          // Cursor moved outside the context of an edit. Reset the change.\\n          lastChange.maybeReset = true;\\n        }\\n      } else if (!cm.curOp.isVimOp) {\\n        handleExternalSelection(cm, vim);\\n      }\\n      if (vim.visualMode) {\\n        updateFakeCursor(cm);\\n      }\\n    }\\n    function updateFakeCursor(cm) {\\n      var vim = cm.state.vim;\\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\\n      var to = offsetCursor(from, 0, 1);\\n      if (vim.fakeCursor) {\\n        vim.fakeCursor.clear();\\n      }\\n      vim.fakeCursor = cm.markText(from, to, {className: 'cm-animate-fat-cursor'});\\n    }\\n    function handleExternalSelection(cm, vim) {\\n      var anchor = cm.getCursor('anchor');\\n      var head = cm.getCursor('head');\\n      // Enter or exit visual mode to match mouse selection.\\n      if (vim.visualMode && !cm.somethingSelected()) {\\n        exitVisualMode(cm, false);\\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\\n        vim.visualMode = true;\\n        vim.visualLine = false;\\n        CodeMirror.signal(cm, \\\"vim-mode-change\\\", {mode: \\\"visual\\\"});\\n      }\\n      if (vim.visualMode) {\\n        // Bind CodeMirror selection model to vim selection model.\\n        // Mouse selections are considered visual characterwise.\\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\\n        head = offsetCursor(head, 0, headOffset);\\n        anchor = offsetCursor(anchor, 0, anchorOffset);\\n        vim.sel = {\\n          anchor: anchor,\\n          head: head\\n        };\\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\\n      } else if (!vim.insertMode) {\\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\\n        vim.lastHPos = cm.getCursor().ch;\\n      }\\n    }\\n\\n    /** Wrapper for special keys pressed in insert mode */\\n    function InsertModeKey(keyName) {\\n      this.keyName = keyName;\\n    }\\n\\n    /**\\n    * Handles raw key down events from the text area.\\n    * - Should only be active in insert mode.\\n    * - For recording deletes in insert mode.\\n    */\\n    function onKeyEventTargetKeyDown(e) {\\n      var macroModeState = vimGlobalState.macroModeState;\\n      var lastChange = macroModeState.lastInsertModeChanges;\\n      var keyName = CodeMirror.keyName(e);\\n      if (!keyName) { return; }\\n      function onKeyFound() {\\n        if (lastChange.maybeReset) {\\n          lastChange.changes = [];\\n          lastChange.maybeReset = false;\\n        }\\n        lastChange.changes.push(new InsertModeKey(keyName));\\n        return true;\\n      }\\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\\n      }\\n    }\\n\\n    /**\\n     * Repeats the last edit, which includes exactly 1 command and at most 1\\n     * insert. Operator and motion commands are read from lastEditInputState,\\n     * while action commands are read from lastEditActionCommand.\\n     *\\n     * If repeatForInsert is true, then the function was called by\\n     * exitInsertMode to repeat the insert mode changes the user just made. The\\n     * corresponding enterInsertMode call was made with a count.\\n     */\\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\\n      var macroModeState = vimGlobalState.macroModeState;\\n      macroModeState.isPlaying = true;\\n      var isAction = !!vim.lastEditActionCommand;\\n      var cachedInputState = vim.inputState;\\n      function repeatCommand() {\\n        if (isAction) {\\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\\n        } else {\\n          commandDispatcher.evalInput(cm, vim);\\n        }\\n      }\\n      function repeatInsert(repeat) {\\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\\n          // For some reason, repeat cw in desktop VIM does not repeat\\n          // insert mode changes. Will conform to that behavior.\\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\\n          var changeObject = macroModeState.lastInsertModeChanges;\\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\\n        }\\n      }\\n      vim.inputState = vim.lastEditInputState;\\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\\n        // o and O repeat have to be interlaced with insert repeats so that the\\n        // insertions appear on separate lines instead of the last line.\\n        for (var i = 0; i < repeat; i++) {\\n          repeatCommand();\\n          repeatInsert(1);\\n        }\\n      } else {\\n        if (!repeatForInsert) {\\n          // Hack to get the cursor to end up at the right place. If I is\\n          // repeated in insert mode repeat, cursor will be 1 insert\\n          // change set left of where it should be.\\n          repeatCommand();\\n        }\\n        repeatInsert(repeat);\\n      }\\n      vim.inputState = cachedInputState;\\n      if (vim.insertMode && !repeatForInsert) {\\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\\n        // were called by an exitInsertMode call lower on the stack.\\n        exitInsertMode(cm);\\n      }\\n      macroModeState.isPlaying = false;\\n    }\\n\\n    function repeatInsertModeChanges(cm, changes, repeat) {\\n      function keyHandler(binding) {\\n        if (typeof binding == 'string') {\\n          CodeMirror.commands[binding](cm);\\n        } else {\\n          binding(cm);\\n        }\\n        return true;\\n      }\\n      var head = cm.getCursor('head');\\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\\n      if (inVisualBlock) {\\n        // Set up block selection again for repeating the changes.\\n        var vim = cm.state.vim;\\n        var lastSel = vim.lastSelection;\\n        var offset = getOffset(lastSel.anchor, lastSel.head);\\n        selectForInsert(cm, head, offset.line + 1);\\n        repeat = cm.listSelections().length;\\n        cm.setCursor(head);\\n      }\\n      for (var i = 0; i < repeat; i++) {\\n        if (inVisualBlock) {\\n          cm.setCursor(offsetCursor(head, i, 0));\\n        }\\n        for (var j = 0; j < changes.length; j++) {\\n          var change = changes[j];\\n          if (change instanceof InsertModeKey) {\\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\\n          } else if (typeof change == \\\"string\\\") {\\n            var cur = cm.getCursor();\\n            cm.replaceRange(change, cur, cur);\\n          } else {\\n            var start = cm.getCursor();\\n            var end = offsetCursor(start, 0, change[0].length);\\n            cm.replaceRange(change[0], start, end);\\n          }\\n        }\\n      }\\n      if (inVisualBlock) {\\n        cm.setCursor(offsetCursor(head, 0, 1));\\n      }\\n    }\\n\\n    resetVimGlobalState();\\n    return vimApi;\\n  };\\n  // Initialize Vim and make it available as an API.\\n  CodeMirror.Vim = Vim();\\n}\\n//-- );\\n\""],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpHA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;A","sourceRoot":""}